<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Legrandk&#39;s Qzone</title>
  
  
  <link href="https://www.legr4ndk.top/atom.xml" rel="self"/>
  
  <link href="https://www.legr4ndk.top/"/>
  <updated>2021-07-12T07:59:14.281Z</updated>
  <id>https://www.legr4ndk.top/</id>
  
  <author>
    <name>Legrandk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>致2023年后的你</title>
    <link href="https://www.legr4ndk.top/2023/05/24/Tango2023/"/>
    <id>https://www.legr4ndk.top/2023/05/24/Tango2023/</id>
    <published>2023-05-24T09:17:07.000Z</published>
    <updated>2021-07-12T07:59:14.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从泥土中来<br>到橱窗里去<br>有时满意<br>有时想远远逃离</p></blockquote><p>2019读的大学，到2021年，正好读完了一半，在大学时光还有一半的时候，我想给自己立几个🚩</p><ul><li><input disabled="" type="checkbox"> 大三继续看CMU-CSAPP和MIT-LA</li><li><input disabled="" type="checkbox"> 到2022.7通过 JLPT N2 等级考试</li><li><input disabled="" type="checkbox"> 到2022.8考到 TOEFL 80+ Score</li><li><input disabled="" type="checkbox"> 继续学2D/3D Rendering</li><li><input disabled="" type="checkbox"> 拼搏百天，我要上***</li></ul><p>看我最后到2023年的夏天能完成几件吧</p><p>插Flag不拔也不是个事，不如插得明显，引众人监督</p><p>共勉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从泥土中来&lt;br&gt;到橱窗里去&lt;br&gt;有时满意&lt;br&gt;有时想远远逃离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2019读的大学，到2021年，正好读完了一半，在大学时光还有一半的时候，我想给自己立几个🚩&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input d</summary>
      
    
    
    
    <category term="个人感悟" scheme="https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="misc" scheme="https://www.legr4ndk.top/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理实验报告</title>
    <link href="https://www.legr4ndk.top/2021/07/04/ComputerArch/"/>
    <id>https://www.legr4ndk.top/2021/07/04/ComputerArch/</id>
    <published>2021-07-04T03:58:07.000Z</published>
    <updated>2021-07-04T04:18:50.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请选择你想看的实验"><a href="#请选择你想看的实验" class="headerlink" title="请选择你想看的实验"></a>请选择你想看的实验</h2><script>        function clickButton() {            var se = document.querySelector('#s');            var em = document.querySelector('#e');            var i = se.selectedIndex + 1;            console.log(i);            em.src = `${i}.pdf`;        }</script><select id="s">        <option value="1">1</option>        <option value="2">2</option>        <option value="3">3</option>        <option value="4">4</option>        <option value="5">5</option>        <option value="6">6</option>        <option value="7">7</option>        <option value="8">8</option>        <option value="9">9</option>    </select>&nbsp;<input type="button" id="button1" value="确认" onclick="clickButton()"><hr><div class="row"><embed id="e" src="1.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;请选择你想看的实验&quot;&gt;&lt;a href=&quot;#请选择你想看的实验&quot; class=&quot;headerlink&quot; title=&quot;请选择你想看的实验&quot;&gt;&lt;/a&gt;请选择你想看的实验&lt;/h2&gt;&lt;script&gt;
        function clickButton() {
   </summary>
      
    
    
    
    <category term="学习" scheme="https://www.legr4ndk.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="study" scheme="https://www.legr4ndk.top/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>当代大学牲的正义演讲（日语版）</title>
    <link href="https://www.legr4ndk.top/2021/07/04/origay/"/>
    <id>https://www.legr4ndk.top/2021/07/04/origay/</id>
    <published>2021-07-04T03:40:18.000Z</published>
    <updated>2021-07-04T03:42:00.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>也许，我可以整个好活？</p></blockquote><p>俺(おれ)たちはどんな困難(こんなん)あっても</p><p>恐(おそ)れないで</p><p>笑(わら)って迎(むか)え</p><p>恐怖(きょうふ)を取り除(のぞ)く最良(さいりょう)の方法(ほうほう)は</p><p>恐怖(きょうふ)に立(た)ち向(む)かうことだ</p><p>堅持(けんじ)はこそ勝利(しょうり)だ</p><p>頑張(がんば)ろう！オーリゲー！！！😫</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;也许，我可以整个好活？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俺(おれ)たちはどんな困難(こんなん)あっても&lt;/p&gt;
&lt;p&gt;恐(おそ)れないで&lt;/p&gt;
&lt;p&gt;笑(わら)って迎(むか)え&lt;/p&gt;
&lt;p&gt;恐怖(きょうふ)を取り除(のぞ)く最良(さい</summary>
      
    
    
    
    <category term="耍" scheme="https://www.legr4ndk.top/categories/%E8%80%8D/"/>
    
    
    <category term="misc" scheme="https://www.legr4ndk.top/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>编译原理实验报告与实验文件</title>
    <link href="https://www.legr4ndk.top/2021/07/04/CompilerPrincipalReport/"/>
    <id>https://www.legr4ndk.top/2021/07/04/CompilerPrincipalReport/</id>
    <published>2021-07-04T03:20:41.000Z</published>
    <updated>2021-07-04T03:34:40.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p><a href="https://gitee.com/legrandk/cpe">CompilerPrincipalExperiment: 杭电计算机编译原理课程实验</a></p><p>实验有四个，输入均是用命令行参数指明输入文件，输出默认在输入文件同文件夹。</p><h3 id="LexicalAnalysis-cc"><a href="#LexicalAnalysis-cc" class="headerlink" title="LexicalAnalysis.cc"></a>LexicalAnalysis.cc</h3><p>词法分析程序，把源代码分解成二元组，可以有效识别非法字符和两类注释并且在对应报错位置予以提出。</p><h3 id="RegexParser-cc"><a href="#RegexParser-cc" class="headerlink" title="RegexParser.cc"></a>RegexParser.cc</h3><p>正规表达式解析程序，可以把正规表达式解析成后缀表达式然后输出可以生成对应的NFA的dot语言的源代码，源代码再经dot工具可以得到使用MYT算法得到的对应正规表达式的NFA。</p><p><strong>注意，它的输入是单纯正规表达式</strong></p><h3 id="RecursiveDownParsing-cc"><a href="#RecursiveDownParsing-cc" class="headerlink" title="RecursiveDownParsing.cc"></a>RecursiveDownParsing.cc</h3><p>递归下降子程序，可以实现LL(1)文法的语句的合法性的鉴别，具体文法见测试样例。</p><p><strong>注意，它的输入是经词法分析处理的表达式的二元组</strong></p><h3 id="LL1Parser-cc"><a href="#LL1Parser-cc" class="headerlink" title="LL1Parser.cc"></a>LL1Parser.cc</h3><p>LL(1)分析程序，可以实现LL(1)文法的语句的合法性的鉴别，具体文法见测试样例。</p><p><strong>注意，它的输入是经词法分析处理的表达式的二元组</strong></p><h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><div class="row">    <embed src="CPReport.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验代码&quot;&gt;&lt;a href=&quot;#实验代码&quot; class=&quot;headerlink&quot; title=&quot;实验代码&quot;&gt;&lt;/a&gt;实验代码&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/legrandk/cpe&quot;&gt;CompilerPrincipalExpe</summary>
      
    
    
    
    <category term="学习" scheme="https://www.legr4ndk.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="study" scheme="https://www.legr4ndk.top/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Knuth洗牌算法</title>
    <link href="https://www.legr4ndk.top/2021/03/13/KnuthShuffle/"/>
    <id>https://www.legr4ndk.top/2021/03/13/KnuthShuffle/</id>
    <published>2021-03-13T04:54:52.000Z</published>
    <updated>2021-03-14T15:26:12.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Knuth算法是一种非常常用的洗牌算法，它在很多方面都有着广泛的应用。<br>本文需要一定的概率论知识，包括排列组合、古典概型和条件概率。</p></blockquote><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>洗牌其实是一种取随机的算法，只有每一面牌在序列中的任意位置出现的概率都相同的时候，我们才可以说一个随机算法是公平的。</p><p>最容易想到的公平洗牌方式大概是这种：有n张牌，这n张牌自由组合共有<code>n!</code>个组合，每次只要随机且等可能地从这<code>n!</code>种情况内选取一项，就可以得到一种随机的排列，也就是一次洗牌。那么问题就来了，n在小的时候，<code>n!</code>的数值大小仍可计算，而当n逐渐增大到一定值的时候，<code>n!</code>就会变得不可计算了起来，要随机取得一个情况要耗费的开支太大，时间复杂度达到了<code>o(n!)</code>。</p><p>那么，有没有别的方法可以保证一次洗牌开销没那么大而每张牌在任一位置的概率都相等呢？</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>我们可以借鉴下插入排序的思想。</p><p>比如有5张牌需要我去打乱位置，我就直接留五个空位，然后从第一个空位开始，从原来五张牌中随机选择一张，填到1号空位中，然后在原来的五张牌中抹去那张，还剩下4张。接下来来到二号空位，继续从剩下的4张牌中随机选择一张，放入第二个空位中，再在剩余的四张牌中抹去被选中的那一张……依次类推，你会得到一个序列，那就是洗牌的结果。那么，它是公平的吗？让我们来算算它的概率。</p><ul><li>任一牌出现在第一个位置的概率，即为它第一次就被选中的概率，为<code>1/5</code>。</li><li>任一牌出现在第二个位置的概率，即为它第一次落选，但它在第二次被选中的概率，为<code>4/5 * 1/4 = 1/5</code>。</li><li>任一牌出现在第三个位置的概率，即为它第一、二次落选，但在第三次被选中的概率，为<code>4/5 * 3/4 * 1/3 = 1/5</code>。</li><li>……</li></ul><p>依此类推，跟据条件概率公式推导，你可以发现一张牌出现在任一位置的概率都为<code>1/5</code>即<code>1/n</code>，说明此洗牌算法是公平的。我们分析这个算法的时间复杂度，可以发现其时间复杂度为<code>o(n)</code>，也就是说他遍历一遍牌，就能实现洗牌的操作。但是我们发现，我们仍需要请求额外的存储空间来存储洗完的牌，空间复杂度方面还可以优化，而且，如何标记已经被选择过的牌，也是一个问题，这些都会带来额外的开支。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>那么我们如何优化它的效率呢？我们注意到，每次随机选完牌之后，下一次选牌仍是随机的，那么在洗牌前的数据组中，牌的顺序是无关紧要的。我们完全可以把取数据然后放数据的过程，改为交换数据的过程。从第一个位置开始洗牌，从整个数组里所有元素中随机选择一个位置的内容与1号位置的元素交换，完成第一轮的洗牌。第二轮的时候，我们默认1号位置已经完成洗牌，从2~n号位置中选择一个元素与2号位置的元素交换位置，这样二号位置的洗牌也完成了……依此类推，把每个位置的牌都遍历一次，即可完成一次洗牌。这就是Knuth Shuffle洗牌算法。</p><p>使用条件概率公式，你可以很轻易地算出，每一张牌出现于任一位置的概率均为<code>1/n</code>，而且，Knuth算法每次会把排完序的数据排除在下一次循环之外，完美解决了已经洗完的部分的标记问题，它不需要额外的存储空间，只需要在交换两个数据的时候使用一个临时变量作为中间交换量即可，效率与空间利用率比之前高了很多。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是使用C#实现的Knuth算法，可以把<code>{1, 2, 3, 4, 5}</code>五张牌乱序洗牌后输出。</p><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">KnuthShuffle</span><br>{<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    {<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><br><span class="hljs-function"></span>        {<br>            <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>            <span class="hljs-comment">//随机数生成法千千万，这个用的是Unix时间戳做种子</span><br>            <span class="hljs-comment">//你要是想搞事，完全可以换成随机性更强的随机数生成方法</span><br>            Random random = <span class="hljs-keyword">new</span> Random(); <br>            <br>            <span class="hljs-comment">//Knuth洗牌算法其实就下面这么三行，非常简单</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.Length; i++)<br>            {<br>                Swap(<span class="hljs-keyword">ref</span> arr[i], <span class="hljs-keyword">ref</span> arr[random.Next(i, arr.Length)]);<br>            }<br>            <span class="hljs-comment">//其实你要极致优化的话，听说从后面开始向前洗牌效率更高（这个是玄学我不确定）</span><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> variable <span class="hljs-keyword">in</span> arr)<br>            {<br>                Console.WriteLine(variable);<br>            }<br>        }<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">ref</span> <span class="hljs-keyword">int</span> y</span>)</span><br><span class="hljs-function"></span>        {<br>            <span class="hljs-keyword">int</span> temp = x;<br>            x = y;<br>            y = temp;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="它有什么用？"><a href="#它有什么用？" class="headerlink" title="它有什么用？"></a>它有什么用？</h1><p>最简单且直观的用途就是：他能帮我们洗牌，然后实现牌类游戏的洗牌操作。</p><p>比如对于经典牌类游戏斗地主，你可以把54张牌的牌面塞到一个容器内，然后通过Knuth算法实现洗牌，然后抽出3张作为地主牌后按次序分成3组，每个人拿到的与地主牌就都是随机的，完美的符合随机洗牌的要求，再配合排序算法，可以快速地把牌按顺序排列完毕，就可以来一把紧张刺激的斗地主了。</p><p>那么一维的可以，二维的可以吗？事实上当然可以，比如我们同样很熟悉的小游戏扫雷，把雷和空格均匀地洗开之后，再按二维堆叠，就可以形成一幅随机的雷图了，接下来就是跟据数据来判断要在空白格子里填的数据了。</p><p>事实上，我们最常见的Knuth Shuffle的运用，还是在我们听歌的那件事上。市场上几乎所有的音乐播放软件的“随机播放”功能，其实都是“伪随机”，就是通过Knuth算法实现的乱序播放歌曲。这类音乐软件会在你打开随机播放功能后对你的歌单进行一次Knuth Shuffle，然后按序播放这个“洗牌后”的歌单里的歌，但是对于用户来说，确实是看起来像随机播放的了。</p><p>那么问题来啦，我们怎么判断你的音乐App是使用的“真随机播放”还是“伪随机播放”呢？很简单，打开你的音乐软件的随机播放功能，音乐开始播放后，轻按“下一首”按钮，再轻按“上一首”功能，如果它回到了原来的那首歌，那它毫无疑问是“伪随机播放”了。“真随机播放”的话，切歌时它会随机跳到下一首去，你是回不去的了~</p><p>不过话说回来，如果我是要开发“真随机播放”功能的程序员的话，我可能会选择在“随机播放”模式下，把“上一首”按钮和“下一首”按钮的功能都设置成洗完牌后的随机打乱的歌单里的下一首。永远都往下一首播放的话，你也回不去原来那首歌了，体验上来说，因为都是切到下一首没被听过的音乐，应该与每次都生成随机数然后去随机找歌的“真随机播放”体验一致了，而且感觉这种处理方法的开销好像比每次生成随机数的情况要小。（<strong>发现华点😏</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Knuth算法是一种非常常用的洗牌算法，它在很多方面都有着广泛的应用。&lt;br&gt;本文需要一定的概率论知识，包括排列组合、古典概型和条件概率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=</summary>
      
    
    
    
    <category term="算法" scheme="https://www.legr4ndk.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algorithm" scheme="https://www.legr4ndk.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章快速上手Nginx服务器</title>
    <link href="https://www.legr4ndk.top/2021/03/08/NginxCrashCourse/"/>
    <id>https://www.legr4ndk.top/2021/03/08/NginxCrashCourse/</id>
    <published>2021-03-08T12:21:10.000Z</published>
    <updated>2021-03-14T10:17:28.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇文章解决Nginx基础操作</p><p>本文基于Debian操作系统演示。（不要问我服务器为啥不用CentOS，问就是它无了</p><p>【恶 灵 退 散】前方灵魂画手出没</p></blockquote><h1 id="啥是Nginx"><a href="#啥是Nginx" class="headerlink" title="啥是Nginx"></a>啥是Nginx</h1><p>比如你写了个HTML丢在服务器上，你输入这个服务器的域名去访问，服务器不知道要拿什么给你，也就不能访问到页面。Nginx就跟Apache一样，会监听服务器的80端口（就是http协议浏览器默认端口），有人发请求，它就把它一个特殊文件夹里的网页文件返回回去。也就是说，它是一个Web服务器应用。</p><p>Nginx的并发量非常大，能达到50000左右，是Tomcat的很多倍，在部署JavaWeb服务的时候，一个Tomcat处理的并发量有限，如果想要同时处理更多的请求，就需要有一个中间的服务器作为转发。Nginx很强（它是老毛子写的），它有两个很重要的功能，就是<strong>负载均衡</strong>和<strong>反向代理</strong>。这俩后面再说。</p><h1 id="怎么安装"><a href="#怎么安装" class="headerlink" title="怎么安装"></a>怎么安装</h1><p>我用的Debian。（CentOS变成Red Hat的上游版了，不可能再用了的~）</p><p>这次咱从源代码手动编译出Nginx，相对于直接下载得到的Nginx，自己编译的不容易有依赖问题。</p><p>你需要系统里先有C语言编译器，比如Debian类Linux可以这样：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">apt install build-essential <span class="hljs-comment"># 需要权限，这玩意里面包括了编译要用的一堆东西</span><br></code></pre></td></tr></tbody></table></figure><p>先去 <a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> 下载Nginx，是个tar.gz包，然后解压：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">tar -xzvf nginx-xxx.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压完进入文件夹：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nginx-xxx<br><span class="hljs-comment"># 目录结构如下</span><br>drwxr-xr-x 6 1001 1001   4096 Mar  8 16:21 auto<br>-rw-r--r-- 1 1001 1001 302863 Apr 21  2020 CHANGES<br>-rw-r--r-- 1 1001 1001 462213 Apr 21  2020 CHANGES.ru<br>drwxr-xr-x 2 1001 1001   4096 Mar  8 16:21 conf<br>-rwxr-xr-x 1 1001 1001   2502 Apr 21  2020 configure<br>drwxr-xr-x 4 1001 1001   4096 Mar  8 16:21 contrib<br>drwxr-xr-x 2 1001 1001   4096 Mar  8 16:21 html<br>-rw-r--r-- 1 1001 1001   1397 Apr 21  2020 LICENSE<br>drwxr-xr-x 2 1001 1001   4096 Mar  8 16:21 man<br>-rw-r--r-- 1 1001 1001     49 Apr 21  2020 README<br>drwxr-xr-x 9 1001 1001   4096 Mar  8 16:21 src<br></code></pre></td></tr></tbody></table></figure><p>执行目录下的configure文件来配置make与依赖，然后使用make来编译、安装：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">./configure<br>make<br>make install<br><br><span class="hljs-comment"># 注意：以下是可能会需要的依赖，make不成功就把下面的也装了（yum包管理器用户自己找去）</span><br>apt install libpcre3 libpcre3-dev<br>apt install openssl libssl-dev<br>apt install zlib1g<br>apt install zlib1g.dev<br></code></pre></td></tr></tbody></table></figure><p>然后查找Nginx在哪：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">whereis nginx<br><span class="hljs-comment"># 得到 nginx: /usr/local/nginx</span><br></code></pre></td></tr></tbody></table></figure><p>这样就装完了Nginx。</p><h1 id="Nginx文件结构"><a href="#Nginx文件结构" class="headerlink" title="Nginx文件结构"></a>Nginx文件结构</h1><p>我们可以得到以下文件树：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">.<br>├── conf <span class="hljs-comment"># 配置文件目录</span><br>│&nbsp;&nbsp; ├── fastcgi.conf<br>│&nbsp;&nbsp; ├── fastcgi.conf.default<br>│&nbsp;&nbsp; ├── fastcgi_params<br>│&nbsp;&nbsp; ├── fastcgi_params.default<br>│&nbsp;&nbsp; ├── koi-utf<br>│&nbsp;&nbsp; ├── koi-win<br>│&nbsp;&nbsp; ├── mime.types<br>│&nbsp;&nbsp; ├── mime.types.default<br>│&nbsp;&nbsp; ├── nginx.conf<br>│&nbsp;&nbsp; ├── nginx.conf.default<br>│&nbsp;&nbsp; ├── scgi_params<br>│&nbsp;&nbsp; ├── scgi_params.default<br>│&nbsp;&nbsp; ├── uwsgi_params<br>│&nbsp;&nbsp; ├── uwsgi_params.default<br>│&nbsp;&nbsp; └── win-utf<br>├── html <span class="hljs-comment"># 网页文件存放目录</span><br>│&nbsp;&nbsp; ├── 50x.html<br>│&nbsp;&nbsp; └── index.html<br>├── logs <span class="hljs-comment"># 日志文件存放目录</span><br>└── sbin <span class="hljs-comment"># 编译所得的nginx二进制文件存放目录</span><br>    └── nginx<br></code></pre></td></tr></tbody></table></figure><p>以下介绍一下四大文件夹</p><h2 id="conf-配置文件目录"><a href="#conf-配置文件目录" class="headerlink" title="conf 配置文件目录"></a>conf 配置文件目录</h2><p>主要有一个文件：<code>nginx.conf</code>，已经去除了所有的注释以及一些非必须的内容。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">worker_processes  1; <span class="hljs-comment">#工作进程的数量</span><br><br>events {<br>    worker_connections  1024; <span class="hljs-comment"># 每个工作进程的最大连接数</span><br>}<br><br><span class="hljs-comment"># 代表此处配置的是http规则</span><br>http { <br>    include       mime.types; <span class="hljs-comment"># 定义mine类型</span><br>    default_type  application/octet-stream;<br><br>    sendfile        on; <br>    <span class="hljs-comment"># 是否使用sendfile函数来实现文件输出，一般网页建议为on，下载服务器，可以设置为off来降低系统压力</span><br><br>    keepalive_timeout  65; <span class="hljs-comment"># 响应超时时间</span><br><br>    server {<br>        listen       80; <span class="hljs-comment"># http协议监听端口为80</span><br>        server_name  localhost; <span class="hljs-comment"># 配置访问域名</span><br><br>        location / { <span class="hljs-comment"># 访问 / 路径时展示</span><br>            root   html; <span class="hljs-comment"># 网站的网页存放路径，可以改到别处</span><br>            index  index.html index.htm; <span class="hljs-comment"># 默认主页文件</span><br>        }<br><br>        error_page   500 502 503 504  /50x.html; <span class="hljs-comment"># 错误网页，包含50x的错误</span><br>        location = /50x.html { <span class="hljs-comment"># 50x错误时返回的网页的路径</span><br>            root   html;<br>        }<br><br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="html-网页文件目录"><a href="#html-网页文件目录" class="headerlink" title="html 网页文件目录"></a>html 网页文件目录</h2><p>此目录存放了该服务器受到http请求时返回给浏览器的网页文件，你可以在这边放html、css、js甚至php等网页文件（如果你的系统支持的话），以及服务器报错时显示的文件（比如50x、404等）。</p><h2 id="logs-日志文件目录"><a href="#logs-日志文件目录" class="headerlink" title="logs 日志文件目录"></a>logs 日志文件目录</h2><p>这边会有几个日志文件。</p><p>access.log会记录Nginx每次被访问的信息，包括访问地址，时间、设备、内容等信息。</p><p>error.log会记录Nginx每次出错的时间，内容等信息。</p><p>nginx.pid会记录Nginx在系统中的进程ID（即PID）。</p><h2 id="sbin-二进制文件目录"><a href="#sbin-二进制文件目录" class="headerlink" title="sbin 二进制文件目录"></a>sbin 二进制文件目录</h2><p>这边只有一个文件，执行它，没有任何反应，就代表你启动了Nginx。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">sudo ./nginx<br></code></pre></td></tr></tbody></table></figure><p>然后你去用域名或者ip地址什么的访问你的服务器的80端口，就可以看到这个：</p><p><img src="http://www.legr4ndk.top/img/nginx/nginx_op.png" alt="Welcome to nginx!"></p><p>看到这个就说明你成功打开Nginx了。</p><p>关于nginx有一些命令行操作：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">nginx -s stop <span class="hljs-comment"># 立即停止Nginx</span><br>nginx -s quit <span class="hljs-comment"># 关闭Nginx的所有服务再关闭Nginx</span><br>nginx -s reload <span class="hljs-comment">#改变Nginx的配置文件后重新加载配置文件，无需重启Nginx，用户无感操作</span><br>ps aux|grep nginx <span class="hljs-comment"># 查看Nginx的进程</span><br></code></pre></td></tr></tbody></table></figure><h1 id="Nginx可以做什么"><a href="#Nginx可以做什么" class="headerlink" title="Nginx可以做什么"></a>Nginx可以做什么</h1><h2 id="直接拿Nginx做PHP应用服务器"><a href="#直接拿Nginx做PHP应用服务器" class="headerlink" title="直接拿Nginx做PHP应用服务器"></a>直接拿Nginx做PHP应用服务器</h2><p>你可以直接在web服务器上安装PHP解释器与MySQL数据库，然后你可以在html内放入你写好的Web程序（包括html、css、js与php文件等）。默认访问这个服务器时，它会自动打开文件里的index.html。若要自动打开PHP文件，你需要在Nginx的配置文件中改动一处：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">location / { <span class="hljs-comment"># 访问 / 路径时展示</span><br>            root   html; <br>            index  index.html index.htm index.php; <span class="hljs-comment"># 默认主页文件，在此处添加index.php</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="反向代理（Reverse-Proxy）"><a href="#反向代理（Reverse-Proxy）" class="headerlink" title="反向代理（Reverse Proxy）"></a>反向代理（Reverse Proxy）</h2><p><img src="http://www.legr4ndk.top/img/nginx/proxy.png" alt="Proxy"></p><p>这是正向代理的示意图，客户端无法直接访问到目标服务器的时候，可以使用一个可以访问到目标服务器的中间服务器作为代理，来为客户端提供流量转发的服务。</p><p>那反向代理是怎么回事呢？</p><p>比如我们有3台服务器运行着我们的网站的服务，每个服务器都有着各自不同的ip地址。让我们假设每台服务器最多让100人同时访问。那么，当我们有200人同时访问这个网站时，用户要如何才能知道哪台服务器是有余力处理的，而又有哪台是被挤满了即将宕机的？用户当然没法知道，因为大家访问网站都是用同一个域名，比如百度，大家都只知道baidu.com，可是它实际上有很多很多的服务器架设在各地，每次访问我们都用的是同一个域名，没有人专门去访问百度1号，百度2号等服务器，这就是反向代理的作用。反向代理服务器把客户端的请求分给多个服务器，再由这个代理服务器将应用服务器上的返回包返回给客户。这样，客户只访问了一个域名，却不会导致大家都访问了一个服务器从而把服务器搞炸。示意图如下：</p><p><img src="http://www.legr4ndk.top/img/nginx/reversed.png" alt="Reverse Proxy"></p><p>这就是反向代理的作用，使用反向代理可以很方便的构建服务器集群，而这对于用户来说是无感的。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡就是Nginx反向代理时为后台的Web服务器分配请求的策略。</p><p>Nginx有很多种策略来进行负载均衡，以下简单介绍几种。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>轮询适用于在后端的Web服务器的性能都差不多的时候，Nginx会把反向代理的流量均匀分配给后台每一个服务器。像上面反向代理的图片一样，服务器1，2，3号收到的代理的数量大致一样。这样可以确保大量访问到来的时候各个服务器的负载压力都相近，不至于使某个服务器压力过大。</p><h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>理解了上面那个轮询之后，加权轮询就比较好理解了。不同于上面那一个，加权轮询更适用于后端Web服务器的性能有差异的情况下。Nginx会跟据配置文件中设置好的权重比例分配代理流量到不同的服务器上去，以实现不同性能的服务器各司其职都能最大化性能利用的功能。比如上图的1，2，3号服务器，分别最多能负载的请求数为1：2：3，那么在Nginx中配置好后，Nginx会把大约50%的流量转发到服务器3上，大约33%的流量转发到服务器2上，约17%的流量则会被转发到服务器1上。使用加权轮询策略可以尽量使服务器集群的性能最大化。（能力越大，责任越大）</p><h3 id="IP-Hash"><a href="#IP-Hash" class="headerlink" title="IP Hash"></a>IP Hash</h3><p>轮询与流量转发带来的一个很重要的问题就是一个用户两次访问这个网站，他的流量可能会被转发到不同的服务器上，之前在那个服务器上进行过的操作、存留的Session在这个新服务器上并没有，而要实现服务器集群的Session共享又十分麻烦。一个好方法是使用Redis，但是Nginx的内置IP Hash策略其实可以帮我们完美解决一个问题。当第一次你从一个IP地址访问这个网站时，Nginx会算你的IP的Hash值，然后跟据留存的Hash结果，每次来自同一IP的请求，均交给同一个服务器来执行，就可以解决Session不共享的问题了。</p><h2 id="URL重写（rewrite）"><a href="#URL重写（rewrite）" class="headerlink" title="URL重写（rewrite）"></a>URL重写（rewrite）</h2><p>该指令通过正则表达式的使用来改变URL。可以同时存在一个或者多个指令，按照顺序一次对URL进行匹配和处理。该指令可以在<code>server</code>块后者<code>location</code>块中使用<code>rewrite</code>关键字配置。</p><p>  语法：<code>rewrite regex replacement [flag];</code></p><p>定义如下</p><ul><li><strong>rewrite</strong>：指令关键字。 　</li><li><strong>regex</strong>：用来匹配URI的正则表达式。</li><li><strong>replacement</strong>：匹配成功后用来替换URI中被截取内容的字符串，默认情况如果该字符串包含“http://”、”https://“开头，则不会继续向下对URI进行其他处理，直接返回重写的URI给客户端。</li><li><strong>flag</strong>：用来设置rewrite对URI的处理行为,包含如下数据：<ul><li>last：终止在本location块中处理接收到的URI，并将此处重写的URI作为新的URI使用其他location进行处理（只是终止当前location的处理）。</li><li>break：将此处重写的URI作为一个新的URI在当前location中继续执行，并不会将新的URI转向其他location。</li><li>redirect：将重写后的URI返回个客户端，状态码是302，表明临时重定向，主要用在replacement字符串不以“http://”，“ https://”或“ $scheme” 开头。</li><li>permanent    将重写的URI返回客户端，状态码为301,指明是永久重定向。</li></ul></li></ul><h1 id="反向代理与负载均衡的实现"><a href="#反向代理与负载均衡的实现" class="headerlink" title="反向代理与负载均衡的实现"></a>反向代理与负载均衡的实现</h1><p>这边只实现一个最简单的http协议下80端口的反向代理与转发。</p><p>此处假设的情况是于<code>127.0.0.1:8080</code>与<code>127.0.0.1:8081</code>上均运行着同一个WebApp，需要把从<code>80端口</code>入口的流量以1：2的权重转发给这两个服务。</p><p>在<code>nginx.conf</code>文件下进行配置即可。（配置的部分参见上面以及下文代码的注释）</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">http { <br>    server {<br>        listen       80; <br>        server_name  localhost; <br><br>        location / { <br>            root   html;<br>            index  index.html index.htm; <br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个代码块我省去了外围的全局配置，只留下了http那一块（实际上被我省去的不能删）</p><h3 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h3><p>反向代理的实现需要先实现负载均衡。负载均衡的配置需要在<code>http协议</code>的配置区域内配置，使用关键字<code>upstream</code>:</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">http { <br>    <span class="hljs-comment"># 此处使用upstram关键字配置负载均衡，balance1为负载均衡的自定义策略名，可任意指定</span><br>    upstrean balance1{<br>        server 127.0.0.1:8080 weight=1; <span class="hljs-comment"># 每台服务器均使用server关键词声明</span><br>        server 127.0.0.1:8081 weight=1; <span class="hljs-comment"># 使用weight来声明每个服务器的权值，这边实现了轮询</span><br>    }<br>    <span class="hljs-comment"># 这边实现了加权轮询的负载均衡策略，两台服务器收到的请求数大致为1:2</span><br>    upstrean balance2{<br>        server 127.0.0.1:8080 weight=1;<br>        server 127.0.0.1:8081 weight=2;<br>    }<br>    <br>    server {<br>        <span class="hljs-comment"># 节省篇幅，这边省去</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="反向代理实现"><a href="#反向代理实现" class="headerlink" title="反向代理实现"></a>反向代理实现</h3><p>反向代理需要在<code>http协议</code>的配置区域的<code>location</code>域内配置，使用关键字<code>proxy pass</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">location / { <br>            root   html;<br>            index  index.html index.htm; <br>            <br>            <span class="hljs-comment"># 此处使用proxy pass关键字进行反向代理，使用上文声明的balance2策略</span><br>            proxy pass http://balance2; <span class="hljs-comment"># 以此方法实现Nginx对80端口的访问 / 目录的流量的反向代理</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="URL重写的实现（以http请求转https为例）"><a href="#URL重写的实现（以http请求转https为例）" class="headerlink" title="URL重写的实现（以http请求转https为例）"></a>URL重写的实现（以http请求转https为例）</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><code class="hljs bash">http { <br>    server {<br>        listen       80; <br>        server_name  localhost; <br>        <br>        rewrite ^(.*)$ https://<span class="hljs-variable">$host</span><span class="hljs-variable">$1</span> permanent; <span class="hljs-comment"># 把所有的请求，转发到https的同域名下</span><br>        <span class="hljs-comment"># 或者有另一种写法，使用return实现</span><br>        <span class="hljs-built_in">return</span> 301 https://127.0.0.1<span class="hljs-variable">$request_uri</span>; <span class="hljs-comment"># 发送301 再转新的地址</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>Nginx是个配置坑。可以配置的地方真的是，太太太太多了，性能调优也有很多骚操作。本文只是帮助你快速理解Nginx的一些工作的原理以及如何用它最主要的功能。很多其他的功能，例如动静分离（提供静态文件服务器）等操作在本文中还没有涉及，希望后面能再自己学学。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一篇文章解决Nginx基础操作&lt;/p&gt;
&lt;p&gt;本文基于Debian操作系统演示。（不要问我服务器为啥不用CentOS，问就是它无了&lt;/p&gt;
&lt;p&gt;【恶 灵 退 散】前方灵魂画手出没&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;啥是Nginx</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="server" scheme="https://www.legr4ndk.top/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章快速上手JavaScript</title>
    <link href="https://www.legr4ndk.top/2021/03/07/JavaScriptCrashCourse/"/>
    <id>https://www.legr4ndk.top/2021/03/07/JavaScriptCrashCourse/</id>
    <published>2021-03-07T14:53:45.000Z</published>
    <updated>2021-03-14T10:17:28.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观此文，你仍需有C语言、HTML、CSS基础之基础。</p><p>本文规范基本上基于ECMAScript2015（就是ES6）。</p><p>你需要认识C语言的分支与循环处理、HTML的常见标签以及CSS的基础选择器。如果你对C语言的函数指针或者函数式编程常用的lambda表达式有所理解的话，将有助你快速上手JavaScript。</p><p>（事件那边你要是懂一点WPF的event原理就更好了……不过没人学C#吧……</p></blockquote><h1 id="如何输出"><a href="#如何输出" class="headerlink" title="如何输出"></a>如何输出</h1><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(); <span class="hljs-comment">//输出信息</span><br><span class="hljs-built_in">console</span>.warn(); <span class="hljs-comment">//输出警告，是黄色的</span><br><span class="hljs-built_in">console</span>.error(); <span class="hljs-comment">//输出报错，是红色的（虽然也不会导致程序中止</span><br></code></pre></td></tr></tbody></table></figure><p>它们可以通过传入多个参数来实现一次性输出更多数据。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>通过let声明/定义变量，通过const声明常量。（不再推荐使用var）</strong></p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Alfred'</span>; <span class="hljs-comment">//name是常量，必须直接初始化，之后不可变</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">19</span>; <span class="hljs-comment">//age是变量，仍可变</span><br></code></pre></td></tr></tbody></table></figure><p>你可与使用typeof运算符来输出一个量的数据类型，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> age); <span class="hljs-comment">//向控制台输出age的类型（输出number）</span><br></code></pre></td></tr></tbody></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>用单引号或者双引号包围的字符串。</p><p>例子中我们有：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">'Hello World'</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>使用加号可以连接字符串。</p><p>可以使用模板字符串来往字符串里面填入数据（使用反引号）。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> info1 = <span class="hljs-string">'My name is '</span> + name + <span class="hljs-string">', and I am '</span> + age + <span class="hljs-string">' years old.'</span>; <span class="hljs-comment">//使用加法连接</span><br><span class="hljs-keyword">let</span> info2 = <span class="hljs-string">`My name is <span class="hljs-subst">${name}</span>, and I am <span class="hljs-subst">${age}</span> years old.`</span>; <span class="hljs-comment">//使用模板字符串</span><br><span class="hljs-comment">//info1 和 info2 两个字符串的内容一致</span><br></code></pre></td></tr></tbody></table></figure><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><p>使用字符串的<code>length</code>属性获取字符串长度。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(s.length); <span class="hljs-comment">//向控制台输出字符串s的长度（输出11）</span><br></code></pre></td></tr></tbody></table></figure><h3 id="转变字符"><a href="#转变字符" class="headerlink" title="转变字符"></a>转变字符</h3><p>使用字符串的<code>toUpperCase()</code>方法把字符串里的字母都转成大写，使用<code>toLowerCase()</code>方法把字符串里的字母都转成小写。注意，返回值才是所求的字符串，原字符串并不会改变。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(s.toUpperCase()); <span class="hljs-comment">//向控制台输出全为大写字母的字符串s（输出为HELLO WORLD）</span><br><span class="hljs-built_in">console</span>.log(s.toLowerCase()); <span class="hljs-comment">//向控制台输出全为小写字母的字符串s（输出为hello world）</span><br></code></pre></td></tr></tbody></table></figure><h3 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h3><p>使用字符串的<code>substring()</code>方法获取字符串的子串。该方法有两个参数，第一个参数代表子串从原字符串的第几个开始（下标从0开始），第二个参数代表子串在父串的第几个字符前结束。注意，第一个参数所指的字符会被包含在子串中而第二个参数所指的不会。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(s.substring(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">//向控制台输出s的自下标为2的字符开始，自下标为5的字符结束的子串（输出为llo）</span><br></code></pre></td></tr></tbody></table></figure><h3 id="将字符串分割到数组中"><a href="#将字符串分割到数组中" class="headerlink" title="将字符串分割到数组中"></a>将字符串分割到数组中</h3><p>使用字符串的<code>split()</code>方法将字符串分割到数组中。该方法有一个参数，为分割的分隔符，此方法将按此分隔符分割该字符串到数组。如果要分割每个字符，请使用参数<code>''</code>（空字符串）。注意，参数将不出现在分割完的字符串中。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">''</span>));<br>    <span class="hljs-comment">//输出["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d"]</span><br><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">' '</span>));<br>    <span class="hljs-comment">//输出["Hello", "World"]</span><br><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">'ell'</span>));<br>    <span class="hljs-comment">//输出["H", "o World"]</span><br></code></pre></td></tr></tbody></table></figure><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个数组内可以有多个数据，这些数据可以是不同类型的。</p><p>数组下标从0开始，逐项递增。</p><p>即使数组被定义为const，但仍可改变数组，只是不能给该量赋值其他数组。</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>有多种方法创建数组：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//使用构造函数创建，括号内可以传入一些值以初始化数组（也可以不传）</span><br><span class="hljs-keyword">const</span> array2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'233'</span>]; <span class="hljs-comment">//直接创建</span><br></code></pre></td></tr></tbody></table></figure><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>直接使用<code>[]</code>即可。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(array1[<span class="hljs-number">0</span>]); <span class="hljs-comment">//向控制台输出array1数组的第一项（下标为0）（输出1）</span><br></code></pre></td></tr></tbody></table></figure><h4 id="给数组添加元素"><a href="#给数组添加元素" class="headerlink" title="给数组添加元素"></a>给数组添加元素</h4><p>虽然array1只有两个元素，但是要想给它加元素，直接<code>array1[2] = 3</code>即可。注意，如果添加的位置比较不和原来的贴在一起，中间会用empty填充。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">array1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">console</span>.log(array1); <span class="hljs-comment">//输出[1, 2, 3]，长度为3</span><br>array1[<span class="hljs-number">6</span>] = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">console</span>.log(array1); <span class="hljs-comment">//输出[1, 2, 3, empty × 3, 7]，长度为7（empty也算长度）</span><br><br><span class="hljs-comment">//特殊情况：</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">-2</span>] = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//输出 [1, 2, -2: 5]，长度为2</span><br><span class="hljs-comment">//要访问下标为-2的元素，可以使用arr[-2]或者arr['-2']</span><br></code></pre></td></tr></tbody></table></figure><p>向末尾追加，可以使用数组的<code>push()</code>方法，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">array2.push(<span class="hljs-number">666</span>);<br><span class="hljs-built_in">console</span>.log(array2); <span class="hljs-comment">//输出[1, 2, '233', 666]</span><br></code></pre></td></tr></tbody></table></figure><p>向开头添加，可以使用数组的<code>unshift()</code>方法，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">array2.unshift(<span class="hljs-number">9</span>);<br><span class="hljs-built_in">console</span>.log(array2); <span class="hljs-comment">//输出[9, 1, 2, '233', 666]</span><br></code></pre></td></tr></tbody></table></figure><h4 id="去除数组中的元素"><a href="#去除数组中的元素" class="headerlink" title="去除数组中的元素"></a>去除数组中的元素</h4><p>使用数组的<code>pop()</code>方法，可以去除数组的最后一个元素，同时，此方法会返回被去除的元素。（类似于其他语音的<code>pushBack()</code>方法。）例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = array2.pop();<br><span class="hljs-built_in">console</span>.log(array2); <span class="hljs-comment">//输出[9, 1, 2, '233']</span><br><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//输出666</span><br></code></pre></td></tr></tbody></table></figure><h4 id="检查某个量是不是数组"><a href="#检查某个量是不是数组" class="headerlink" title="检查某个量是不是数组"></a>检查某个量是不是数组</h4><p>使用<code>Array.isArray()</code>方法可以检查一个量是不是数组，如果传入的参数是数组，它会返回true；否则，它会返回false。</p><h4 id="获取数组中某个值的下标"><a href="#获取数组中某个值的下标" class="headerlink" title="获取数组中某个值的下标"></a>获取数组中某个值的下标</h4><p>使用数组的<code>indexOf()</code>方法可以获取数组中该元素（由参数传入）的下标。如果参数内容不存在于数组中，该函数会返回<code>-1</code>。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(array2.indexOf(<span class="hljs-number">2</span>)); <span class="hljs-comment">//输出2</span><br><span class="hljs-built_in">console</span>.log(array2.indexOf(<span class="hljs-number">999</span>)); <span class="hljs-comment">//输出-1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>可以通过<code>for...of</code>循环遍历数组的值，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> array2) {<br>    <span class="hljs-built_in">console</span>.log(x);<br>}<br><span class="hljs-comment">//控制台会依次输出9, 1, 2, 233</span><br></code></pre></td></tr></tbody></table></figure><p>或者使用数组的<code>forEach()</code>方法进行遍历。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">array2.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{ <span class="hljs-built_in">console</span>.log(x); }); <span class="hljs-comment">//参数为回调匿名函数</span><br>array2.forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(x) ); <span class="hljs-comment">//使用λ表达式的匿名函数</span><br><span class="hljs-comment">//控制台会依次输出9, 1, 2, 233</span><br></code></pre></td></tr></tbody></table></figure><h4 id="取出数组中对象的特定属性值并生成新数组"><a href="#取出数组中对象的特定属性值并生成新数组" class="headerlink" title="取出数组中对象的特定属性值并生成新数组"></a>取出数组中对象的特定属性值并生成新数组</h4><p>可以通过数组的<code>map()</code>方法实现。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数，该回调函数需要返回特定的属性值。此方法的返回值为所求的数组。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取数组中所有对象的id</span><br><span class="hljs-keyword">const</span> x = [<br>    {<br>        id: <span class="hljs-number">1</span>,<br>        name: <span class="hljs-string">'Alfred'</span><br>    },<br>    {<br>        id: <span class="hljs-number">2</span>,<br>        name: <span class="hljs-string">'John'</span><br>    }<br>]<br><span class="hljs-keyword">const</span> ids = x.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{ <span class="hljs-keyword">return</span> i.id; });<br><span class="hljs-keyword">const</span> ids = x.map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.id); <span class="hljs-comment">//λ表达式版</span><br><span class="hljs-built_in">console</span>.log(ids);<br><span class="hljs-comment">//控制台会输出[1, 2]</span><br></code></pre></td></tr></tbody></table></figure><h4 id="筛选数组中满足特定属性值要求的对象并生成新对象数组"><a href="#筛选数组中满足特定属性值要求的对象并生成新对象数组" class="headerlink" title="筛选数组中满足特定属性值要求的对象并生成新对象数组"></a>筛选数组中满足特定属性值要求的对象并生成新对象数组</h4><p>可以通过数组的<code>filter()</code>方法实现。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数，该回调函数需要返回一个布尔值，为真的情况下此对象会被加入新数组。此方法的返回值为所求的数组。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//筛选所有id=2的对象</span><br><span class="hljs-keyword">const</span> x = [<br>    {<br>        id: <span class="hljs-number">1</span>,<br>        name: <span class="hljs-string">'Alfred'</span><br>    },<br>    {<br>        id: <span class="hljs-number">2</span>,<br>        name: <span class="hljs-string">'John'</span><br>    }<br>]<br><span class="hljs-keyword">const</span> id2 = x.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{ <span class="hljs-keyword">return</span> i.id === <span class="hljs-number">2</span>; });<br><span class="hljs-keyword">const</span> id2 = x.filter(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.id === <span class="hljs-number">2</span>); <span class="hljs-comment">//λ表达式版</span><br><span class="hljs-built_in">console</span>.log(id2);<br><span class="hljs-comment">//控制台会输出[{id: 2, name: "John"}]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象实际上就是大括号包围的键值对。（<code>{key: value}</code>)</p><p>即使对象被定义为const，但仍可改变对象的内容，只是不能给该量赋值其他对象。</p><p>例子中，有：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = {<br>    name: <span class="hljs-string">'Alfred'</span>,<br>    age: <span class="hljs-number">19</span>,<br>    address: {<br>        province: <span class="hljs-string">'Zhejiang'</span>,<br>        city: <span class="hljs-string">'Hangzhou'</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="访问对象的单个值"><a href="#访问对象的单个值" class="headerlink" title="访问对象的单个值"></a>访问对象的单个值</h4><p>使用<code>.</code>运算符来方位对象的单个值。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(person.age); <span class="hljs-comment">//输出19</span><br></code></pre></td></tr></tbody></table></figure><h4 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h4><p>可以通过解构对象的方式从对象中取出一定数量的值。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> { name, age, <span class="hljs-attr">address</span>: {city} } = person; <span class="hljs-comment">//现在有3个const量分别为name、age和city</span><br></code></pre></td></tr></tbody></table></figure><h4 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h4><p>可以直接为对象添加新的键值对，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">person.email = <span class="hljs-string">'person@me.com'</span>;<br><span class="hljs-comment">//那么person现在是</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">{ </span><br><span class="hljs-comment">name: 'Alfred', </span><br><span class="hljs-comment">age: 19, </span><br><span class="hljs-comment">address: {</span><br><span class="hljs-comment">province: 'Zhejiang', </span><br><span class="hljs-comment">city: 'Hangzhou' },</span><br><span class="hljs-comment">email: 'person@me.com'</span><br><span class="hljs-comment">}</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h4 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h4><p>可以通过<code>for...in</code>循环遍历对象的属性，例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> person) {<br>    <span class="hljs-built_in">console</span>.log(x);<br>}<br><span class="hljs-comment">//遍历属性的名字（键），控制台会依次输出name, age, address, email</span><br><span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> person){<br>    <span class="hljs-built_in">console</span>.log(person[x]);<br>}<br><span class="hljs-comment">//遍历属性的值，控制台会依次输出Alfred, 19, {province: "Zhejiang", city: "Hangzhou"}, person@me.com</span><br></code></pre></td></tr></tbody></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON是一种数据格式，长得很像JavaScript的对象，经常用于传输数据。</p><p>使用<code>JSON.stringify()</code>函数可以把JavaScript的object类型数据转换为JSON字符串。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">JSON</span>.stringify(person);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-comment">/*输出</span><br><span class="hljs-comment">{"name":"Alfred",</span><br><span class="hljs-comment">    "age":19,</span><br><span class="hljs-comment">    "address":{"province":"Zhejiang","city":"Hangzhou"},</span><br><span class="hljs-comment">    "email":"person@me.com"</span><br><span class="hljs-comment">}</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果你给一个变量赋值为<code>null</code>，那么你用<code>typeof</code>运算符查看这个量的类型的时候，会发现它是<code>object</code>类型。</p><p>只定义了而未初始化的变量，它的默认值是<code>undefined</code>。</p><p>其他待补充。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="如何选择元素"><a href="#如何选择元素" class="headerlink" title="如何选择元素"></a>如何选择元素</h2><p>使用<code>document.querySelector()</code>和<code>document.querySelectorAll()</code>来选择HTML上的标签。</p><p>前者用来选择单个元素，后者可以选择多个元素并将其组入一个<code>NodeList</code>，它类似于数组，可以进行数组的一些操作（比如<code>forEach()</code>遍历和<code>NodeList.children[]</code>来选择第几个元素）。这两个函数的参数是一个字符串，字符串是选择器，形式同CSS的标签选择器、class选择器（加<code>.</code>）和id选择器（加<code>#</code>），例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> elem1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#id'</span>); <span class="hljs-comment">//如果实际可选的元素不止一个，则选择第一个</span><br><span class="hljs-keyword">const</span> elem2 = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.item'</span>); <span class="hljs-comment">//选中了所有.item标记的元素</span><br></code></pre></td></tr></tbody></table></figure><h2 id="删除页面元素"><a href="#删除页面元素" class="headerlink" title="删除页面元素"></a>删除页面元素</h2><p>可以使用<code>页面元素.remove()</code>方法完成。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">elem1.remove(); <span class="hljs-comment">//移除页面上的以#id标记的元素</span><br>elem2.remove(); <span class="hljs-comment">//移除页面上的所有的.item标记的元素</span><br>elem2.lastElementChild.remove(); <span class="hljs-comment">//移除elem2组合中的最后一个元素</span><br></code></pre></td></tr></tbody></table></figure><h2 id="添加页面元素"><a href="#添加页面元素" class="headerlink" title="添加页面元素"></a>添加页面元素</h2><p>可以通过<code>document.createElement()</code>方法来创建一个元素。此方法的参数为你要创建的元素的标签名，它的返回值为新创建好的元素DOM对象。要往元素内添加元素，可以使用元素的<code>appendChild()</code>方法，参数为你要插入的元素。特殊地，若要插入文字，参数可以设置为<code>document.createTextNode()</code>，此方法的参数为元素内的字符串。例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在一个ul内插入一个li，li的内容为2333</span><br><span class="hljs-keyword">const</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>) <span class="hljs-comment">//选中ul</span><br><span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>); <span class="hljs-comment">//创建li</span><br>li.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">'2333'</span>)); <span class="hljs-comment">//li内插入字符</span><br>ul.appendChild(li); <span class="hljs-comment">//把li加入ul</span><br></code></pre></td></tr></tbody></table></figure><h2 id="获取与编辑页面元素的内容试试"><a href="#获取与编辑页面元素的内容试试" class="headerlink" title="获取与编辑页面元素的内容试试"></a>获取与编辑页面元素的内容试试</h2><p>使用元素对象的<code>textContent</code>、<code>innerText</code>、<code>innerHTML</code>属性可以方便的获取或者更改元素的内容。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">elem2.firstElementChild.textContent = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">//修改elem2集合中的第一个元素的标签中的文本内容</span><br>elem2.firstElementChild.innerText = <span class="hljs-string">'Hello'</span>; <span class="hljs-comment">//效果同上</span><br>elem1.innerHTML = <span class="hljs-string">'&lt;a href="xxx"&gt;233&lt;/a&gt;'</span>; <span class="hljs-comment">//修改elem1的内嵌html代码</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h1'</span>).textContent); <span class="hljs-comment">//输出的是文本</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h1'</span>).innerText); <span class="hljs-comment">//同上</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h1'</span>).innerHTML); <span class="hljs-comment">//输出的是该元素的内嵌的所有HTML代码与文本</span><br></code></pre></td></tr></tbody></table></figure><p>输入框里面的内容，可以通过元素对象的<code>value</code>属性来获取。</p><h2 id="获取与编辑页面元素的HTML属性与CSS样式"><a href="#获取与编辑页面元素的HTML属性与CSS样式" class="headerlink" title="获取与编辑页面元素的HTML属性与CSS样式"></a>获取与编辑页面元素的HTML属性与CSS样式</h2><p>直接使用元素对象的相应属性并赋值即可。</p><p>给HTML元素添加新类使用元素的<code>classList.add()</code>方法实现，该函数接受一个字符串参数，即为要添加的class名；另外有一个方法叫<code>classList.remove()</code>，可以去除元素的某个class。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">elem1.style.background = <span class="hljs-string">'red'</span>; <span class="hljs-comment">//把elem1元素的背景改成红色的（CSS）</span><br>elem1.href = <span class="hljs-string">'https://www.baidu.com'</span>; <span class="hljs-comment">//把elem的href属性设为百度（之前没设置的会新指定）</span><br><span class="hljs-built_in">console</span>.log(elem1.target); <span class="hljs-comment">//输出elem1元素的target属性的内容</span><br><br>elem1.classList.add(<span class="hljs-string">'container'</span>); <span class="hljs-comment">//给elem1的class属性添加一个 container 类（可用于CSS选择）</span><br></code></pre></td></tr></tbody></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>以一个按钮元素为例。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn'</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="为一个元素添加监听事件"><a href="#为一个元素添加监听事件" class="headerlink" title="为一个元素添加监听事件"></a>为一个元素添加监听事件</h2><p>使用元素的<code>addEventListener()</code>方法可以为特定的元素添加监听事件。该函数有两个参数，第一个参数是一个字符串，代表要监听的事件；第二个参数为在目标元素上监听到该事件时所触发的回调函数。关于这个回调函数，它接受一个参数，这个参数是被监听方法自动传入的事件对象，函数体即该事件触发时执行的行为。该事件对象的<code>target</code>属性即为触发本事件的元素本身。例如，我给这个按钮添加单击按下时的监听事件：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">btn.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {<br>    e.preventDefault(); <span class="hljs-comment">//阻止该行为的默认事件，比如提交表单、跳转网页等</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'clicked!'</span>);<br>});<br></code></pre></td></tr></tbody></table></figure><p>常用事件有：</p><ul><li>click：单击</li><li>mouseover：鼠标移入、悬浮在上</li><li>mouseout：鼠标移出</li><li>submit：表单提交</li></ul><p>以及其他的比如输入事件等等。</p><p><strong>事件可以用于检查表单格式（我懒得举例子了，建议自己实现一下，获取DOM对象然后在函数体内确认）。</strong></p><h1 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h1><blockquote><p>看到这里就把整个文章看完了，但是你以为你这就可以愉快的写js了吗？</p><p>并不！</p><p>你要是还想了解更多的JavaScript语言方面的东西，推荐你几本书：《ES6标准入门（第三版）》、《JavaScript高级程序设计（第四版）》和《JavaScript DOM编程艺术》。</p><p>Good luck, and good night!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;观此文，你仍需有C语言、HTML、CSS基础之基础。&lt;/p&gt;
&lt;p&gt;本文规范基本上基于ECMAScript2015（就是ES6）。&lt;/p&gt;
&lt;p&gt;你需要认识C语言的分支与循环处理、HTML的常见标签以及CSS的基础选择器。如果你对C语言的函数指针或</summary>
      
    
    
    
    <category term="前端" scheme="https://www.legr4ndk.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://www.legr4ndk.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>鼠年的年终总结</title>
    <link href="https://www.legr4ndk.top/2021/02/12/S3Solve/"/>
    <id>https://www.legr4ndk.top/2021/02/12/S3Solve/</id>
    <published>2021-02-12T05:43:31.000Z</published>
    <updated>2021-03-14T10:17:28.612Z</updated>
    
    <content type="html"><![CDATA[<p>这半年最大的变化就是从网安去了计算机吧，说实话我觉得转专业带给我的平时生活的改变不是很大，除了不怎么会和室友一起上课了以外，虽然认识了很多从别的专业一起汇聚而来的人，但是其实我发现，新班级也好，旧班级也好，经常一起聊天探讨的也没几个人，虽然都分到一个班里了，但是大家其实很多都还是陌生人。</p><p>从我的专业角度来说，这学期，我是真的下决心坚持写博客了。记录自己的所学真的很棒，把网上学到的东西再用自己的话写一遍下来，不仅说是算一种留念，也能说是标记所学，将来在同样的问题上也更不容易翻车。这学期主要是有一门特殊的课叫创新实践。我们转专业学生一开始是没得选的，只能在所剩无几的名额中挑选了。我跟了一个做网络应用的老师（来源于对人工智能算法的抵触，虽然还是没逃掉），前半学期看起来很人畜无害，真的就是最轻松最养老的老师了，直到学期末，老师让我们一起申报新苗和大创计划的时候，才是我们麻烦的开始。现在，我作为一个没有学过Java的人，也在努力攻克JavaWeb这块肉。</p><p>我觉得我一个根本不会被贩卖焦虑的人，在群里每次看到大佬发言然后我一点都不懂的时候，真的就会不由自主地放弃摸鱼的想法。这学期，说实话摸鱼很多，就没学什么技术吧，每次都跟自己找借口说都来了计算机了，不着急学慢慢来。可是到现在，周围同学都上升了很多，我都甚至有的时候不怎么敢去搭话吧哈哈哈。</p><p>从人际上说的话，这学期其实没认识几个人（指名字和脸能对上的），大部分的认识人我都是在上课的时候，但是呢，就没有几个一起上过课的同学吧，平时其实也不怎么聊得起来。重组班级的人际关系说实话，很难搞，大家都已经建立了一个大学的朋友圈了，我发觉很多人其实并不是很想再像大家都是陌生人一样建立关系了。我这学期班级活动确实参与了不少呢。哎，现在有点后悔其实，我当时要是参选个班委是不是可以认识更多同学呢。当然，这学期说实话也确实认识了几个很值得的朋友，希望他们也能来年继续多多指教吧。</p><p>这学期，我觉得我最和mainstream对立的地方就是，大家都在学Java和Go开发，只有我在学几乎没有人看好的.NET和.NET Core平台。我对微软从很久以前就有个很独特的感情吧，也不知道怎么回事，就这么入了巨硬的坑，我相信这玩意虽然大家都不看好，但是我好好学的话还是很有用的。我一直挺看好这个平台的，而且千金难买我愿意，希望我喜欢的平台也能越来越好吧。</p><p>来年啊，课真的就越来越多了，也要进入大三了，说早也不早，差不多就要到下一次大的抉择的时候了，希望来年这个时候，我已经定好目标了吧。不过在那之前，我还是得先继续好好学呢，课内也好，课外也好，项目也好，希望能顺利齐头并进吧。</p><hr><p>好吧，我写到这儿我已经混乱了。</p><p>加油，奥里给！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这半年最大的变化就是从网安去了计算机吧，说实话我觉得转专业带给我的平时生活的改变不是很大，除了不怎么会和室友一起上课了以外，虽然认识了很多从别的专业一起汇聚而来的人，但是其实我发现，新班级也好，旧班级也好，经常一起聊天探讨的也没几个人，虽然都分到一个班里了，但是大家其实很多</summary>
      
    
    
    
    <category term="个人感悟" scheme="https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="misc" scheme="https://www.legr4ndk.top/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>解决Servlet页面中文乱码问题</title>
    <link href="https://www.legr4ndk.top/2021/02/08/ServletHandleWithChinese/"/>
    <id>https://www.legr4ndk.top/2021/02/08/ServletHandleWithChinese/</id>
    <published>2021-02-08T13:44:47.000Z</published>
    <updated>2021-03-14T10:17:28.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>年前诈尸再来记一笔。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java">resp.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);<br>resp.setContentType(<span class="hljs-string">"text/html"</span>);<br></code></pre></td></tr></tbody></table></figure><p>Servlet页面中文乱码的解法。</p><hr><p><strong>新年快乐，武运昌隆。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;年前诈尸再来记一笔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://www.legr4ndk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>在JSP上使用JavaBean</title>
    <link href="https://www.legr4ndk.top/2021/01/07/JSPuseJavaBean/"/>
    <id>https://www.legr4ndk.top/2021/01/07/JSPuseJavaBean/</id>
    <published>2021-01-07T07:54:53.000Z</published>
    <updated>2021-03-14T14:24:38.803Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>恁诸位新年好哇！</p></blockquote><p>记录一下怎么在JSP中使用JavaBean来避免写重复代码。</p><h3 id="什么是JavaBean"><a href="#什么是JavaBean" class="headerlink" title="什么是JavaBean"></a>什么是JavaBean</h3><p>JavaBean 是特殊的 Java 类，使用 Java 语言书写，并且遵守 JavaBean API 规范。</p><blockquote><p>为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。</p><p>JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。</p></blockquote><p>以上来自<a href="https://baike.baidu.com/item/javaBean/529577">百度百科</a>。总之，JavaBean就类似你事先写好一个类然后可以在多个不同的文件里引入而不需要在每个JSP文件里都单独声明这个类，可以减少很多的重复代码。</p><h3 id="怎么写一个JavaBean"><a href="#怎么写一个JavaBean" class="headerlink" title="怎么写一个JavaBean"></a>怎么写一个JavaBean</h3><p>JavaBean的特征在上面已经有所提及了，下面以一个操作JDBC连接MySQL的JavaBean文件来示范如何写JavaBean。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src; <span class="hljs-comment">//包名</span><br><br><span class="hljs-keyword">import</span> java.sql.*; <span class="hljs-comment">//引入必需的库</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>{ <span class="hljs-comment">//必须继承序列化接口</span><br>    <span class="hljs-comment">//以下为字段，全是私有的，这边的内容在使用时都不会改，所以没有getter和setter</span><br>    String DBDriver = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;<br>    String ConnStr = <span class="hljs-string">"jdbc:mysql://localhost:3306/$DBNAME"</span>;<br>    String MyUser = <span class="hljs-string">"$USERNAME"</span>;<br>    String MyPassword = <span class="hljs-string">"$PASSWORD"</span>;<br>    Connection conn = <span class="hljs-keyword">null</span>;<br>    Statement stmt = <span class="hljs-keyword">null</span>;<br>    ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MysqlBean</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            Class.forName(DBDriver);<br>        } <span class="hljs-keyword">catch</span> (java.lang.ClassNotFoundException e) {<br>            System.err.println(<span class="hljs-string">"DBconn (): "</span> + e.getMessage());<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultSet <span class="hljs-title">executeQuery</span><span class="hljs-params">(String sql)</span> </span>{<br>        rs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            conn = DriverManager.getConnection(ConnStr, MyUser, MyPassword);<br>            Statement stmt = conn.createStatement(<br>                    java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE,<br>                    java.sql.ResultSet.CONCUR_READ_ONLY);<br>            rs = stmt.executeQuery(sql);<br>        } <span class="hljs-keyword">catch</span> (SQLException ex) {<br>            System.err.println(<span class="hljs-string">"aq.executeQuery:"</span> + ex.getMessage());<br>        }<br>        <span class="hljs-keyword">return</span> rs;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">executeUpdate</span><span class="hljs-params">(String sql)</span> </span>{<br>        {<br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> {<br>                conn = DriverManager.getConnection(ConnStr, MyUser, MyPassword);<br>                Statement stmt = conn.createStatement();<br>                count = stmt.executeUpdate(sql);<br>                stmt.close();<br>                conn.close();<br>            } <span class="hljs-keyword">catch</span> (SQLException ex) {<br>                System.err.println(<span class="hljs-string">"aq.executeQuery:"</span> + ex.getMessage());<br>            }<br>            <span class="hljs-keyword">return</span> count;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">closeConn</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>)<br>                rs.close();<br>            <span class="hljs-keyword">if</span> (stmt != <span class="hljs-keyword">null</span>)<br>                stmt.close();<br>            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>)<br>                conn.close();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        } <span class="hljs-keyword">catch</span> (SQLException ex) {<br>            System.err.println(<span class="hljs-string">"closeConn:"</span> + ex.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在文件里完成必要的自定义（比如数据库名等）之后，将其保存为<code>MysqlBean.java</code>，然后使用<code>javac</code>命令将其编译为class文件（注意使用的Java版本需要与你运行tomcat的JRE版本相同），得到<code>MysqlBean.class</code>文件。这样，你就成功生成了一个JavaBean的类文件。</p><h3 id="如何在JSP里面使用JavaBean"><a href="#如何在JSP里面使用JavaBean" class="headerlink" title="如何在JSP里面使用JavaBean"></a>如何在JSP里面使用JavaBean</h3><h4 id="部署JavaBean"><a href="#部署JavaBean" class="headerlink" title="部署JavaBean"></a>部署JavaBean</h4><p>跟据你写的包名（比如我的是src包），将class文件放在<code>&lt;JSP 项目&gt;/WEB-INF/classes/包名/</code>文件夹中，例如本示例，class文件的位置为<code>&lt;JSP 项目&gt;/WEB-INF/classes/src/MysqlBean.class</code>。</p><h4 id="调用JavaBean"><a href="#调用JavaBean" class="headerlink" title="调用JavaBean"></a>调用JavaBean</h4><p>在JSP文件中，你可与使用<code>&lt;jsp:useBean /&gt;</code>标签来声明一个Bean。在声明一个Bean之后，这个JavaBean对象就变成脚本变量，可以在JSP里面直接使用。例如，要在JSP里使用上文提到的Bean，可以在JSP的开头加上：</p><figure class="highlight jsp"><table><tbody><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">"MySQL"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"src.MysqlBean"</span>/&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中，id代表Bean生成的对象的脚本变量的名字，class代表class文件所在的包和类名。</p><p>然后，你就可以在JSP中使用<code>对象名（id）.方法名</code>的方式来使用Bean内的方法了，例如我想使用上文的Bean中的execute方法，我可以使用<code>MySQL.execute("");</code>。</p><h4 id="特殊的getter、setter使用方法"><a href="#特殊的getter、setter使用方法" class="headerlink" title="特殊的getter、setter使用方法"></a>特殊的getter、setter使用方法</h4><p>JavaBean中对于getter，setter函数使用特殊的标签来调用：</p><figure class="highlight jsp"><table><tbody><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty name=<span class="hljs-string">"bean的id"</span> property=<span class="hljs-string">"属性名"</span> value=<span class="hljs-string">"value"</span>/&gt; <span class="hljs-comment">//调用setter()</span><br>&lt;jsp:getProperty name=<span class="hljs-string">"bean的id"</span> property=<span class="hljs-string">"属性名"</span>/&gt; <span class="hljs-comment">//调用getter()</span><br></code></pre></td></tr></tbody></table></figure><p>上面那个类我没写getter和setter，就不演示了~</p><hr><p>先这样，JSP其实好像用的不多，以后还是Servlet吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;恁诸位新年好哇！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一下怎么在JSP中使用JavaBean来避免写重复代码。&lt;/p&gt;
&lt;h3 id=&quot;什么是JavaBean&quot;&gt;&lt;a href=&quot;#什么是JavaBean&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://www.legr4ndk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC提供的SQL操作API解析</title>
    <link href="https://www.legr4ndk.top/2020/12/23/JDBCexecuteCourse/"/>
    <id>https://www.legr4ndk.top/2020/12/23/JDBCexecuteCourse/</id>
    <published>2020-12-23T10:55:28.000Z</published>
    <updated>2021-03-14T10:17:28.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DriveManager类"><a href="#DriveManager类" class="headerlink" title="DriveManager类"></a>DriveManager类</h2><p>DriveManager类有两个作用：注册驱动与获得数据库连接。</p><p>注册驱动使用<code>registerDrive()</code>方法实现，建立连接使用<code>getConnection()</code>方法实现。</p><h3 id="registerDriver"><a href="#registerDriver" class="headerlink" title="registerDriver()"></a>registerDriver()</h3><p>在此类中有一段静态代码使用<code>DriverManager.registerDriver(new Driver());</code>完成了驱动的注册，所以已经无须手动调用此方法注册。</p><h3 id="getConnection"><a href="#getConnection" class="headerlink" title="getConnection()"></a>getConnection()</h3><p>此方法有三个String类型参数：</p><ul><li>url：与数据库连接的路径 </li><li>user：与数据库连接的用户名 </li><li>password：与数据库连接的密码</li></ul><p>此处主要涉及URL的写法，比较特殊：<code>jdbc:mysql://localhost:3306/$DB_NAME</code>。其中：</p><ul><li>jdbc：连接数据库的协议 </li><li>mysql：jdbc的子协议 </li><li>localhost：连接的MySQL数据库服务器的主机地址。连接是本机就可以写成localhost，如果连接不是本机的，就需要写上连接主机的IP地址或域名。 </li><li>3306：MySQL数据库服务器的端口号 </li><li>$DB_NAME：数据库名称</li></ul><p>该函数将会与数据库连接，如果连接成功则返回一个<code>Connection</code>类的数据库连接对象，若连接失败则返回null。</p><h2 id="Connection类"><a href="#Connection类" class="headerlink" title="Connection类"></a>Connection类</h2><p>Connection类即数据库连接对象，有两大功能：创建用于执行SQL语句的对象和管理事务</p><p>以下三个方法可以创建用于执行SQL语句的对象：</p><ul><li>createStatement()：返回一个Statement对象，用于执行SQL</li><li>prepareCall()：返回一个CallableStatement对象，用于调用数据库中存储过程</li><li>prepareStatement()：返回一个PreparedStatement对象，用于执行SQL并对SQL进行预处理以解决SQL注入漏洞。</li></ul><p>以下三个无返回值的方法用于管理数据库事务：</p><ul><li>getAutoCommit()：将此连接的自动提交模式设定为给定状态</li><li>commit()：使所有上一次提交/回滚后进行的更改成为永久更改，并释放此Connection对象当前的数据库锁</li><li>rollback()：取消在当前事务中进行的所有更改，并释放此Connection对象当前的数据库锁</li></ul><h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>Statement 接口提供了三种执行 SQL 语句的方法：</p><ul><li>executeQuery()</li><li>executeUpdate() </li><li>execute()</li></ul><p>我们需要针对不同的SQL语句使用这三种方法</p><h3 id="executeQuery"><a href="#executeQuery" class="headerlink" title="executeQuery()"></a>executeQuery()</h3><p><code>executeQuery()</code>返回一个<code>ResultSet</code>类的对象，该对象是一个结果集。这个方法只能被用于查询语句，比如用的最多的<code>SELECT</code>语句，执行完语句后会返回代表查询结果的<code>ResultSet</code>对象。随后可以通过<code>ResultSet</code>类中的getString()方法来获取读到的数据。</p><h3 id="executeUpdate"><a href="#executeUpdate" class="headerlink" title="executeUpdate()"></a>executeUpdate()</h3><p><code>executeUpdate()</code>常用于执行<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CREATE TABLE</code>等非查询类语句。常用于数据库与数据表的增删改。它返回一个int类型的值，对于<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等操作，会返回数据表中受影响的行数；对于<code>CREATE TABLE</code>等的操作，它的返回值总为0。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p><code>execute()</code>可以用于执行任何SQL语句。它的返回值是一个bool类型的值，来表明该SQL语句是否返回了<code>ResultSet</code>对象。如果执行后得到的第一个结果是<code>ResultSet</code>则返回true，否则返回false。返回为true后可以利用<code>getResultSet()</code>方法来获取对应的<code>ResultSet</code>类的结果集对象。此函数更复杂，推荐仅当不知道SQL语句的具体类型时使用此函数来执行。</p><h2 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h2><p><code>ResultSet</code>类是查询的结果集。主要使用两个方法来进行操作：getString()和next()。</p><h3 id="getString"><a href="#getString" class="headerlink" title="getString()"></a>getString()</h3><p><code>getString()</code>方法接受一个String类型的参数，作为要获得的字段的字段名。它会返回一个String类型的值，就是<code>ResultSet</code>对象当前指向行的所求字段的值。此方法多用于处理查询所得值。</p><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><p><code>next()</code>方法会将该<code>ResultSet</code>对象所指向行的光标向下移动一行。它返回一个bool类型的值，当光标已经不能下移时会返回false，否则返回true并下移光标。此方法可以用于遍历查询所得数据或者判断查询是否有查到值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DriveManager类&quot;&gt;&lt;a href=&quot;#DriveManager类&quot; class=&quot;headerlink&quot; title=&quot;DriveManager类&quot;&gt;&lt;/a&gt;DriveManager类&lt;/h2&gt;&lt;p&gt;DriveManager类有两个作用：注册驱动与获得</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://www.legr4ndk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>NPUCTF HappyCheckInVerification WP</title>
    <link href="https://www.legr4ndk.top/2020/12/17/HappyCheckinNPUWP/"/>
    <id>https://www.legr4ndk.top/2020/12/17/HappyCheckinNPUWP/</id>
    <published>2020-12-17T15:39:52.000Z</published>
    <updated>2021-03-15T14:04:17.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文搬运自我写在别处的文章</p></blockquote><h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><p>题目链接：<a href="https://pan.baidu.com/s/1c_Y0WJmzTdNVyYgjHmUI_Q">https://pan.baidu.com/s/1c_Y0WJmzTdNVyYgjHmUI_Q</a></p><p>提取码: qhh8</p><p>Hint：关注西北工业大学信息安全协会微信公众号NWPUSEC</p><hr><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>下载得到无后缀名的名叫zip的文件，把后缀名改成.zip，提示文件已损坏，故用16进制文件查看器检查文件（本文使用HxD）。</p><p><img src="http://greenhateam.top/wp-content/uploads/2020/05/hcv1.png" alt="img"></p><p>这是此文件的文件头，可见zip文件的文件头标记504B0304不在文件头部，反而是zip文件的目录结束标识（504B0506）在文件头。把从00000000-00000015的部分移动至文件尾，保存重新打开，就可以看到zip文件的文件了。此zip文件带有伪加密，可以通过搜索的方法搜索zip文件头标记504B0102，在其偏移5字节的地方改为00（要改两处）来去除伪加密。</p><p><img src="http://greenhateam.top/wp-content/uploads/2020/05/hcv2.png" alt="img"></p><p>保存解压即可获得一个mp4视频和一个二维码文件。</p><p>视频文件是喜闻乐见的黑人抬棺材的视频，但是在视频中有两个部分被植入了拨号音。截取这段音频降噪，使用dtmf2num工具识别拨号音，得到电话号码13418070885。</p><p>再来看二维码：</p><p><img src="http://greenhateam.top/wp-content/uploads/2020/05/hcv3.png" alt="img"></p><p>这是获取的二维码图像，可见二维码的三个定位符均被抹去，所以无法扫描。通过PS添加三个定位符，得到一个二维码。扫描得到以下文字：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs rawtext">flag{this_is_not_flag}<br>三曳所諳陀怯耶南夜缽得醯怯勝數不知喝盧瑟侄盡遠故隸怯薩不娑羯涅冥伊盧耶諳提度奢道盧冥以朋罰所即栗諳蒙集皤夷夜集諳利顛呐寫無怯依奢竟<br>#￥#%<br>E68BBFE4BD9BE68B89E6A0BCE79A84E5A7BFE58ABFE59CA8E69C80E5908E32333333<br>||<br>254333254242254338254342254231254338254345254432254238254643254236254145254239254441254437254234254232254131254236254245253244253244254343254438254330254341254336254435<br>…sadwq#asdsadasf faf$use$dasdasdafafa_$ba##se64$<br></code></pre></td></tr></tbody></table></figure><p>this is not flag 后面的第一部分哪些诡异的文字，是“与佛论禅”编码。最前面加上“佛曰：”，得到一句话：“都说了这不是佛拉格了”。</p><p>第二部分是一段十六进制数，把它转成字符串，得到：“拿佛拉格的姿势在最后”。</p><p>第三段也是一串十六进制数，把它转成字符串，得到：%C3%BB%C8%CB%B1%C8%CE%D2%B8%FC%B6%AE%B9%DA%D7%B4%B2%A1%B6%BE%2D%2D%CC%D8%C0%CA%C6%D5 肉眼可见它是url编码，直接转换，得到一串字符：“没人比我更懂冠状病毒–特朗普”。</p><p>最后一段没啥花头了，就是看到了use base64，是时候把刚刚从拨号音得到的电话号码用BASE64编码发到公众号，得到一段诡异的音频。</p><p><audio controls="" src="http://greenhateam.top/wp-content/uploads/2020/05/%E9%AB%98%E6%B8%85%E9%87%8D%E7%BD%AE.mp3" style="box-sizing: inherit; display: inline-block; width: 660.25px; min-width: 300px;"></audio><br>这是一段sstv的音频，里面有个图，直接使用软件MMSSTV，播放这段音频给电脑听（推荐电脑内录），你就可以看到孙狗的笑容（天皇遗照）。flag就写在孙🐕的胸上。</p><p><img src="http://greenhateam.top/wp-content/uploads/2020/05/hcv.png" alt="img"></p><hr><p><strong>结束</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文搬运自我写在别处的文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;p&gt;题目链接：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="安全" scheme="https://www.legr4ndk.top/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ctf" scheme="https://www.legr4ndk.top/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>实现网页登陆的逻辑</title>
    <link href="https://www.legr4ndk.top/2020/12/17/BackEndLoginCourse/"/>
    <id>https://www.legr4ndk.top/2020/12/17/BackEndLoginCourse/</id>
    <published>2020-12-17T14:46:26.000Z</published>
    <updated>2021-03-14T10:17:28.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现登陆逻辑至少涉及两个方面，登陆与注册</p><p>本文使用SQL语言的MySQL dialect</p></blockquote><h3 id="登陆（Log-in）"><a href="#登陆（Log-in）" class="headerlink" title="登陆（Log in）"></a>登陆（Log in）</h3><p>登陆主要是实现将用户提交的含有用户名<code>uname</code>和密码<code>passwd</code>的表单提交给数据库对比，如果发现此条记录在数据库中存在且合法，则返回登陆成功，否则返回登陆失败，需要请求用户重新提交。</p><p>这边主要注意的是一个点，在查询的时候我们会使用SQL语句去数据库查询，一般想到的逻辑应该是去查询得到用户名对应的密码，然后再去对比用户提交的密码与数据库返回的密码是否一致。即使用了以下的SQL代码：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs mysql">SELECT passwd FROM user_info WHERE uname = $UNAME;<br></code></pre></td></tr></tbody></table></figure><p>在登陆成功情况下两者并无任何区别，但实际上这个方式有一个巨大的缺陷：在登陆失败时，这种数据处理方式割裂了“用户名输入错误”（此用户名不存在）与“查到用户名，但密码错误”两种情况。如果这两种不同的情况被以不同形式返回到前端（比如分别提示“用户名错误”或“密码错误”，那么就很容易被通过“撞库攻击”而“撞”出网站的许多用户的用户名，即使他们并不知道每个id的密码，这无疑方便了攻击者通过id暴力穷举或者使用密码字典的方式获取密码。</p><p>正确的处理方法应该是连着用户名和密码一起放入SQL语句里去查询，比如：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM user_info WHERE uname = $UNAME AND passwd = $PASSWD;<br></code></pre></td></tr></tbody></table></figure><p>然后通过执行了该语句之后是否具有返回数据的方式来判断用户试图登陆的账号密码对是否被注册且有效。如果成功，则结果同上，但是若登陆失败，那么它只能体现用户名和密码错误，安全性相对更高。</p><h3 id="注册（Register）"><a href="#注册（Register）" class="headerlink" title="注册（Register）"></a>注册（Register）</h3><p>注册的验证涉及三个步骤：</p><ul><li>验证提交的密码的合法性</li><li>验证提交的username的唯一性</li><li>插入提交的用户名与密码到数据库。</li></ul><h4 id="提交密码的合法性判断"><a href="#提交密码的合法性判断" class="headerlink" title="提交密码的合法性判断"></a>提交密码的合法性判断</h4><p>无非是判断密码长度、判断是否含有不合法字符、判断密码格式是否合规。使用各种语言的字符串处理手段乃至正则表达式都可以直接实现，此处不再赘述。提供一个常见的网站密码格式要求：以字母开头，必须包含大/小写字母、数字、一般符号的至少三种，长度在8-64位之间。</p><h4 id="提交的用户名的唯一性判断"><a href="#提交的用户名的唯一性判断" class="headerlink" title="提交的用户名的唯一性判断"></a>提交的用户名的唯一性判断</h4><p>可以通过SQL语言的SELECT语句，即查询语句来实现，比如：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM user_info WHERE uname = $UNAME;<br></code></pre></td></tr></tbody></table></figure><p>然后通过执行该语句后是否有查询到的数据来判断这个用户名是否被注册过，以决定是否要为此组提交的数据执行注册（即插入数据表）的操作。</p><blockquote><p>值得一提的是，你可与为某一列设置UNIQUE来保证这列的数据一定不相同，此情况下，若插入重复的username将会导致MySQL抛出异常，需要对这一异常进行处理。</p></blockquote><h4 id="插入提交的数据到数据库"><a href="#插入提交的数据到数据库" class="headerlink" title="插入提交的数据到数据库"></a>插入提交的数据到数据库</h4><p>在我们确认用户提交的数据在数据库中不会出现问题之后，我们便可以把用户提交的键值对插入数据表中了。插入操作使用INSERT来实现，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user_info (uname, passwd) VALUES ($UNAME, $PASSWD);<br></code></pre></td></tr></tbody></table></figure><p>此方法会把$UNAME与$PASSWD以一条新记录的方式插入到对于数据表中。一般在这种情况下，它便不再会出现插入异常了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实现登陆逻辑至少涉及两个方面，登陆与注册&lt;/p&gt;
&lt;p&gt;本文使用SQL语言的MySQL dialect&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;登陆（Log-in）&quot;&gt;&lt;a href=&quot;#登陆（Log-in）&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="sql" scheme="https://www.legr4ndk.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>在JSP上连接MySQL数据库</title>
    <link href="https://www.legr4ndk.top/2020/12/16/JSPconnectMySQL/"/>
    <id>https://www.legr4ndk.top/2020/12/16/JSPconnectMySQL/</id>
    <published>2020-12-16T12:53:36.000Z</published>
    <updated>2021-03-14T10:17:28.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱动准备"><a href="#驱动准备" class="headerlink" title="驱动准备"></a>驱动准备</h2><p>你需要下载Java Database Connector for MySQL，本文提供一个来自于菜鸟教程的jar包，版本号为5.1.39。点击<a href="http://static.runoob.com/download/mysql-connector-java-5.1.39-bin.jar">此处</a>下载。将此文件放入tomcat目录的lib文件夹中。</p><h2 id="配置Tomcat的连接池"><a href="#配置Tomcat的连接池" class="headerlink" title="配置Tomcat的连接池"></a>配置Tomcat的连接池</h2><p>不配置连接池，在使用驱动包的时候tomcat会返回500 Internal Server Error，提示ClassNotFoundException（异常：找不到类），可以通过配置它的连接池来解决问题。</p><h3 id="修改server-xml"><a href="#修改server-xml" class="headerlink" title="修改server.xml"></a>修改server.xml</h3><p>修改位于tomcat目录下的conf/server.xml,找到<code>&lt;GlobalNamingResources&gt;</code>标签，在此标签内我们需要添加内容。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这个标签是已经存在的，找到它然后编辑即可--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--这部分为文件自带内容，不作改动--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="hljs-tag">              <span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置mysql数据库的连接池, 需要做的额外步骤是将mysql的Java驱动类放到tomcat的lib目录下--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbc/mysqlds"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">type</span>=<span class="hljs-string">"javax.sql.DataSource"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">username</span>=<span class="hljs-string">"$UNAME"</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">password</span>=<span class="hljs-string">"$PWD"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">maxIdle</span>=<span class="hljs-string">"30"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">maxWait</span>=<span class="hljs-string">"10000"</span> </span><br><span class="hljs-tag">                       <span class="hljs-attr">maxActive</span>=<span class="hljs-string">"100"</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">driverClassName</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">url</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/$DBNAME"</span> /&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span>  <br></code></pre></td></tr></tbody></table></figure><p>其中 <code>$DBNAME</code>位置放你的数据库名，<code>$UNAME</code>位置放置你的数据库用户名，<code>$PWD</code>位置放置你的数据库密码</p><h3 id="修改context-xml"><a href="#修改context-xml" class="headerlink" title="修改context.xml"></a>修改context.xml</h3><p>修改位于tomcat目录下的conf/context.xml，在<code>&lt;Context&gt;</code>标签内我们需要添加内容。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--这部分为文件自带内容，不作改动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>WEB-INF/tomcat-web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">WatchedResource</span>&gt;</span>${catalina.base}/conf/web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">WatchedResource</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--以下为在本文件中的添加内容--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceLink</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbc/mysqlds"</span> <span class="hljs-attr">global</span>=<span class="hljs-string">"jdbc/mysqlds"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"javax.sql.DataSource"</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="修改web-xml"><a href="#修改web-xml" class="headerlink" title="修改web.xml"></a>修改web.xml</h3><p>修改位于tomcat目录下的网页项目文件夹下的WEB-INF/web.xml文件，在</p><p><code>&lt;web-app&gt;</code>内我们需要添加内容。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--以下为在本文件中的添加内容--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource-ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>mysql数据库连接池<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">res-ref-name</span>&gt;</span>jdbc/mysqlds<span class="hljs-tag">&lt;/<span class="hljs-name">res-ref-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">res-type</span>&gt;</span>javax.sql.DataSource<span class="hljs-tag">&lt;/<span class="hljs-name">res-type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">res-auth</span>&gt;</span>Container<span class="hljs-tag">&lt;/<span class="hljs-name">res-auth</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">res-sharing-scope</span>&gt;</span>Shareable<span class="hljs-tag">&lt;/<span class="hljs-name">res-sharing-scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource-ref</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>配置之后，<strong>需重启tomcat</strong>。之后连接数据库的时候就不会出现ClassNotFoundException了。</p><h2 id="JSP连接数据库"><a href="#JSP连接数据库" class="headerlink" title="JSP连接数据库"></a>JSP连接数据库</h2><p>给出一段DEMO：</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">"java.sql.*"</span>%&gt;<br><br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;通过JSP打开数据表&lt;/title&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br><br>        &lt;%<br>            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);  <span class="hljs-comment">//驱动程序名</span><br>            String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/$DBNAME"</span>; <span class="hljs-comment">//数据库名</span><br>            String username = <span class="hljs-string">"$UNAME"</span>;  <span class="hljs-comment">//数据库用户名</span><br>            String password = <span class="hljs-string">"$PWD"</span>;  <span class="hljs-comment">//数据库用户密码</span><br>            Connection conn = DriverManager.getConnection(url, username, password);  <span class="hljs-comment">//连接数据库并返回连接状态</span><br><br>            <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>){<br>                out.print(<span class="hljs-string">"数据库连接成功！"</span>);<br>                out.print(<span class="hljs-string">"&lt;br /&gt;"</span>);<br>                Statement stmt = <span class="hljs-keyword">null</span>;<br>                ResultSet rs = <span class="hljs-keyword">null</span>;<br>                String sql = <span class="hljs-string">"SELECT * FROM $TABLENAME;"</span>;  <span class="hljs-comment">//查询语句</span><br>                stmt = conn.createStatement();<br>                rs = stmt.executeQuery(sql);<br>                out.print(<span class="hljs-string">"查询结果："</span>);<br>                out.print(<span class="hljs-string">"&lt;br /&gt;"</span>);<br>                out.println(<span class="hljs-string">"id"</span>+<span class="hljs-string">"  "</span>+<span class="hljs-string">"uname"</span>+<span class="hljs-string">"  "</span>+<span class="hljs-string">"pwd"</span>);<br>                out.print(<span class="hljs-string">"&lt;br /&gt;"</span>);<br>                <span class="hljs-keyword">while</span> (rs.next()) {<br>                    out.println(rs.getString(<span class="hljs-string">"id"</span>)+<span class="hljs-string">" "</span>+rs.getString(<span class="hljs-string">"uname"</span>)+<span class="hljs-string">" "</span>+rs.getString(<span class="hljs-string">"passwd"</span>)+<span class="hljs-string">"&lt;br /&gt;"</span>); <span class="hljs-comment">//将查询结输出</span><br>                }<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                out.print(<span class="hljs-string">"连接失败！"</span>);<br>            }<br><br>        %&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>$DBNAME</code>位置放你的数据库名，<code>$UNAME</code>位置放置你的数据库用户名，<code>$PWD</code>位置放置你的数据库密码，<code>$TABLENAME</code>位置放置你操作的数据表表名。</p><p>ResultSet.getString()函数接受字段名作为参数返回对应一条记录的该字段的值，可以以此读取信息。</p><p>上方Demo实现了读取一个数据表中id、uname、pwd字段的所有数据的JSP代码。</p><p>通过更改SQL语句可以实现更多的操作，此处不再赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;驱动准备&quot;&gt;&lt;a href=&quot;#驱动准备&quot; class=&quot;headerlink&quot; title=&quot;驱动准备&quot;&gt;&lt;/a&gt;驱动准备&lt;/h2&gt;&lt;p&gt;你需要下载Java Database Connector for MySQL，本文提供一个来自于菜鸟教程的jar包，版本号为</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://www.legr4ndk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>于Ubuntu 18.04上配置Java Server Pages运行环境</title>
    <link href="https://www.legr4ndk.top/2020/12/11/JSPenvironment/"/>
    <id>https://www.legr4ndk.top/2020/12/11/JSPenvironment/</id>
    <published>2020-12-11T10:16:45.000Z</published>
    <updated>2021-03-14T10:17:28.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><code class="hljs routeros">sudo apt update #更新软件源<br>sudo apt<span class="hljs-built_in"> upgrade </span>#更新软件包<br></code></pre></td></tr></tbody></table></figure><h3 id="Web服务器应用Apache"><a href="#Web服务器应用Apache" class="headerlink" title="Web服务器应用Apache"></a>Web服务器应用Apache</h3><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk">sudo apt install apache2 -y <span class="hljs-comment">#安装apache2</span><br>sudo <span class="hljs-regexp">/etc/i</span>nit.d/apache2 start <span class="hljs-comment">#启动apache2</span><br>sudo <span class="hljs-regexp">/etc/i</span>nit.d/apache2 stop <span class="hljs-comment">#关闭apache2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Java运行时与JDK"><a href="#Java运行时与JDK" class="headerlink" title="Java运行时与JDK"></a>Java运行时与JDK</h3><figure class="highlight mipsasm"><table><tbody><tr><td class="code"><pre><code class="hljs mipsasm">sudo apt <span class="hljs-keyword">install </span>openjdk<span class="hljs-number">-11</span>-<span class="hljs-keyword">jdk-headless </span><span class="hljs-comment">#安装openjdk-11</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Java应用服务器Tomcat"><a href="#Java应用服务器Tomcat" class="headerlink" title="Java应用服务器Tomcat"></a>Java应用服务器Tomcat</h3><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><code class="hljs awk">sudo apt install git <span class="hljs-comment">#安装git（作为wget的依赖）</span><br>sudo apt install wget <span class="hljs-comment">#有的系统自带wget，就不用装</span><br>wget https:<span class="hljs-regexp">//mi</span>rrors.cnnic.cn<span class="hljs-regexp">/apache/</span>tomcat<span class="hljs-regexp">/tomcat-9/</span>v9.<span class="hljs-number">0.40</span><span class="hljs-regexp">/bin/</span>apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">40</span>.tar.gz<br> <span class="hljs-comment">#于cnnic镜像站下载tomcat的预编译二进制文件</span><br>tar -xzvf apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">40</span>.tar.gz <span class="hljs-comment">#解压压缩文件</span><br>sudo mv .<span class="hljs-regexp">/apache-tomcat-9.0.40 /u</span>sr<span class="hljs-regexp">/local/</span>tomcat <span class="hljs-comment">#移动所有文件到/usr/local目录下的tomcat文件夹中</span><br>sudo chmod -R <span class="hljs-number">755</span> <span class="hljs-regexp">/usr/</span>local/tomcat <span class="hljs-comment">#赋予权限</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>bin <span class="hljs-comment">#进入存放tomcat的文件夹</span><br>vim ./startup.sh <span class="hljs-comment">#编辑startup.sh脚本</span><br><span class="hljs-comment"># 最后一行加上：</span><br><span class="hljs-comment">#tomcat</span><br>export TOMCAT_HOME=<span class="hljs-regexp">/usr/</span>local/tomcat<br><span class="hljs-comment"># 保存退出</span><br>sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>bin/startup.sh <span class="hljs-comment">#启动tomcat</span><br>sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>bin/shutdown.sh <span class="hljs-comment">#关闭tomcat</span><br></code></pre></td></tr></tbody></table></figure><h3 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h3><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install mysql-server #安装mysql-server<br>sudo mysql -uroot -p #root用户登陆mysql-clinet，默认无密码<br><span class="hljs-comment">#执行以下操作以自订密码</span><br>use mysql;<br>update<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">authentication_string</span>=PASSWORD("自定义密码") where <span class="hljs-attribute">user</span>=<span class="hljs-string">'root'</span>;<br>update<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">plugin</span>=<span class="hljs-string">"mysql_native_password"</span>;<br>flush privileges;<br>quit;<br><span class="hljs-comment">#退出mysql</span><br>sudo /etc/init.d/ mysql start #启动mysql<br>sudo /etc/init.d/ mysql stop #关闭mysql<br>sudo /etc/init.d/ mysql restart #重启mysql<br><br><span class="hljs-comment">#要创建新的mysql用户</span><br>CREATE<span class="hljs-built_in"> USER </span><span class="hljs-string">'username'</span>@<span class="hljs-string">'host'</span> IDENTIFIED BY <span class="hljs-string">'password'</span>;<br><span class="hljs-comment">#username：用户名，host：指定该用户在哪个主机上可以登陆，本地用户用localhost，从任意远程主机登陆，可以使用通配符%，password：用户密码</span><br></code></pre></td></tr></tbody></table></figure><hr><blockquote><p>启动Apache和Tomcat之后可以在80端口看到apache的it works界面，8080端口可以看到位于 <strong>/usr/local/tomcat/webapps/ROOT/</strong> 的网页，可以自己放jsp文件于次文件夹，以对于域名的相对地址访问。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;更新系统&quot;&gt;&lt;a href=&quot;#更新系统&quot; class=&quot;headerlink&quot; title=&quot;更新系统&quot;&gt;&lt;/a&gt;更新系统&lt;/h3&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="server" scheme="https://www.legr4ndk.top/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>在网页文件中引入Bootstrap</title>
    <link href="https://www.legr4ndk.top/2020/12/09/IncludeBootstrap/"/>
    <id>https://www.legr4ndk.top/2020/12/09/IncludeBootstrap/</id>
    <published>2020-12-09T15:27:58.000Z</published>
    <updated>2021-03-14T10:17:28.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>文件均使用了在Staticfile CDN上的镜像</strong></p></blockquote><h3 id="在文件中引入Bootstrap3的库"><a href="#在文件中引入Bootstrap3的库" class="headerlink" title="在文件中引入Bootstrap3的库"></a>在文件中引入Bootstrap3的库</h3><p>以下内容请放入html文件的<code>&lt;head&gt;</code>与<code>&lt;/head&gt;</code>之间：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 --&gt;</span><br>      <span class="hljs-comment">&lt;!--[if lt IE 9]&gt;</span><br><span class="hljs-comment">         &lt;script src="https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;</span><br><span class="hljs-comment">         &lt;script src="https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;</span><br><span class="hljs-comment">      &lt;![endif]--&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>以下内容请放入html文件的<code>&lt;body&gt;</code>与<code>&lt;/body&gt;</code>之间：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 包括所有已编译的插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Bootstrap4版的库文件链接："><a href="#Bootstrap4版的库文件链接：" class="headerlink" title="Bootstrap4版的库文件链接："></a>Bootstrap4版的库文件链接：</h3><p>以下内容请放入html文件的<code>&lt;head&gt;</code>与<code>&lt;/head&gt;</code>之间：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 --&gt;</span><br>      <span class="hljs-comment">&lt;!--[if lt IE 9]&gt;</span><br><span class="hljs-comment">         &lt;script src="https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;</span><br><span class="hljs-comment">         &lt;script src="https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;</span><br><span class="hljs-comment">      &lt;![endif]--&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>以下内容请放入html文件的<code>&lt;body&gt;</code>与<code>&lt;/body&gt;</code>之间：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件均使用了在Staticfile CDN上的镜像&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在文件中引入Bootstrap3的库&quot;&gt;&lt;a href=&quot;#在文件中引入Bootstrap3的库&quot; class</summary>
      
    
    
    
    <category term="前端" scheme="https://www.legr4ndk.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="bootstrap" scheme="https://www.legr4ndk.top/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>注 入 怨 念</title>
    <link href="https://www.legr4ndk.top/2020/11/27/EssayP/"/>
    <id>https://www.legr4ndk.top/2020/11/27/EssayP/</id>
    <published>2020-11-27T15:23:06.000Z</published>
    <updated>2021-03-14T10:17:28.586Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一首很有感觉的诗，且放在这边：</p><blockquote><p>我把子弹穿破胸膛<br>我的眼睛被鲸鲨咬碎<br>口腔被灌满砒霜溃疡<br>双手砍断滚在床下<br>少女把头颅盛走<br>你就静静看着我<br>把我泡在福尔马林<br>永垂不朽</p></blockquote><p><strong>活在福尔马林里，也未尝不是永垂不朽。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看到一首很有感觉的诗，且放在这边：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我把子弹穿破胸膛&lt;br&gt;我的眼睛被鲸鲨咬碎&lt;br&gt;口腔被灌满砒霜溃疡&lt;br&gt;双手砍断滚在床下&lt;br&gt;少女把头颅盛走&lt;br&gt;你就静静看着我&lt;br&gt;把我泡在福尔马林&lt;br&gt;永垂不朽&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="个人感悟" scheme="https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="misc" scheme="https://www.legr4ndk.top/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>马保国日语版</title>
    <link href="https://www.legr4ndk.top/2020/11/24/masensei/"/>
    <id>https://www.legr4ndk.top/2020/11/24/masensei/</id>
    <published>2020-11-24T13:36:30.000Z</published>
    <updated>2021-03-14T10:17:28.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原视频见于<a href="https://www.bilibili.com/video/BV1QV411a75M">Bilibili</a></p><p>此处只是靠听力和字幕扒取了台词</p><p>止增笑耳</p></blockquote><p>こんにちは</p><p>俺(おれ)は太極(たいきょく)マスター</p><p>马(mǎ) 保(bǎo) 国(guó)</p><p>今(いま)　友達(ともだち)が「先生(せんせい)どうしたの」と</p><p>俺(おれ)は「何(なに)が」と</p><p>写真(しゃしん)が何枚来(なんまいき)た</p><p>俺見(おれみ)たと</p><p>お！</p><p>それは昨日(きのう)</p><p>二人(ふたり)の若(わか)もん</p><p>３０ぐらい</p><p>一人体重(ひとりたいじゅう)９０キロ</p><p>一人体重(ひとりたいじゅう)８０キロ</p><p>彼(かれ)ら</p><p>一人(ひとり)</p><p>「俺(おれ)、ジム(じむ)で運動(うんどう)、首(くび)がひねった、馬先生(うませんせい)、太極(たいきょく)を気功(きこう)を、教(おし)えてくれない？」</p><p>俺(おれ)は「いい」と</p><p>おれは「君(きみ)の筋(きん)トレ效(き)かない」</p><p>彼(かれ)は不満(ふまん)</p><p>俺(おれ)は「子供(こども)よ、両手(りょうて)で俺(おれ)の指(ゆび)を折(お)ってみ」</p><p>折(お)れない</p><p>彼(かれ)は「役立(やくだ)てない」と</p><p>俺(おれ)は「役立(やくだ)てる」と</p><p>これ「化力(かりょく)」</p><p>カンフー技(わざ)</p><p>四両(よんりょう)で千斤(せんきん)を制(せい)する</p><p>２００斤(きん)の英国力士(えいこくりきし)</p><p>俺(おれ)の指(ゆび)に勝(か)てない</p><p>あ！</p><p>彼(かれ)はやってみみと</p><p>俺(おれ)はオッケーと</p><p>そして彼(かれ)ガーと立(た)て</p><p>速(はや)いあ！</p><p>そして続(つづ)いて</p><p>先ず左蹴(ひだりしゅう) 「ん」</p><p>次右(つぎみぎ)サイド</p><p>最後左(さいごひだり)ジャブ</p><p>俺全部(おれぜんぶ)ガードした</p><p>ガードした！</p><p>ガードしてもちろん伝統(でんとう)カンフーは切磋(せっさ)だけ  </p><p>右手鼻(みぎてはな)につけて</p><p>打(う)たない</p><p>俺笑(おれわら)って</p><p>手(て)を引(ひ)こうと</p><p>だからここで</p><p>伝統(でんとう)カンフーの切磋琢磨(せっさたくま)で</p><p>彼(かれ)はすでに負(ま)けた</p><p>もし力(ちから)いれたら</p><p>ワンパンチで彼(かれ)の鼻(はな)を折(お)った</p><p>鼻(はな)につけて打(う)たない</p><p>かれ認(みと)め</p><p>俺(おれ)は彼(かれ)の顔(かお)に行(い)った</p><p>彼(かれ)は鼻(はな)がつけられたのを知(し)らずに</p><p>俺(おれ)は顔(かお)に行ったと認(みと)めた</p><p>俺(おれ)は手(て)を引(ひ)いてやめた</p><p>彼(かれ)は不意打(ふいう)ち</p><p>左(ひだり)ジャブ俺(おれ)の顔(かお)を</p><p>俺油断(おれゆだん)したら、「迷(まよ)うさ」<strong>（没有闪）</strong></p><p>彼(かれ)の左(ひだり)パンチ俺(おれ)の目(め)…</p><p>右目(みぎめ)に擦(す)った</p><p>でも大丈夫(だいじょうぶ)</p><p>彼(かれ)も写真(しゃしん)で言(い)った</p><p>二分(にふん)ほど以降(いこう)</p><p>その場(ば)で涙出(なみだで)た</p><p>目(め)を覆(おお)って</p><p>俺(おれ)は「止(や)めて」と</p><p>二(に)分(ふん)以(い)ほ…二(に)分(ふん)以(い)降(こう)</p><p>治(なお)った</p><p>俺(おれ)はガキお前(まえ)</p><p>ジャブじゃ無駄(むだ)</p><p>しぶとう</p><p>彼(かれ)は「馬先生(ませんせい)御免御免(ごめんごめん)、俺(おれ)は素人(しろうと)」</p><p>「俺(おれ)は無鉄砲(むてっぽう)」と</p><p>彼(かれ)は無鉄砲(むてっぽう)じゃないんだ</p><p>前(まえ)キック、サイドキック</p><p>左(ひだり)パンチ、練(ね)れ者(もの)</p><p>あとで彼(かれ)は三(さん)四(よん)年(ねん)</p><p>タイ拳(こぶし)お習(なら)った</p><p>やはり　準備万端(じゅんびばんたん)<strong>（有bear来）</strong></p><p>これら　若造(わかぞう)</p><p>無駄無駄(むだむだ)<strong>（不讲武德）</strong></p><p>だ～ます</p><p>不(ふ)意(い)～打(う)ち</p><p>六(ろく)十(じゅう)九(きゅう)歳(さい)の老(ろう)人(じん)</p><p>いいのか？よくない</p><p>小(こ)僧(ぞう)　よくお前(まえ)は</p><p>恥(は)ず忘(わす)<strong>（耗子尾汁）</strong>れてます</p><p>今後(こんご)</p><p>このようなずる</p><p>小賢(こざか)しい</p><p>武林(ぶりん)は和(わ)を大事(だいじ)</p><p>ようじゃ無駄(むだ)<strong>（要讲武德）</strong></p><p>八百(はっぴゃく)るな～俺(おれ)と<strong>（不要搞窝里斗）</strong></p><p>ありがとうね！</p><hr><p>已经更新完了，还加了汉字的假名注音hh</p><p>可以拿去照着这个台本配音玩了</p><p>有部分是字幕里有但是那人没念出来的，我就给删了</p><p><strong>不是标准日语，很多语法错误，但是读着好玩就是了😂</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原视频见于&lt;a href=&quot;https://www.bilibili.com/video/BV1QV411a75M&quot;&gt;Bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此处只是靠听力和字幕扒取了台词&lt;/p&gt;
&lt;p&gt;止增笑耳&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="耍" scheme="https://www.legr4ndk.top/categories/%E8%80%8D/"/>
    
    
    <category term="misc" scheme="https://www.legr4ndk.top/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>C#常见控件（WPF平台）</title>
    <link href="https://www.legr4ndk.top/2020/11/22/CsharpCommonControls/"/>
    <id>https://www.legr4ndk.top/2020/11/22/CsharpCommonControls/</id>
    <published>2020-11-22T10:48:47.000Z</published>
    <updated>2021-03-14T10:17:28.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C#的WinForm编程真的是和Visual Basic一毛一样的体验</p><p>——比隔壁C++的WinForm不知道高到哪里去了（</p></blockquote><p><strong>控件（Control）是WinForm的基本元素</strong></p><h3 id="Brief-Introduction"><a href="#Brief-Introduction" class="headerlink" title="Brief Introduction"></a>Brief Introduction</h3><p>Form控件有一个系统自动生成的一个类实例化的对象（默认叫Form1），该类自带Load事件的函数。此类定义于Form1.cs和Form1.Design.cs中。于Program.cs中另有Program.cs内定义了Main函数作为程序的起点。</p><p>常见的控件有几个基本共有的属性，如：</p><ul><li>Size：是一组共两个值，用于确定对象的宽度和高度</li><li>(Name)：相当于该对象在程序中的变量名</li><li>AutoSize：如果为True则可能造成控件某些维度的手动大小调整不可用</li><li>Location：是一组两个值，用于确定对象在窗体的位置(x,y)，窗体左上顶点为坐标原点，向右为+x，向下为+y</li></ul><h3 id="Label（标签）控件"><a href="#Label（标签）控件" class="headerlink" title="Label（标签）控件"></a>Label（标签）控件</h3><p>为控件和窗体的其它组成部分提供标识，通常用于提供描述性文字</p><p>Label控件由Label类描述，Label类继承自Control类，它在名字空间System.Windows.Forms中。</p><h4 id="Label常用属性"><a href="#Label常用属性" class="headerlink" title="Label常用属性"></a>Label常用属性</h4><ul><li>AutoElipsis：获取或者设定一个值，指示是否要在Label右边缘显示<strong>省略号</strong>表示文本超过指定长度，否则文本将被直接截断</li><li>AutoSize：获取或者设定一个值，指示是否自动调整控件大小以显示完整内容</li><li>BorderStyle：获取或设置控件的边框样式</li><li>Image：获取或设置显示在Label上的图像</li><li>Text：获取或设置与此控件相关联的文本，即显示在Label上的文本</li><li>TextAlign：获取或设置Label中文本的对齐方式</li></ul><h3 id="TextBox（文本框）控件"><a href="#TextBox（文本框）控件" class="headerlink" title="TextBox（文本框）控件"></a>TextBox（文本框）控件</h3><p>TextBox中的文本可以被编辑，而Label中的不行。</p><p>TextBox类所在的名字空间为System.Windows.Forms。</p><h4 id="TextBox常用属性"><a href="#TextBox常用属性" class="headerlink" title="TextBox常用属性"></a>TextBox常用属性</h4><ul><li>AcceptsReturn：获取或设置一个值，该值指示在多行TextBox控件中按Enter键时，是在控件中创建一行新文本还是激活窗体的默认按钮，比如用于选择按回车是输入完了还是换一行</li><li>AcceptsTab：获取或设置一个值，该值指示在多行TextBox控件中按Tab键时，是在控件中键入一个Tab字符还是按选项卡的顺序将焦点移动到下一个控件</li><li>BackColor：获取或设置控件的背景色</li><li>Focused：获取一个值，该值指示控件是否有输入焦点</li><li>Font：获取或设置控件显示的文字的字体</li><li>Multiline：获取或设置一个值，该值指示此控件是否为多行TextBox控件</li><li>PasswordChar：获取或设置字符，该字符用于屏蔽单行TextBox控件中的密码字符</li><li>ReadOnly：获取或设置一个值，该值指示文本框中的文本是否为只读</li><li>RightToLeft：获取或设置一个值，该值指示是否将控件的元素对齐以支持从右向左的字体的区域设置</li><li>SelectedText：获取或设置一个值，该值指示控件中当前选定的文本</li><li>Text：字符串，获取或设置TextBox中的当前文本</li><li>TextAlign：获取或设置控件中文本的对齐方式</li><li>TextLength：获取或设置控件中文本的长度</li><li>WordWrap：指示多行文本框控件在必要时是否自动换行到下一行开始</li></ul><h4 id="TextBox常用事件"><a href="#TextBox常用事件" class="headerlink" title="TextBox常用事件"></a>TextBox常用事件</h4><ul><li>Click：鼠标单击控件时发生</li><li>Enter：鼠标进入控件区域时发生</li><li>GotFocus：在控件得到焦点时发生</li><li>KeyDown：在控件有焦点时按下按键时发生</li><li>KeyUp：在控件有焦点时释放按键时发生</li><li>Leave：在控件失去焦点时发生</li><li>LostFocus：在控件失去焦点时发生</li><li>TextChanged：在控件的Text属性值更改时发生（文本被改变</li></ul><h3 id="Button（按钮）控件"><a href="#Button（按钮）控件" class="headerlink" title="Button（按钮）控件"></a>Button（按钮）控件</h3><p>用户可以单击按钮控件触发程序动作。</p><p>Button继承自ButtonBase类，ButtonBase继承自ContentControl类，ContentControl类继承自Control类。</p><h4 id="Button常用属性"><a href="#Button常用属性" class="headerlink" title="Button常用属性"></a>Button常用属性</h4><ul><li>ClickMode：获取或设置Click事件何时发生，ClickMode有3种<ul><li>悬停，鼠标悬停在该按钮上时激发此按钮</li><li>按下，鼠标在该按钮上按下时激发此按钮</li><li>释放，鼠标在该按钮上按下后，释放时激发此按钮</li></ul></li><li>IsCancel：获取或设置一个值，指示该Button控件是否为取消按钮。用户可以通过ESC键激活取消按钮</li><li>IsDefault：获取或设置一个值，指示该Button控件是否为默认按钮。用户可以通过Enter键调用默认按钮</li></ul><h4 id="Button常用事件"><a href="#Button常用事件" class="headerlink" title="Button常用事件"></a>Button常用事件</h4><ul><li>Click：按钮被按下时发生（最常用）</li></ul><h3 id="选项控件"><a href="#选项控件" class="headerlink" title="选项控件"></a>选项控件</h3><p>选项的作用是跟据用户的实际情况在程序运行时调整程序的状态或行为。</p><h4 id="选项控件的分类"><a href="#选项控件的分类" class="headerlink" title="选项控件的分类"></a>选项控件的分类</h4><ul><li>GroupBox（组框）</li><li>Panel（面板）</li><li>RadioButton（单选按钮）</li><li>CheckBox（复选框）</li></ul><h4 id="RadioButton"><a href="#RadioButton" class="headerlink" title="RadioButton"></a>RadioButton</h4><p>RadioButton（单选按钮）控件是用来让用户在一组选项中选定一项且只能选定一项。</p><p>若窗体内仅有一组RadioButton控件时，可以将它们直接放置在这个窗体内。</p><p>当有两组或多组选项时，RadioButton应该被放置到一个GroupBox（组框）控件内进行分组。</p><h5 id="RadioButton常用属性"><a href="#RadioButton常用属性" class="headerlink" title="RadioButton常用属性"></a>RadioButton常用属性</h5><ul><li>Text：设定该RadioButton旁边的文本内容</li><li>CheckAlign：设定控件按钮与文本的位置关系（对齐方式）</li><li>Checked：由它设定RadioButton的状态（bool类型，True-被选中，False-未被选中（缺省设置））</li></ul><h5 id="RadioButton常用事件"><a href="#RadioButton常用事件" class="headerlink" title="RadioButton常用事件"></a>RadioButton常用事件</h5><ul><li><p>CheckedChanged：Checked属性改变时发生（默认事件）</p><p><strong>在VS中，双击单选按钮控件，会自动添加默认事件的事件处理函数</strong></p></li></ul><h4 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h4><p>ChechBox（复选框）控件是让用户在一组选项中选定一项或多项。</p><p>若窗体内仅有一组CheckBox控件时，可以将它们直接放置在这个窗体内。</p><p>当有两组或多组选项时，CheckBox应该被放置到一个GroupBox（组框）控件内进行分组。</p><h5 id="CheckBox常用属性"><a href="#CheckBox常用属性" class="headerlink" title="CheckBox常用属性"></a>CheckBox常用属性</h5><ul><li>Text：设定该CheckBox旁边的文本内容</li><li>CheckAlign：设定控件按钮与文本的位置关系（对齐方式）</li><li>Checked：由它设定CheckBox的状态（bool类型，True-被选中，False-未被选中（缺省设置））</li><li>CheckState：指示CheckBox目前的状态，有三个取值<ul><li>Checked：表示被选中状态</li><li>Unchecked，表示未被选中状态</li><li>Indeterminate，表示不可用状态（此状态当ThreeState属性为True时有效）</li></ul></li></ul><h5 id="CheckBox常用事件"><a href="#CheckBox常用事件" class="headerlink" title="CheckBox常用事件"></a>CheckBox常用事件</h5><ul><li>CheckedChanged：Checked属性改变时发生（默认事件）</li><li>CheckedStateChanged：CheckedState属性改变时发生</li></ul><h4 id="GroupBox"><a href="#GroupBox" class="headerlink" title="GroupBox"></a>GroupBox</h4><p>GroupBox（组框）是一个容器类控件。</p><p>你可以将一组控件放入GroupBox来分类。</p><p>组框可以显示标题（文本），但是它没有滚动条。</p><p>边框一般比较细。</p><h5 id="GroupBox常用属性"><a href="#GroupBox常用属性" class="headerlink" title="GroupBox常用属性"></a>GroupBox常用属性</h5><ul><li>Controls：组框包含的控件集</li><li>Text：在组框顶部显示的标题文本</li></ul><h4 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h4><p>Panel（面板）与GroupBox类似，也是一个容器类控件。</p><p>你也可以将一组控件放入Panel来分类。</p><p>面板可以包含滚动条，但是它没有标题。</p><p>边框可以通过相关边框属性来调节。</p><h5 id="Panel常用属性"><a href="#Panel常用属性" class="headerlink" title="Panel常用属性"></a>Panel常用属性</h5><ul><li>AutoScroll：当面板由于太小而无法显示所有控件时，这个属性指定是否出现滚动条，默认值为False</li><li>BorderStyle：设置面板的边界样式，默认为None，其他选项有Fixed3D和FixedSingle</li><li>Controls：面板包含的控件集</li></ul><hr><p><strong>感觉差不多了，就这样吧！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C#的WinForm编程真的是和Visual Basic一毛一样的体验&lt;/p&gt;
&lt;p&gt;——比隔壁C++的WinForm不知道高到哪里去了（&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;控件（Control）是WinForm的基本元素&lt;</summary>
      
    
    
    
    <category term="客户端" scheme="https://www.legr4ndk.top/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
    <category term="csharp" scheme="https://www.legr4ndk.top/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的多态</title>
    <link href="https://www.legr4ndk.top/2020/10/23/CppPolymorphism/"/>
    <id>https://www.legr4ndk.top/2020/10/23/CppPolymorphism/</id>
    <published>2020-10-23T12:02:51.000Z</published>
    <updated>2021-03-14T10:17:28.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多态是面向对象编程内极为重要的一种特征，它能极大的简化我们的代码</p></blockquote><p>先来看一段类的原型</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> //基类</span><br><span class="hljs-class">{</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Voiceless"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//不知道该叫啥</span><br>    };<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal <span class="hljs-comment">//狗派生类，继承了Animal</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Woof"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//汪汪叫</span><br>    }<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span> <span class="hljs-keyword">public</span> Animal <span class="hljs-comment">//猫派生类，继承了Animal</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Meow"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//喵喵叫</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>我们可以看到，基类和派生类中都有函数voice()，它可以让不同的动物发出不同的叫声，其中，Dog类和Cat类的voice()函数是覆写了基类中的同名函数。</p><p>当然，还可以有很多基于Animal类的派生类，都可以有叫声，但是我们如果想统一一下让它们叫的方法，比如用个train函数，传入对象或者它的指针就可以自动调用它的voice函数。虽然Cpp支持重载函数，但是为每个不同的类各写一个这样的函数，工作量不仅大，而且枯燥。多态就是帮我们解决这个问题的。</p><p><strong>多态</strong> <em>Polymorphism</em></p><p>表现方式有两种</p><ul><li>重载多态，比如函数重载（本文不介绍了），属于静态联编</li><li>子类型多态，属于动态联编，就是我接下来要说的那些</li></ul><p>子类型多态有两个要点：</p><ol><li>虚函数</li><li>函数覆写<sub>override</sub></li></ol><p>我们来区分涉及继承链情况下的两种联编：</p><ol><li>通过派生类对象访问同名函数，是静态联编</li><li>通过基类对象的指针访问同名函数，是静态联编</li><li>通过基类对象的指针或引用访问同名虚函数，是动态联编</li></ol><p>那我们现在改一下原来的类的定义让它符合子类型多态的要求</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">{</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span> <span class="hljs-comment">//此函数声明为虚函数后，派生类中无须再注明</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Voiceless"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    };<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-comment">//覆写了voice函数</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Woof"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    }<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span> <span class="hljs-keyword">public</span> Animal<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-comment">//覆写了voice函数</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Meow"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么还是刚刚那个例子，我们设计一个train函数</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">train</span><span class="hljs-params">(Animal animal)</span></span><br><span class="hljs-function"></span>{<br>    animal.voice();<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用这个函数，你会发现无论你往参数里塞了什么阿猫阿狗的对象，输出的永远是“Voiceless”，这便是静态联编的问题了，它使用的是基类的对象而非基类对象的指针或引用，你需要把train修改成这样：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">train</span><span class="hljs-params">(Animal&amp; animal)</span></span><br><span class="hljs-function"></span>{<br>    animal.voice();<br>}<br><span class="hljs-comment">//或者这样</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">train</span><span class="hljs-params">(Animal* animal)</span></span><br><span class="hljs-function"></span>{<br>    animal-&gt;voice();<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后你的子类对象在调用这个train函数之后就可以正常发出正确的声音了</p><p><strong>需要注意的是，如果voice函数不是<em>虚函数</em>，那么即使你用了派生类对象的指针、引用，只要那个进入函数的东西的类型是基类，它就会调用基类的函数</strong></p><p>一句话总结一下，就是：<strong>函数虚，看对象；函数实，看类型。</strong></p><p>但是，这个东西它也有问题，就是你使用基类的指针（或者引用）指向了派生类的对象的时候，你只能调用派生类的虚函数，无法调用非虚函数，例如我改一下Dog类的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">voice</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Woof"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">//这个不是虚函数了</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Foo!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>但是我在main函数里这样定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">Animal ptr;<br>Dog dog = <span class="hljs-keyword">new</span> Dog();<br>ptr = &amp;dog;<br>ptr-&gt;voice(); <span class="hljs-comment">//调用的是dog对象的voice函数</span><br>ptr-&gt;foo(); <span class="hljs-comment">//无法调用，No member named foo in Animal</span><br></code></pre></td></tr></tbody></table></figure><p>Animal类的指针虽然指向了dog，但是它将无法调用dog的非虚函数，但是如果我们偏要调用属于子类的非虚函数呢？</p><p><strong>Introducing dynamic_cast!</strong></p><p>Cpp的dynamic_cast&lt;&gt;运算符可以把基类类型的指针转换为派生类的类型的指针，就可以使调用子类的非虚函数称为可能，方法如下</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">ptr-&gt;foo(); <span class="hljs-comment">//它出了问题</span><br><span class="hljs-keyword">dynamic_cast</span>&lt;Dog*&gt;(ptr)-&gt;foo(); <span class="hljs-comment">//正常调用！</span><br></code></pre></td></tr></tbody></table></figure><p>虽然建议在任何基类与派生类间的指针、引用的类型转换都使用dynamic_cast运算符，但是实际上，派生类的指针（引用）转为基类类型的指针（引用）可以不使用该运算符而隐式转换，而基类的指针（引用）转为派生类类型的指针（引用）<strong>必须</strong>显式使用该运算符以完成类型转换。</p><p>比如我们有：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><code class="hljs c++">Animal animal;<br>Animal* pa;<br>Cat cat;<br>Cat* pc;<br><br>pa = &amp;cat; <span class="hljs-comment">//可以隐式转换（下转上）</span><br>pc = <span class="hljs-keyword">dynamic_cast</span>&lt;Cat*&gt;(animal); <span class="hljs-comment">//必须显式转换（上转下）</span><br></code></pre></td></tr></tbody></table></figure><p>多态就先写这么多~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;多态是面向对象编程内极为重要的一种特征，它能极大的简化我们的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来看一段类的原型&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="后端" scheme="https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="cpp" scheme="https://www.legr4ndk.top/tags/cpp/"/>
    
  </entry>
  
</feed>
