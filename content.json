{"meta":{"title":"Legrandk's Qzone","subtitle":"","description":"","author":"Legrandk","url":"https://legr4ndk.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2020-10-17T10:21:49.923Z","updated":"2020-10-17T10:21:49.923Z","comments":false,"path":"links/index.html","permalink":"https://legr4ndk.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-26T15:23:28.551Z","updated":"2020-11-26T15:23:28.551Z","comments":false,"path":"about/index.html","permalink":"https://legr4ndk.github.io/about/index.html","excerpt":"","text":"About 我一只HDU的沙雕 id源自曾服役120年的国际标准公斤实体Le Grand K 网络空间安全专业出身，现为计算机科学与技术专业学生 喜欢键政的马克思主义者（屁股没歪 喜欢插flag（然后不拔 D D L 人 为人儒雅随和，见谁都能有的没的扯几句 夜猫子，但是从来没有通宵过 What 我在做的 学习C#与.Net Core 想学好C++的网络编程和Windows API 被老师抓去做新苗计划了，学习MindSpore与后端开发中 百 萬 前 端 大 製 作 日语 What 我喜欢的 日语ACG类歌曲 Vocaloid歌曲 异世界、末日题材番 无厘头动漫 英文pop/country music 部分小语种 日式角色扮演游戏（JRPG） 第一人称射击类游戏（FPS） 王者荣耀（纯消遣🤣） 正在尝试无双类与开放世界类 How to 找我玩新浪微博：Iegrandk（注意第一个是大写的i） QQ音乐：Legrandk 网易云音乐：六氟锑酸钠_NaSbF6 知乎：Legrandk 邮箱：legrandk@aliyun.com Github：legr4ndk Gitee：Legrandk"},{"title":"分类","date":"2020-10-16T07:32:16.374Z","updated":"2020-10-16T07:32:16.374Z","comments":false,"path":"categories/index.html","permalink":"https://legr4ndk.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-16T07:32:16.376Z","updated":"2020-10-16T07:32:16.376Z","comments":false,"path":"tags/index.html","permalink":"https://legr4ndk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"马宝国日语版脚本","slug":"masensei","date":"2020-11-24T13:36:30.000Z","updated":"2020-11-26T15:04:02.727Z","comments":true,"path":"2020/11/24/masensei/","link":"","permalink":"https://legr4ndk.github.io/2020/11/24/masensei/","excerpt":"","text":"原视频见于Bilibili 此处只是靠听力和字幕扒取了台词 ——Just for fun こんにちは 俺は太極マスター 马保国 今 友達が「先生どうしたの」と 俺は「何が」と 写真がなん何枚来た 俺見たと お！ それは昨日 二人の若もん ３０ぐらい 一人体重９０キロ 一人体重８０キロ 彼ら 一人 「俺はジムで運動、首がひねった、馬先生、太極を気功を、教えてくれない？」 俺は「いい」と おれは「君の筋トレ效かない」 彼は不満 俺は「子供よ、両手で俺の指を折ってみ」 折れない 彼は「役立てない」と 俺は「役立てる」と これ「化力」 カンフー技 四両で千斤を制する ２００斤の英国力士 俺の指に勝てない あ！ 彼はやってみみと おれはオッケーと そして彼ガーと立て 速いあ！ そして続いて 先ず左蹴 次右サイド 最後左ジャブ 俺全部ガードした ガードしてもちろん伝統カンフーは 切磋だけ 未完待续~","categories":[{"name":"Essay","slug":"Essay","permalink":"https://legr4ndk.github.io/categories/Essay/"}],"tags":[{"name":"fun","slug":"fun","permalink":"https://legr4ndk.github.io/tags/fun/"}]},{"title":"C#常见控件","slug":"CsharpCommonControls","date":"2020-11-22T10:48:47.000Z","updated":"2020-11-24T13:35:27.618Z","comments":true,"path":"2020/11/22/CsharpCommonControls/","link":"","permalink":"https://legr4ndk.github.io/2020/11/22/CsharpCommonControls/","excerpt":"","text":"C#的WinForm编程真的是和Visual Basic一毛一样的体验 ——比隔壁C++的WinForm不知道高到哪里去了（ 控件（Control）是WinForm的基本元素 Brief IntroductionForm控件有一个系统自动生成的一个类实例化的对象（默认叫Form1），该类自带Load事件的函数。此类定义于Form1.cs和Form1.Design.cs中。于Program.cs中另有Program.cs内定义了Main函数作为程序的起点。 常见的控件有几个基本共有的属性，如： Size：是一组共两个值，用于确定对象的宽度和高度 (Name)：相当于该对象在程序中的变量名 AutoSize：如果为True则可能造成控件某些维度的手动大小调整不可用 Location：是一组两个值，用于确定对象在窗体的位置(x,y)，窗体左上顶点为坐标原点，向右为+x，向下为+y Label（标签）控件为控件和窗体的其它组成部分提供标识，通常用于提供描述性文字 Label控件由Label类描述，Label类继承自Control类，它在名字空间System.Windows.Forms中。 Label常用属性 AutoElipsis：获取或者设定一个值，指示是否要在Label右边缘显示省略号表示文本超过指定长度，否则文本将被直接截断 AutoSize：获取或者设定一个值，指示是否自动调整控件大小以显示完整内容 BorderStyle：获取或设置控件的边框样式 Image：获取或设置显示在Label上的图像 Text：获取或设置与此控件相关联的文本，即显示在Label上的文本 TextAlign：获取或设置Label中文本的对齐方式 TextBox（文本框）控件TextBox中的文本可以被编辑，而Label中的不行。 TextBox类所在的名字空间为System.Windows.Forms。 TextBox常用属性 AcceptsReturn：获取或设置一个值，该值指示在多行TextBox控件中按Enter键时，是在控件中创建一行新文本还是激活窗体的默认按钮，比如用于选择按回车是输入完了还是换一行 AcceptsTab：获取或设置一个值，该值指示在多行TextBox控件中按Tab键时，是在控件中键入一个Tab字符还是按选项卡的顺序将焦点移动到下一个控件 BackColor：获取或设置控件的背景色 Focused：获取一个值，该值指示控件是否有输入焦点 Font：获取或设置控件显示的文字的字体 Multiline：获取或设置一个值，该值指示此控件是否为多行TextBox控件 PasswordChar：获取或设置字符，该字符用于屏蔽单行TextBox控件中的密码字符 ReadOnly：获取或设置一个值，该值指示文本框中的文本是否为只读 RightToLeft：获取或设置一个值，该值指示是否将控件的元素对齐以支持从右向左的字体的区域设置 SelectedText：获取或设置一个值，该值指示控件中当前选定的文本 Text：字符串，获取或设置TextBox中的当前文本 TextAlign：获取或设置控件中文本的对齐方式 TextLength：获取或设置控件中文本的长度 WordWrap：指示多行文本框控件在必要时是否自动换行到下一行开始 TextBox常用事件 Click：鼠标单击控件时发生 Enter：鼠标进入控件区域时发生 GotFocus：在控件得到焦点时发生 KeyDown：在控件有焦点时按下按键时发生 KeyUp：在控件有焦点时释放按键时发生 Leave：在控件失去焦点时发生 LostFocus：在控件失去焦点时发生 TextChanged：在控件的Text属性值更改时发生（文本被改变 Button（按钮）控件用户可以单击按钮控件触发程序动作。 Button继承自ButtonBase类，ButtonBase继承自ContentControl类，ContentControl类继承自Control类。 Button常用属性 ClickMode：获取或设置Click事件何时发生，ClickMode有3种 悬停，鼠标悬停在该按钮上时激发此按钮 按下，鼠标在该按钮上按下时激发此按钮 释放，鼠标在该按钮上按下后，释放时激发此按钮 IsCancel：获取或设置一个值，指示该Button控件是否为取消按钮。用户可以通过ESC键激活取消按钮 IsDefault：获取或设置一个值，指示该Button控件是否为默认按钮。用户可以通过Enter键调用默认按钮 Button常用事件 Click：按钮被按下时发生（最常用） 选项控件选项的作用是跟据用户的实际情况在程序运行时调整程序的状态或行为。 选项控件的分类 GroupBox（组框） Panel（面板） RadioButton（单选按钮） CheckBox（复选框） RadioButtonRadioButton（单选按钮）控件是用来让用户在一组选项中选定一项且只能选定一项。 若窗体内仅有一组RadioButton控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，RadioButton应该被放置到一个GroupBox（组框）控件内进行分组。 RadioButton常用属性 Text：设定该RadioButton旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定RadioButton的状态（bool类型，True-被选中，False-未被选中（缺省设置）） RadioButton常用事件 CheckedChanged：Checked属性改变时发生（默认事件） 在VS中，双击单选按钮控件，会自动添加默认事件的事件处理函数 CheckBoxChechBox（复选框）控件是让用户在一组选项中选定一项或多项。 若窗体内仅有一组CheckBox控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，CheckBox应该被放置到一个GroupBox（组框）控件内进行分组。 CheckBox常用属性 Text：设定该CheckBox旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定CheckBox的状态（bool类型，True-被选中，False-未被选中（缺省设置）） CheckState：指示CheckBox目前的状态，有三个取值 Checked：表示被选中状态 Unchecked，表示未被选中状态 Indeterminate，表示不可用状态（此状态当ThreeState属性为True时有效） CheckBox常用事件 CheckedChanged：Checked属性改变时发生（默认事件） CheckedStateChanged：CheckedState属性改变时发生 GroupBoxGroupBox（组框）是一个容器类控件。 你可以将一组控件放入GroupBox来分类。 组框可以显示标题（文本），但是它没有滚动条。 边框一般比较细。 GroupBox常用属性 Controls：组框包含的控件集 Text：在组框顶部显示的标题文本 PanelPanel（面板）与GroupBox类似，也是一个容器类控件。 你也可以将一组控件放入Panel来分类。 面板可以包含滚动条，但是它没有标题。 边框可以通过相关边框属性来调节。 Panel常用属性 AutoScroll：当面板由于太小而无法显示所有控件时，这个属性指定是否出现滚动条，默认值为False BorderStyle：设置面板的边界样式，默认为None，其他选项有Fixed3D和FixedSingle Controls：面板包含的控件集 待续~","categories":[{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://legr4ndk.github.io/tags/C/"}]},{"title":"Cpp中的多态","slug":"CppPolymorphism","date":"2020-10-23T12:02:51.000Z","updated":"2020-10-23T13:41:34.465Z","comments":true,"path":"2020/10/23/CppPolymorphism/","link":"","permalink":"https://legr4ndk.github.io/2020/10/23/CppPolymorphism/","excerpt":"","text":"多态是面向对象编程内极为重要的一种特征，它能极大的简化我们的代码 先来看一段类的原型 class Animal //基类&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Voiceless&quot; &lt;&lt; std::endl; //不知道该叫啥 &#125;;&#125;;class Dog : public Animal //狗派生类，继承了Animal&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; //汪汪叫 &#125;&#125;;class Cat : public Animal //猫派生类，继承了Animal&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Meow&quot; &lt;&lt; std::endl; //喵喵叫 &#125;&#125;; 我们可以看到，基类和派生类中都有函数voice()，它可以让不同的动物发出不同的叫声，其中，Dog类和Cat类的voice()函数是覆写了基类中的同名函数。 当然，还可以有很多基于Animal类的派生类，都可以有叫声，但是我们如果想统一一下让它们叫的方法，比如用个train函数，传入对象或者它的指针就可以自动调用它的voice函数。虽然Cpp支持重载函数，但是为每个不同的类各写一个这样的函数，工作量不仅大，而且枯燥。多态就是帮我们解决这个问题的。 多态 Polymorphism 表现方式有两种 重载多态，比如函数重载（本文不介绍了），属于静态联编 子类型多态，属于动态联编，就是我接下来要说的那些 子类型多态有两个要点： 虚函数 函数覆写override 我们来区分涉及继承链情况下的两种联编： 通过派生类对象访问同名函数，是静态联编 通过基类对象的指针访问同名函数，是静态联编 通过基类对象的指针或引用访问同名虚函数，是动态联编 那我们现在改一下原来的类的定义让它符合子类型多态的要求 class Animal&#123;public: virtual void voice() //此函数声明为虚函数后，派生类中无须再注明 &#123; std::cout &lt;&lt; &quot;Voiceless&quot; &lt;&lt; std::endl; &#125;;&#125;;class Dog : public Animal&#123;public: void voice() override //覆写了voice函数 &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; &#125;&#125;;class Cat : public Animal&#123;public: void voice() override //覆写了voice函数 &#123; std::cout &lt;&lt; &quot;Meow&quot; &lt;&lt; std::endl; &#125;&#125;; 那么还是刚刚那个例子，我们设计一个train函数 void train(Animal animal)&#123; animal.voice();&#125; 使用这个函数，你会发现无论你往参数里塞了什么阿猫阿狗的对象，输出的永远是“Voiceless”，这便是静态联编的问题了，它使用的是基类的对象而非基类对象的指针或引用，你需要把train修改成这样： void train(Animal&amp; animal)&#123; animal.voice();&#125;//或者这样void train(Animal* animal)&#123; animal-&gt;voice();&#125; 然后你的子类对象在调用这个train函数之后就可以正常发出正确的声音了 需要注意的是，如果voice函数不是虚函数，那么即使你用了派生类对象的指针、引用，只要那个进入函数的东西的类型是基类，它就会调用基类的函数 一句话总结一下，就是：函数虚，看对象；函数实，看类型。 但是，这个东西它也有问题，就是你使用基类的指针（或者引用）指向了派生类的对象的时候，你只能调用派生类的虚函数，无法调用非虚函数，例如我改一下Dog类的定义： class Dog : public Animal&#123;public: void voice() override &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; &#125; void foo() //这个不是虚函数了 &#123; std::cout &lt;&lt; &quot;Foo!&quot; &lt;&lt; std::endl; &#125;&#125;; 但是我在main函数里这样定义： Animal ptr;Dog dog = new Dog();ptr = &amp;dog;ptr-&gt;voice(); //调用的是dog对象的voice函数ptr-&gt;foo(); //无法调用，No member named foo in Animal Animal类的指针虽然指向了dog，但是它将无法调用dog的非虚函数，但是如果我们偏要调用属于子类的非虚函数呢？ Introducing dynamic_cast! Cpp的dynamic_cast&lt;&gt;运算符可以把基类类型的指针转换为派生类的类型的指针，就可以使调用子类的非虚函数称为可能，方法如下 ptr-&gt;foo(); //它出了问题dynamic_cast&lt;Dog*&gt;(ptr)-&gt;foo(); //正常调用！ 虽然建议在任何基类与派生类间的指针、引用的类型转换都使用dynamic_cast运算符，但是实际上，派生类的指针（引用）转为基类类型的指针（引用）可以不使用该运算符而隐式转换，而基类的指针（引用）转为派生类类型的指针（引用）必须显式使用该运算符以完成类型转换。 比如我们有： Animal animal;Animal* pa;Cat cat;Cat* pc;pa = &amp;cat; //可以隐式转换（下转上）pc = dynamic_cast&lt;Cat*&gt;(animal); //必须显式转换（上转下） 多态就先写这么多~","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/tags/C-C/"}]},{"title":"Markdown语法教程","slug":"MarkdownCourse","date":"2020-10-18T14:11:22.000Z","updated":"2020-10-22T12:43:35.903Z","comments":true,"path":"2020/10/18/MarkdownCourse/","link":"","permalink":"https://legr4ndk.github.io/2020/10/18/MarkdownCourse/","excerpt":"","text":"这篇文章简单介绍下Markdown的基础语法，对写文章，记笔记有用 注意，Markdown排版支持大量html标签 # 大小标题（使用标题可以生成大纲） 使用=和-标记一号和二号标题 我是大标题我是小标题我是大标题=========在第二行书写多个=，为一级标题我是小标题---------------在第二行书写多个-，为二级标题 使用#标记1-6级标题 我是H1我是H2我是H3我是H4我是H5我是H6# 我是H1## 我是H2### 我是H3#### 我是H4##### 我是H5###### 我是H6是几级标题就打几个#，再跟上一个空格 特殊格式我是斜体 我是粗体 我是斜粗体 *我是斜体***我是粗体*****我是斜粗体***注意，星号可以用下划线替代 分割线，就像这样 ***___---你需要使用连续三个及以上的星号、减号或者下划线来创建分割线，每个符号间可以有空格 下划线和删除线 我是下划线 我是删除线 &lt;u&gt;我是下划线&lt;/u&gt;~~我是删除线~~下划线使用html的u标签实现，删除线在前后加上两个~即可 列表 第一项 第二项 第三项 第一项 第二项 * 第一项* 第二项* 第三项无序列表使用星号（或者加号、减号）跟一个空格1. 第一项2. 第二项有序列表使用数字加一个小数点以跟一个空格 区块 这是区块 &gt; 这是区块大于号加一个空格 代码块 这是代码块​```[language]#Codes here​```前后三个点包围的区块，第一块三个点后面可以跟上语言的名称 超链接 这是指向我的博客的超链接 [这是指向我的博客的超链接](https://legr4ndk.github.io/)方括号里是显示的字，小括号里是要跳转的链接当然你也可以使用html的&lt;a&gt;标签 图片 ![龙龙快动啊](MarkdownCourse\\test.jpg)一个感叹号直接接中括号，里面是注释文本，后面跟的小括号里面是图片路径当然你也可以使用html的&lt;img&gt;标签 表格 表头 表头 表头 表头 单元格 左对齐 右对齐 居中对齐 | 表头 | 表头 | 表头 | 表头 || ---- | :---- | ----: | :----: || 单元格 | 左对齐 | 右对齐 | 居中对齐 |使用|来分割单元格，使用-来分割表头和其他行，使用:来确定当列的对齐方式使用html的&lt;table&gt;标签也可以做到 够你喝一壶了！","categories":[{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"}],"tags":[]},{"title":"用Hexo配合GitHub快速上线自己的个人博客","slug":"HexoCourse","date":"2020-10-18T09:05:41.000Z","updated":"2020-10-18T11:28:24.855Z","comments":true,"path":"2020/10/18/HexoCourse/","link":"","permalink":"https://legr4ndk.github.io/2020/10/18/HexoCourse/","excerpt":"","text":"不想买服务器却又想创造属于自己的网站？Hexo可以帮你。 啥是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程可以让你快速上线属于你自己的博客。 事前准备你需要安装两个东西：Git和Node.js Git的安装教程在这儿。 Node.js可以直接在这儿下载，不要忘记把它加到环境变量中去。 安装完之后可以在命令行中输入 ➜ git --version #输入这个，下面是显示的内容git version 2.28.0.windows.1 ➜ npm --version #输入这个，下面是显示的内容6.14.8 如果均有回显版本号（可能你的版本和我的不一样），那么就说明安装成功了。 接下来因为要用到npm这个包管理器，所以先给npm的镜像站点换成国内的淘宝源，命令如下： ➜ npm config set registry https://registry.npm.taobao.org 然后准备工作就全部完成了。 安装Hexo需要以下几个命名，按顺序执行就行了： ➜ npm install hexo -g #安装hexo➜ npm install hexo-deployer-git --save #安装hexo的一个插件包，用于Git部署 安装完之后，你需要建立一个文件夹专门用来存放你的博客的文件，然后打开那个文件夹，在该文件夹里打开命令行窗口（Windows用户可以选择通过按住Shift并在文件夹窗口空白地区右键来打开PowerShell），现在需要初始化你的网站，命令行输入： ➜ hexo init #初始化hexo站点，init=initialize 此命令会从远程仓库克隆基础的Hexo站点模板，视你的网络条件（你懂）此过程可能持续数分钟，然后你的文件夹里会多很多文件，主文件夹结构大致如下： ├─node_modules #太大了不展开了├─scaffolds├─source #要展示在网页上的资源文件│ └─_posts #存放博客内的博文和媒体文件，博文以markdown存储└─themes #存放主题文件，自带一个landscape主题，此处以它为例，如果要用其他主题也请放入这边 └─landscape #主题存放文件夹，此处有主题的配置文件_config.yml ├─languages ├─layout │ ├─_partial │ │ └─post │ └─_widget ├─scripts └─source ├─css │ ├─fonts │ ├─images │ ├─_partial │ └─_util ├─fancybox │ └─helpers └─js 然后，你可以在命令行执行以下语句来清理已有网站内容 ➜ hexo clean 正式使用Hexo先介绍几个Hexo使用的基本命令： ➜ hexo generate #或者 hexo g，用来跟据你写好的md博文生成新的网页文件并链接➜ hexo server #或者hexo s,用于在本地的4000端口（127.0.0.1:4000）实时预览你的网页➜ hexo new &#x27;xxx&#x27; #新建博文，会在主文件夹/source/_posts文件夹下创建xxx.md与同名媒体文件夹 编辑博文请在md文件内，博文的资源文件（如图片）请放到同名文件夹中并在md文件中使用相对地址链接来完成（比如./xxx/233.jpg)。 ——————那么做到这步我就假定你已经在刚刚生成的.md文件中写完文章了—————— 部署Hexo博客到GitHub毫无疑问你得先注册个GitHub，如果还没有的话，点这里去注册。 然后新建一个仓库，注意这个仓库必须是开源的，而且名字有一定要求：必须是 用户名.github.io 例如我的GitHub的id是legr4ndk，那么我的仓库名就是legr4ndk.github.io。 新建仓库之后，你可以在仓库里找到你仓库的链接，就像这样： https://github.com/YourGithubID/YourRepoName.git 然后打开你的本地Hexo文件夹，有个_config.yml文件（注意不是主题文件夹里的那个），使用你的代码编辑器打开它，划到最下面有个deploy标签，你需要编辑一下： #原来是这样的deploy: type: &#39;&#39; #你需要把它改成deploy: type: &#39;git&#39; repository: https:&#x2F;&#x2F;github.com&#x2F;YourGithubID&#x2F;YourRepoName.git #这边写的是你的仓库链接，我这个只是范例 #注意冒号之后有空格 第16行还有个标签叫url，你需要把后面的值改成你的仓库名称，比如这样： url: http:&#x2F;&#x2F;YourGithubID.github.io 然后保存即可。 在部署前你必须使用hexo g重新生成网页文件。你可以运行hexo s命令先在本地检查你的网站还有没有问题。 部署使用一个命令： ➜ hexo deploy #或者hexo d，把本地生成的文件部署到GitHub上 如果你是第一次在命令行上面使用GitHub，那么将会有一个弹窗要求你登录你的GitHub，之后，你的网站将会被推送到GitHub上。过几分钟你就可以通过你的仓库名作为URL访问你的网站了。比如我的网站的地址就是legr4ndk.github.io。 注意事项 GitHub因为国内特殊环境可能出现无法访问，这个需要魔法上网。 每次deploy之后都需要几分钟后才能刷新观察到变化，切勿心急 每次写完新文章或者更换主题什么的之后，必须使用hexo g重新生成文件之后再部署 主题可以去这里寻找自己喜欢的，点击主题名字可以直接跳转主题的GitHub页面，跟据上面的教程安装即可。更改主题请去本地Hexo主文件夹的_config.yml内的theme标签更改。 主题内可能有部分依赖，建议换主题后在主题文件夹的命令行内运行npm install一键安装依赖（有的主题可能不行，建议查看主题的项目下的安装教程）。 到此为止你已经可以上线一个基础的个人网站了，接下来就是跟据主题的README.md文件介绍的那样去自己订制网页了。 Have fun~","categories":[{"name":"Git","slug":"Git","permalink":"https://legr4ndk.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://legr4ndk.github.io/tags/git/"}]},{"title":"Essay1","slug":"Essay1","date":"2020-10-17T13:19:02.000Z","updated":"2020-10-18T05:27:20.687Z","comments":true,"path":"2020/10/17/Essay1/","link":"","permalink":"https://legr4ndk.github.io/2020/10/17/Essay1/","excerpt":"","text":"越是了解一个人，就会越看到这个人产出的屎。 这是我在朋友的博客上看到的一句话，能看到这篇文章的应该都是些熟悉我的人，那么我便也如法炮制一下，在这边记录一波我产出的屎吧。 昨天有个学弟告诉我，他报名的两个学生组织类社团他全都落选了，他现在没社团进了该咋办。我虽然出发点不同，但我的现实情况其实和他有点相似。我一直是对学生组织类社团有些嗤之以鼻的，那些社团总会占用我大把的私人时间去做一些我认为无意义的活动，乃至高频次的聚餐和团建，说实话真让我这个“社恐”唯恐避之不及。再加上大一竞选班长的糟心事儿，我简直是快要彻底丧失了“为人民服务”的念头了。那个时候我也挺懊恼的，我说不来别人口里那种高大上的话，还有点办事不经夸。害，就这么去了好了。总之，我大一最后就参加了一个社团：IT俱乐部，这社团名字看起来似乎很“高大上”，本质上其实就是一个修电脑的社团。事情少，办实事，时间自由，正好符合我对社团的三大愿景。而且我其实也挺乐意帮同学解决电脑上的一些问题的，最后就留在了那边。其他的诸如轮滑社什么的，多少都因为过于频繁的社团活动把我劝退了。 现在想想，单一社团对我而言有利也有弊吧。我没参加很多社团，结果大一社团活动最密集那会我拿到了大把的时间去学习，在室友都忙着招新等事宜的时候，我在那边啃C Primer Plus，在朋友去参加社团聚餐的时候，我在学蟒蛇书，大一那会说实话是我大学以来学习新知识最快的时候。但是另一方面，和室友一起走出去上课的时候，他们总是会碰到认识的学长，然后我就一个人背着包在路上茫然，讶然于路上千万面孔却无一人为我所知。不得不说，大学的社团真的是扩展社交圈子的一个重要手段，有大一些的关系圈的话别的不说，消息是真的比我灵通太多了（苦笑），那些有关德育分、创新学分的活动，大部分是往往在我根本不知道它已经举行了的情况下错过了。【反观一下我的社交圈……似乎就周围原来玩的比较好的那几个人吧，出了周围几个寝室我就也没啥认识的人了😅】 靠！这么写起来人突然就开始丧了！大学读了一年还多了，除了拿了一点微薄的奖学金我也再没什么别的成就了，天天宅在寝室里，也没能认识到几个人，把自己关在自己的世界里，不想社交，不想谈对象。晚上的时候我也总是想我这样是不是太佛系了，但是这么反思有什么用呢？懒狗不想改变是一定不会去改变的，我想我可能需要一个契机【可能受点刺激什么的】，但是这个契机又会在什么时候出现呢。 害，这段话就当成我在这个博客放的第一个随笔吧。反正也是记录生活，写给自己看，高兴就好了！ 我计划过几天出一次教程，内容是关于我是怎么建立起这个站点的。 嗷对，国庆节那会我非常巧妙的结实了一个新朋友，有机会的话我也会再写写和他的故事。 回见~","categories":[{"name":"Essay","slug":"Essay","permalink":"https://legr4ndk.github.io/categories/Essay/"}],"tags":[{"name":"随想","slug":"随想","permalink":"https://legr4ndk.github.io/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"C语言数字、指针、布尔值灵活利用的典范","slug":"TheCLanguageIsSoNB","date":"2020-10-16T16:12:19.000Z","updated":"2020-11-24T09:12:33.124Z","comments":true,"path":"2020/10/17/TheCLanguageIsSoNB/","link":"","permalink":"https://legr4ndk.github.io/2020/10/17/TheCLanguageIsSoNB/","excerpt":"","text":"先思考这个问题，假设我有一组数，我需要在每两个数字中间加入一个空格然后再输出出来，末尾和头部都没有空格，应该如何实现。 实现方法很简单，加个if就可以实现了，比如我想输出1 2 3 4 5 6，就可以这样： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) &#123; if (i == 5) //输出到最后一个数字了 printf(&quot;%d&quot;, arr[i]); else printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125; 我们利用一个if语句来判断是否输出到最后一个数字，来选择是否输出占位的空格。事实上，也可以对第一个数字特殊对待，然后剩余数据输出时附带一个空格。 但是如果我们这么做呢： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) printf(&quot; %d&quot; + !i, arr[i]); return 0;&#125; 极其简单的几句话完成了我们之前要的操作，一气呵成。 我详细叙述下它的过程： 玄机在于printf语句的那个加法上。C语言的字符串常量作参数，实际上是一个指向常量池中该字符串的指针，也就是可以进行运算。然后就是一个!i，这是把C语言中的整型数据当布尔值来看待，对他取非。当循环第一趟时，i=0，0在C语言中是false，非i得到true，默认为1，当那个指针+1，指针就从原来的指向空格，变成指向“%d”，那么就不会输出空格。而当之后几轮时，i均为非0数，C语言中为true，那么取非则得到false，即0，那么原指针+0，就是它本身，也就会正常输出空格，最后达到我们的要求。 这种写法说实话有很大局限性，可读性也极差，但是却很好的体现了C语言的灵活之处。C语言对数据和内存的操作极为灵活，这就要求使用者有很高的水平。这种写法不推荐在正式的程序设计中使用，但是对于开拓思维、优化程序是很有帮助的。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/tags/C-C/"}]},{"title":"Use git to push your code to your Github's repository","slug":"GitPushBriefIntroduction","date":"2020-10-16T15:45:05.000Z","updated":"2020-10-17T12:34:49.666Z","comments":true,"path":"2020/10/16/GitPushBriefIntroduction/","link":"","permalink":"https://legr4ndk.github.io/2020/10/16/GitPushBriefIntroduction/","excerpt":"","text":"First things first,install git. ——Stop BBing if you have not even installed the git. Install git(may need root permission) Ubuntu/Debian/Deepin: apt install git Arch/Manjaro:pacman -S git Free BSD:pkg install git macOS:brew install git Windows:Click HERE to download the installer Run git –version to make sure that git is installed on your device. Put your codes to a folder and initializeNow you can copy+paste all your code that need to be pushed to the Github in your new folder.Then run a terminal in this folder. Using git init to initial your local repository. And do not forget to add a new repository in your Github account.Once you added a new repository to your Github,you will get a repository-link just like this: https://github.com/YourGithubID/YourRepoName.git Now,run git remote add origin $YourRepoLink to link your remote repository to the local one. Add your files to staging areaUse git add $Filename to add the files you need to staging area. Or you can use git add . (THERE IS A DOT AT THE END) to add all your files。 Then run git status to check the files in your local repository. Run git commit -m ‘$YourCommits’ to add some commits to this submit. Push your code to GithubFirst of all,use git pull origin master to pull your online repository. Use git push origin master to submit your files to Github. There are some cases that you will meet the ERROR that refusing to merge unrelated histories when you pull.You can try git pull origin master –allow-unrelated-histories to allow merging two unrelated branches.(At the first time,the online repository is empty but the local one have some files,so of course they are unrelated). Now you can check your new repository on the Github. Done,enjoy.","categories":[{"name":"Git","slug":"Git","permalink":"https://legr4ndk.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://legr4ndk.github.io/tags/git/"}]},{"title":"命名规则与驼峰命名法","slug":"NamingRuleAndCamelCase","date":"2020-10-16T13:44:37.000Z","updated":"2020-10-16T14:03:21.625Z","comments":true,"path":"2020/10/16/NamingRuleAndCamelCase/","link":"","permalink":"https://legr4ndk.github.io/2020/10/16/NamingRuleAndCamelCase/","excerpt":"","text":"还在使用x，y，z，a，b，c等无意义字符做变量名嘛？还因为把变量命名位g，s，b而遭到同学的嘲笑嘛？还因为不知道怎么命名变量能做的更直观嘛？ ——Introducing Camel-Case：驼峰命名法 我们现在先来看看一个例子： 假如我们想要定义一个变量存储我们的名字，该怎么命名呢？ mylastname 构成这个变量名的所有字母都通过小写被粗暴地整合在了一起，很难一眼看清，对吧？这种变量命名方法明显地降低了代码的可读性。要不，我们拆分一下单词？ my_last_mane 显而易见地，这个变量名的可读性比上面那种高了很多，我们可以轻易地读出它的各个单词并且很清楚地知道它的意思。但是很显然，这不够紧凑，我们还得多打两个字符（吐槽下这下划线真的不是很好按）。 驼峰命名法驼峰命名法的命名规格极为形象，通过大小写像驼峰一样变换来实现单词的区分，更方便直观地表示变量名。 那我们来看看驼峰命名法该怎么用： myLastName 相比于前两种，驼峰命名法既直观又紧凑，保证了代码可读性的同时也兼顾了效率。 驼峰命名法的规则是这样的： 当变量名或函数名是由多个单词连结在一起，构成的唯一识别字时，每一节个单词的首字母都采用大写来区分，单词与单词之间不额外添加下划线。 而以第一个单词的首字母是否要大写为区分，我们又可以分成大驼峰法和小驼峰法。 大驼峰法：包括第一个单词在内的所有单词的首字母全部大写，如： MyLastName DataBaseUser 小驼峰法：第一个单词的首字母不大写，其余每个单词的首字母均大写，如： myLastName studentsAverageGrades 驼峰命名法就介绍到这里。 接下来再讲讲我使用的一种命名规则。 强烈建议使用英文命名！！！ 变量的命名规则变量名的命名，首先应该是这个变量要储存的内容的英文意思。借助你强大的英文水平，先把你想好的中文变量名翻译成英文，不会的话就借助翻译软件吧。 然后，如果你翻译出来的内容仅由1个英文单词构成，请直接以这个单词的完全小写的形式命名这个变量。如果是由多个单词组成的词组，应该使用小驼峰法的方式为这个变量命名。 记住，它应该是个名词或者名词性词组。 例如： salary,tax,carSum,taxRate; 特殊地，给布尔类型的变量命名，建议使用 is + 属性名的方法，依照具体的语境，也可以用can，have，should等前缀代替is，同样使用小驼峰法。同时要记得避免使用否定词。例如： isReal,isHigh;(√)isNotTall,isError;(×) 常量的命名规则常量一般是指使用const关键字修饰定义的数据，有时也只使用预处理宏#define定义的数据。 使用const关键字定义的常量它的命名规则和变量类似，但是要使用大驼峰法，即第一个单词的首字母也要大写。例如： Line,SavingAccount,Pi; 使用#define关键字宏定义的常量它的所有字母都应该采用大写，同时，若是由多个单词组成的变量名，为了区分每个单词，在每两个单词之间应该添加下划线。例如： PI,MAX_SIZE; 函数/方法的命名规则函数的名称应该是一个动词或者一个动词词组。如果函数名仅由单个单词构成，那么请以这个单词的完全小写形式命名这个函数。如果这个函数名是一个动词词组，请以小驼峰法的方式命名这个函数。例如： getArea,setPath,takeSteps; 名字空间的命名规则（C++）对于名字空间，请以一个英文单词完成对它的命名，而且，应该使用它的完全小写形式。例如： model,common; 结构、类（C++）的命名规则结构体和类的名称应该是一个名词或者名词性词组。若使用单个单词命名，请首字母大写；若使用词组，应使用大驼峰法命名。例如： Node,SomeClass; 但是，命名结构和类形成的实例（结构体和对象）时，应该依照一般的变量的命名法进行命名。 对于枚举类型（以enum关键词声明）同样建议使用名词或者名词性词组，以首字母大写或者大驼峰法命名。 而对于枚举类型的枚举常量，建议以全部大写字母+下划线分割单词的方式命名,同时应尽量使用共同的类型名作为前缀。 例如： enum Color &#123; COLOR_RED, COLOR_GREEN, COLOR_BLUE &#125;;enum ColorType &#123; COLOR_TYPE_WARM, COLOR_TYPE_COLD &#125;; 额外再提几个用于命名的关键字以及技巧，让代码更直观 get应该用在直接取得已设定值的函数中。 set应该用在直接为变量设定值的函数中。 compute应该用在用于进行计算的函数中。 find应该用在用于查找的函数中。 init/initialize应该使用在用于初始化的函数中。 在需要标识序号的变量名中，使用No + 序号比较合适。 布尔变量的命名应使用is，has等前缀，并且尽量避免否定词。 循环变量建议设置为i，j，k，并且建议优先使用i而把j，k用于循环嵌套。 对于缩略词我们有两种态度：1、对于那种缩写了人家可能就看不懂了的，比如cmd，init，请不要用缩写代替他们。2、对于那种缩写认识展开别人就看不懂的，比如HTML，CPU，老老实实写缩写。 另外，对于自己写的头文件的命名，推荐使用大驼峰命名法。例如 MyClass.hCppFunction.h OK,有关命名方法先写这么多。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"}],"tags":[{"name":"CamelCase","slug":"CamelCase","permalink":"https://legr4ndk.github.io/tags/CamelCase/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2020-10-15T14:30:10.810Z","updated":"2020-10-16T16:06:04.742Z","comments":true,"path":"2020/10/15/HelloWorld/","link":"","permalink":"https://legr4ndk.github.io/2020/10/15/HelloWorld/","excerpt":"","text":"Hello World 哈哈哈今天布置了一个github上的Hexo静态站点 准备下次写个教程（flag插好） 这次我整了两个分部，gitee和github上面我都有布置 不得不吐槽一下gitee page 是真的难用，每次更新居然要去手动刷新，时效性还特么巨低 github就是GFW的锅了，太慢了太慢了，移动甚至都不让你上去 害，这边主要搬运一些之前写在别处的文章 还有随时想写的感想，所以不能算是纯技术类博客吧 （所以这站点名字叫QQ空间哈哈哈哈） 等我更新！ 宰🕊祭天","categories":[],"tags":[]}],"categories":[{"name":"Essay","slug":"Essay","permalink":"https://legr4ndk.github.io/categories/Essay/"},{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"},{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/categories/C-C/"},{"name":"Git","slug":"Git","permalink":"https://legr4ndk.github.io/categories/Git/"}],"tags":[{"name":"fun","slug":"fun","permalink":"https://legr4ndk.github.io/tags/fun/"},{"name":"C#","slug":"C","permalink":"https://legr4ndk.github.io/tags/C/"},{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/tags/C-C/"},{"name":"git","slug":"git","permalink":"https://legr4ndk.github.io/tags/git/"},{"name":"随想","slug":"随想","permalink":"https://legr4ndk.github.io/tags/%E9%9A%8F%E6%83%B3/"},{"name":"CamelCase","slug":"CamelCase","permalink":"https://legr4ndk.github.io/tags/CamelCase/"}]}