{"meta":{"title":"Legrandk's Qzone","subtitle":"","description":"","author":"Legrandk","url":"https://blog.legr4ndk.top","root":"./"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-04T12:20:25.595Z","updated":"2020-12-04T12:20:25.595Z","comments":false,"path":"/404.html","permalink":"https://blog.legr4ndk.top/404.html","excerpt":"","text":"别看了，这边没东西的戳这儿👇回到我的主页"},{"title":"分类","date":"2020-11-27T04:48:32.194Z","updated":"2020-10-16T07:32:16.374Z","comments":false,"path":"categories/index.html","permalink":"https://blog.legr4ndk.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-21T04:50:58.132Z","updated":"2020-12-21T04:50:58.132Z","comments":false,"path":"about/index.html","permalink":"https://blog.legr4ndk.top/about/index.html","excerpt":"","text":"About Me夜露死苦！一只HDU的沙雕id源自曾服役120年的国际标准公斤实体Le Grand K网络空间安全专业出身，现为计算机科学与技术专业学生喜欢键政的马克思主义者（屁股没歪喜欢插flag（然后不拔D D L 人为人儒雅随和，见谁都能有的没的扯几句夜猫子，但是从来没有通宵过非著名中二病晚期患者 What am I doing now 学习C#与.Net Core 想学好C++的网络编程和Windows API 被老师抓去做新苗计划了，学习MindSpore与后端开发中 百 萬 前 端 大 製 作 日语 What I love 日语ACG类歌曲 Vocaloid歌曲 彩虹合唱团！ 异世界、末日题材番剧 无厘头动漫 英文pop/country music 部分小语种 日式角色扮演游戏（JRPG） 第一人称射击类游戏（FPS） 部分手游🤣（比如王者荣耀） 正在尝试无双类与开放世界类 How to find me新浪微博：Iegrandk（注意第一个是大写的i）QQ音乐：Legrandk网易云音乐：六氟锑酸钠_NaSbF6知乎：Legrandk邮箱：legrandk@aliyun.comGithub：legr4ndkGitee：LegrandkTweeter：legrandk"},{"title":"友情链接","date":"2020-11-23T07:26:37.741Z","updated":"2020-10-17T10:21:49.923Z","comments":false,"path":"links/index.html","permalink":"https://blog.legr4ndk.top/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-04T08:26:58.468Z","updated":"2020-10-16T07:32:16.376Z","comments":false,"path":"tags/index.html","permalink":"https://blog.legr4ndk.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我认识两个你（Lyrics付）","slug":"iKnowTwoPartsOfYou","date":"2020-12-20T14:56:11.000Z","updated":"2020-12-20T15:42:23.065Z","comments":true,"path":"2020/12/20/iKnowTwoPartsOfYou/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/20/iKnowTwoPartsOfYou/","excerpt":"","text":"来自上海彩虹室内合唱团 我认识两个你 一个五颜六色的你 一个电话里的你 五颜六色的你是活泼的 电话里的你 是平和的 每当十一点 传来铃声 点亮屏幕如同擦亮油灯 那温柔的 以晚安结尾的你 用声音出现了 我想象力有限 总是在夜晚忘记你眉眼 总之你是有一个形象的 如溪水般 流动的 橘色的光 快乐 悲伤 愉悦 落泪 哪怕不语时分 也能看到你灵魂模样 忙碌 远行 流浪 倒转 听筒那头 总有温柔以待 温柔以待 你认识两个我 一个自信满满的我 一个说不出话的我 自信满满的我在工作中 说不出话的我 在想念里 每当十一点传来铃声 点亮屏幕如同擦亮油灯 那温柔的 以晚安结尾的你 用声音出现了 我感受力有限 对周遭事物也缺乏热情 但只要你开启话题 思维马上开始活跃 期待 落寞 辗转 翻滚 有时铃声会晚 有时又会提前个几分 一份真诚 八百个夜 听筒那头 总有温柔以待 一份真诚 八百个夜 听筒那头 总有温柔以待 温柔以待 这首作品其实讲的是恋爱的故事，有没有人是透过电话去认识一个人，有没有人是远距离恋爱的我看一下，有没有？异地恋其实是听上去很辛苦，但实际上也有它的幸福存在。就是当两个人通过电话联系，通过视频联系，在夜晚的时候，你其实是可以听得到，对方的心情的。我们面对面交流的时候，很多时候说不出口的话，其实在晚上电话的时候会，不自知地就脱口而出，这种交流其实是很有意思的，你可以完全直接跟对方的灵魂沟通，这也是写下这首作品的原因。它是诞生于电话，它的作品的名字叫做，《我认识两个你》，我们每个人都有两个状态，平时上班的时候的状态。跟在电话里边，对最温柔的人用最温柔的方式，说最温柔的话的那个状态。把这首作品献给，每一位在场的温柔的人，谢谢你们。（From 词作者 金承志） 封面右下角的Moss Code是 I’m here for you. 愿你深夜有油灯擦亮愿你有橘色的光可以照耀愿你有一份可以托付八百日夜的真诚愿有一声晚安，可以结束你的一天 我认识两个你，也认识每一个你。","categories":[{"name":"Poet","slug":"Poet","permalink":"https://blog.legr4ndk.top/categories/Poet/"}],"tags":[{"name":"文艺","slug":"文艺","permalink":"https://blog.legr4ndk.top/tags/%E6%96%87%E8%89%BA/"}]},{"title":"NPUCTF HappyCheckInVerification WP","slug":"HappyCheckinNPUWP","date":"2020-12-17T15:39:52.000Z","updated":"2020-12-20T15:43:38.036Z","comments":true,"path":"2020/12/17/HappyCheckinNPUWP/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/17/HappyCheckinNPUWP/","excerpt":"","text":"本文搬运自我写在别处的文章 题目信息题目链接：https://pan.baidu.com/s/1c_Y0WJmzTdNVyYgjHmUI_Q 提取码: qhh8 Hint：关注西北工业大学信息安全协会微信公众号NWPUSEC 解题过程下载得到无后缀名的名叫zip的文件，把后缀名改成.zip，提示文件已损坏，故用16进制文件查看器检查文件（本文使用HxD）。 这是此文件的文件头，可见zip文件的文件头标记504B0304不在文件头部，反而是zip文件的目录结束标识（504B0506）在文件头。把从00000000-00000015的部分移动至文件尾，保存重新打开，就可以看到zip文件的文件了。此zip文件带有伪加密，可以通过搜索的方法搜索zip文件头标记504B0102，在其偏移5字节的地方改为00（要改两处）来去除伪加密。 保存解压即可获得一个mp4视频和一个二维码文件。 视频文件是喜闻乐见的黑人抬棺材的视频，但是在视频中有两个部分被植入了拨号音。截取这段音频降噪，使用dtmf2num工具识别拨号音，得到电话号码13418070885。 再来看二维码： 这是获取的二维码图像，可见二维码的三个定位符均被抹去，所以无法扫描。通过PS添加三个定位符，得到一个二维码。扫描得到以下文字： flag&#123;this_is_not_flag&#125;三曳所諳陀怯耶南夜缽得醯怯勝數不知喝盧瑟侄盡遠故隸怯薩不娑羯涅冥伊盧耶諳提度奢道盧冥以朋罰所即栗諳蒙集皤夷夜集諳利顛呐寫無怯依奢竟#￥#%E68BBFE4BD9BE68B89E6A0BCE79A84E5A7BFE58ABFE59CA8E69C80E5908E32333333||254333254242254338254342254231254338254345254432254238254643254236254145254239254441254437254234254232254131254236254245253244253244254343254438254330254341254336254435…sadwq#asdsadasf faf$use$dasdasdafafa_$ba##se64$ this is not flag 后面的第一部分哪些诡异的文字，是“与佛论禅”编码。最前面加上“佛曰：”，得到一句话：“都说了这不是佛拉格了”。 第二部分是一段十六进制数，把它转成字符串，得到：“拿佛拉格的姿势在最后”。 第三段也是一串十六进制数，把它转成字符串，得到：%C3%BB%C8%CB%B1%C8%CE%D2%B8%FC%B6%AE%B9%DA%D7%B4%B2%A1%B6%BE%2D%2D%CC%D8%C0%CA%C6%D5 肉眼可见它是url编码，直接转换，得到一串字符：“没人比我更懂冠状病毒–特朗普”。 最后一段没啥花头了，就是看到了use base64，是时候把刚刚从拨号音得到的电话号码用BASE64编码发到公众号，得到一段诡异的音频。 这是一段sstv的音频，里面有个图，直接使用软件MMSSTV，播放这段音频给电脑听（推荐电脑内录），你就可以看到孙狗的笑容（天皇遗照）。flag就写在孙🐕的胸上。 结束","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.legr4ndk.top/tags/CTF/"}]},{"title":"实现网页登陆的逻辑","slug":"BackEndLoginCourse","date":"2020-12-17T14:46:26.000Z","updated":"2020-12-20T15:08:02.909Z","comments":true,"path":"2020/12/17/BackEndLoginCourse/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/17/BackEndLoginCourse/","excerpt":"","text":"实现登陆逻辑至少涉及两个方面，登陆与注册 本文使用SQL语言的MySQL dialect 登陆（Log in）登陆主要是实现将用户提交的含有用户名uname和密码passwd的表单提交给数据库对比，如果发现此条记录在数据库中存在且合法，则返回登陆成功，否则返回登陆失败，需要请求用户重新提交。 这边主要注意的是一个点，在查询的时候我们会使用SQL语句去数据库查询，一般想到的逻辑应该是去查询得到用户名对应的密码，然后再去对比用户提交的密码与数据库返回的密码是否一致。即使用了以下的SQL代码： SELECT passwd FROM user_info WHERE uname &#x3D; $UNAME; 在登陆成功情况下两者并无任何区别，但实际上这个方式有一个巨大的缺陷：在登陆失败时，这种数据处理方式割裂了“用户名输入错误”（此用户名不存在）与“查到用户名，但密码错误”两种情况。如果这两种不同的情况被以不同形式返回到前端（比如分别提示“用户名错误”或“密码错误”，那么就很容易被通过“撞库攻击”而“撞”出网站的许多用户的用户名，即使他们并不知道每个id的密码，这无疑方便了攻击者通过id暴力穷举或者使用密码字典的方式获取密码。 正确的处理方法应该是连着用户名和密码一起放入SQL语句里去查询，比如： SELECT * FROM user_info WHERE uname &#x3D; $UNAME AND passwd &#x3D; $PASSWD; 然后通过执行了该语句之后是否具有返回数据的方式来判断用户试图登陆的账号密码对是否被注册且有效。如果成功，则结果同上，但是若登陆失败，那么它只能体现用户名和密码错误，安全性相对更高。 注册（Register）注册的验证涉及三个步骤： 验证提交的密码的合法性 验证提交的username的唯一性 插入提交的用户名与密码到数据库。 提交密码的合法性判断无非是判断密码长度、判断是否含有不合法字符、判断密码格式是否合规。使用各种语言的字符串处理手段乃至正则表达式都可以直接实现，此处不再赘述。提供一个常见的网站密码格式要求：以字母开头，必须包含大/小写字母、数字、一般符号的至少三种，长度在8-64位之间。 提交的用户名的唯一性判断可以通过SQL语言的SELECT语句，即查询语句来实现，比如： SELECT * FROM user_info WHERE uname &#x3D; $UNAME; 然后通过执行该语句后是否有查询到的数据来判断这个用户名是否被注册过，以决定是否要为此组提交的数据执行注册（即插入数据表）的操作。 值得一提的是，你可与为某一列设置UNIQUE来保证这列的数据一定不相同，此情况下，若插入重复的username将会导致MySQL抛出异常，需要对这一异常进行处理。 插入提交的数据到数据库在我们确认用户提交的数据在数据库中不会出现问题之后，我们便可以把用户提交的键值对插入数据表中了。插入操作使用INSERT来实现，例如： INSERT INTO user_info (uname, passwd) VALUES ($UNAME, $PASSWD); 此方法会把$UNAME与$PASSWD以一条新记录的方式插入到对于数据表中。一般在这种情况下，它便不再会出现插入异常了。","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://blog.legr4ndk.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"在JSP上连接MySQL数据库","slug":"JSPconnectMySQL","date":"2020-12-16T12:53:36.000Z","updated":"2020-12-16T13:27:03.384Z","comments":true,"path":"2020/12/16/JSPconnectMySQL/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/16/JSPconnectMySQL/","excerpt":"","text":"驱动准备你需要下载Java Database Connector for MySQL，本文提供一个来自于菜鸟教程的jar包，版本号为5.1.39。点击此处下载。将此文件放入tomcat目录的lib文件夹中。 配置Tomcat的连接池不配置连接池，在使用驱动包的时候tomcat会返回500 Internal Server Error，提示ClassNotFoundException（异常：找不到类），可以通过配置它的连接池来解决问题。 修改server.xml修改位于tomcat目录下的conf/server.xml,找到&lt;GlobalNamingResources&gt;标签，在此标签内我们需要添加内容。 &lt;!--这个标签是已经存在的，找到它然后编辑即可--&gt;&lt;GlobalNamingResources&gt; &lt;!--这部分为文件自带内容，不作改动--&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot; /&gt; &lt;!--配置mysql数据库的连接池, 需要做的额外步骤是将mysql的Java驱动类放到tomcat的lib目录下--&gt; &lt;Resource name=&quot;jdbc/mysqlds&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; username=&quot;$UNAME&quot; password=&quot;$PWD&quot; maxIdle=&quot;30&quot; maxWait=&quot;10000&quot; maxActive=&quot;100&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/$DBNAME&quot; /&gt; &lt;/GlobalNamingResources&gt; 其中 $DBNAME位置放你的数据库名，$UNAME位置放置你的数据库用户名，$PWD位置放置你的数据库密码 修改context.xml修改位于tomcat目录下的conf/context.xml，在&lt;Context&gt;标签内我们需要添加内容。 &lt;Context&gt; &lt;!--这部分为文件自带内容，不作改动--&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt; &lt;!--以下为在本文件中的添加内容--&gt; &lt;ResourceLink name=&quot;jdbc/mysqlds&quot; global=&quot;jdbc/mysqlds&quot; type=&quot;javax.sql.DataSource&quot;/&gt; &lt;/Context&gt; 修改web.xml修改位于tomcat目录下的网页项目文件夹下的WEB-INF/web.xml文件，在 &lt;web-app&gt;内我们需要添加内容。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--以下为在本文件中的添加内容--&gt; &lt;resource-ref&gt; &lt;description&gt;mysql数据库连接池&lt;/description&gt; &lt;res-ref-name&gt;jdbc/mysqlds&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;res-sharing-scope&gt;Shareable&lt;/res-sharing-scope&gt; &lt;/resource-ref&gt; &lt;/web-app&gt; 配置之后，需重启tomcat。之后连接数据库的时候就不会出现ClassNotFoundException了。 JSP连接数据库给出一段DEMO： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page import=&quot;java.sql.*&quot;%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;通过JSP打开数据表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //驱动程序名 String url = &quot;jdbc:mysql://localhost:3306/$DBNAME&quot;; //数据库名 String username = &quot;$UNAME&quot;; //数据库用户名 String password = &quot;$PWD&quot;; //数据库用户密码 Connection conn = DriverManager.getConnection(url, username, password); //连接数据库并返回连接状态 if(conn != null)&#123; out.print(&quot;数据库连接成功！&quot;); out.print(&quot;&lt;br /&gt;&quot;); Statement stmt = null; ResultSet rs = null; String sql = &quot;SELECT * FROM $TABLENAME;&quot;; //查询语句 stmt = conn.createStatement(); rs = stmt.executeQuery(sql); out.print(&quot;查询结果：&quot;); out.print(&quot;&lt;br /&gt;&quot;); out.println(&quot;id&quot;+&quot; &quot;+&quot;uname&quot;+&quot; &quot;+&quot;pwd&quot;); out.print(&quot;&lt;br /&gt;&quot;); while (rs.next()) &#123; out.println(rs.getString(&quot;id&quot;)+&quot; &quot;+rs.getString(&quot;uname&quot;)+&quot; &quot;+rs.getString(&quot;passwd&quot;)+&quot;&lt;br /&gt;&quot;); //将查询结输出 &#125; &#125; else&#123; out.print(&quot;连接失败！&quot;); &#125; %&gt; &lt;/body&gt;&lt;/html&gt; 其中 $DBNAME位置放你的数据库名，$UNAME位置放置你的数据库用户名，$PWD位置放置你的数据库密码，$TABLENAME位置放置你操作的数据表表名。 ResultSet.getString()函数接受字段名作为参数返回对应一条记录的该字段的值，可以以此读取信息。 上方Demo实现了读取一个数据表中id、uname、pwd字段的所有数据的JSP代码。 通过更改SQL语句可以实现更多的操作，此处不再赘述。","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://blog.legr4ndk.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"于Ubuntu 18.04上配置Java Server Pages运行环境","slug":"JSPenvironment","date":"2020-12-11T10:16:45.000Z","updated":"2020-12-11T10:18:50.207Z","comments":true,"path":"2020/12/11/JSPenvironment/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/11/JSPenvironment/","excerpt":"","text":"更新系统sudo apt update #更新软件源sudo apt upgrade #更新软件包 Web服务器应用Apachesudo apt install apache2 -y #安装apache2sudo /etc/init.d/apache2 start #启动apache2sudo /etc/init.d/apache2 stop #关闭apache2 Java运行时与JDKsudo apt install openjdk-11-jdk-headless #安装openjdk-11 Java应用服务器Tomcatsudo apt install git #安装git（作为wget的依赖）sudo apt install wget #有的系统自带wget，就不用装wget https://mirrors.cnnic.cn/apache/tomcat/tomcat-9/v9.0.40/bin/apache-tomcat-9.0.40.tar.gz #于cnnic镜像站下载tomcat的预编译二进制文件tar -xzvf apache-tomcat-9.0.40.tar.gz #解压压缩文件sudo mv ./apache-tomcat-9.0.40 /usr/local/tomcat #移动所有文件到/usr/local目录下的tomcat文件夹中sudo chmod -R 755 /usr/local/tomcat #赋予权限cd /usr/local/tomcat/bin #进入存放tomcat的文件夹vim ./startup.sh #编辑startup.sh脚本# 最后一行加上：#tomcatexport TOMCAT_HOME=/usr/local/tomcat# 保存退出sudo /usr/local/tomcat/bin/startup.sh #启动tomcatsudo /usr/local/tomcat/bin/shutdown.sh #关闭tomcat 数据库MySQLsudo apt-get install mysql-server #安装mysql-serversudo mysql -uroot -p #root用户登陆mysql-clinet，默认无密码#执行以下操作以自订密码use mysql;update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where user=&#x27;root&#x27;;update user set plugin=&quot;mysql_native_password&quot;;flush privileges;quit;#退出mysqlsudo /etc/init.d/ mysql start #启动mysqlsudo /etc/init.d/ mysql stop #关闭mysqlsudo /etc/init.d/ mysql restart #重启mysql#要创建新的mysql用户CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;#username：用户名，host：指定该用户在哪个主机上可以登陆，本地用户用localhost，从任意远程主机登陆，可以使用通配符%，password：用户密码 启动Apache和Tomcat之后可以在80端口看到apache的it works界面，8080端口可以看到位于 /usr/local/tomcat/webapps/ROOT/ 的网页，可以自己放jsp文件于次文件夹，以对于域名的相对地址访问。","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://blog.legr4ndk.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"在网页文件中引入Bootstrap","slug":"IncludeBootstrap","date":"2020-12-09T15:27:58.000Z","updated":"2020-12-21T04:57:22.777Z","comments":true,"path":"2020/12/09/IncludeBootstrap/","link":"","permalink":"https://blog.legr4ndk.top/2020/12/09/IncludeBootstrap/","excerpt":"","text":"文件均使用了在Staticfile CDN上的镜像 在文件中引入Bootstrap3的库以下内容请放入html文件的&lt;head&gt;与&lt;/head&gt;之间： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- 引入 Bootstrap --&gt;&lt;link href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 以下内容请放入html文件的&lt;body&gt;与&lt;/body&gt;之间： &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 包括所有已编译的插件 --&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; Bootstrap4版的库文件链接：以下内容请放入html文件的&lt;head&gt;与&lt;/head&gt;之间： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css&quot;&gt;&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 以下内容请放入html文件的&lt;body&gt;与&lt;/body&gt;之间： &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js --&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.legr4ndk.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"注 入 怨 念","slug":"EssayP","date":"2020-11-27T15:23:06.000Z","updated":"2020-12-04T12:12:36.849Z","comments":true,"path":"2020/11/27/EssayP/","link":"","permalink":"https://blog.legr4ndk.top/2020/11/27/EssayP/","excerpt":"","text":"最近看到一首很有感觉的诗，且放在这边： 我把子弹穿破胸膛我的眼睛被鲸鲨咬碎口腔被灌满砒霜溃疡双手砍断滚在床下少女把头颅盛走你就静静看着我把我泡在福尔马林永垂不朽 活在福尔马林里，也未尝不是永垂不朽。","categories":[{"name":"Poet","slug":"Poet","permalink":"https://blog.legr4ndk.top/categories/Poet/"}],"tags":[{"name":"文艺","slug":"文艺","permalink":"https://blog.legr4ndk.top/tags/%E6%96%87%E8%89%BA/"}]},{"title":"马保国日语版","slug":"masensei","date":"2020-11-24T13:36:30.000Z","updated":"2020-12-05T04:08:40.957Z","comments":true,"path":"2020/11/24/masensei/","link":"","permalink":"https://blog.legr4ndk.top/2020/11/24/masensei/","excerpt":"","text":"原视频见于Bilibili 此处只是靠听力和字幕扒取了台词 止增笑耳 こんにちは 俺(おれ)は太極(たいきょく)マスター 马(mǎ) 保(bǎo) 国(guó) 今(いま) 友達(ともだち)が「先生(せんせい)どうしたの」と 俺(おれ)は「何(なに)が」と 写真(しゃしん)が何枚来(なんまいき)た 俺見(おれみ)たと お！ それは昨日(きのう) 二人(ふたり)の若(わか)もん ３０ぐらい 一人体重(ひとりたいじゅう)９０キロ 一人体重(ひとりたいじゅう)８０キロ 彼(かれ)ら 一人(ひとり) 「俺(おれ)、ジム(じむ)で運動(うんどう)、首(くび)がひねった、馬先生(うませんせい)、太極(たいきょく)を気功(きこう)を、教(おし)えてくれない？」 俺(おれ)は「いい」と おれは「君(きみ)の筋(きん)トレ效(き)かない」 彼(かれ)は不満(ふまん) 俺(おれ)は「子供(こども)よ、両手(りょうて)で俺(おれ)の指(ゆび)を折(お)ってみ」 折(お)れない 彼(かれ)は「役立(やくだ)てない」と 俺(おれ)は「役立(やくだ)てる」と これ「化力(かりょく)」 カンフー技(わざ) 四両(よんりょう)で千斤(せんきん)を制(せい)する ２００斤(きん)の英国力士(えいこくりきし) 俺(おれ)の指(ゆび)に勝(か)てない あ！ 彼(かれ)はやってみみと 俺(おれ)はオッケーと そして彼(かれ)ガーと立(た)て 速(はや)いあ！ そして続(つづ)いて 先ず左蹴(ひだりしゅう) 「ん」 次右(つぎみぎ)サイド 最後左(さいごひだり)ジャブ 俺全部(おれぜんぶ)ガードした ガードした！ ガードしてもちろん伝統(でんとう)カンフーは切磋(せっさ)だけ 右手鼻(みぎてはな)につけて 打(う)たない 俺笑(おれわら)って 手(て)を引(ひ)こうと だからここで 伝統(でんとう)カンフーの切磋琢磨(せっさたくま)で 彼(かれ)はすでに負(ま)けた もし力(ちから)いれたら ワンパンチで彼(かれ)の鼻(はな)を折(お)った 鼻(はな)につけて打(う)たない かれ認(みと)め 俺(おれ)は彼(かれ)の顔(かお)に行(い)った 彼(かれ)は鼻(はな)がつけられたのを知(し)らずに 俺(おれ)は顔(かお)に行ったと認(みと)めた 俺(おれ)は手(て)を引(ひ)いてやめた 彼(かれ)は不意打(ふいう)ち 左(ひだり)ジャブ俺(おれ)の顔(かお)を 俺油断(おれゆだん)したら、「迷(まよ)うさ」（没有闪） 彼(かれ)の左(ひだり)パンチ俺(おれ)の目(め)… 右目(みぎめ)に擦(す)った でも大丈夫(だいじょうぶ) 彼(かれ)も写真(しゃしん)で言(い)った 二分(にふん)ほど以降(いこう) その場(ば)で涙出(なみだで)た 目(め)を覆(おお)って 俺(おれ)は「止(や)めて」と 二(に)分(ふん)以(い)ほ…二(に)分(ふん)以(い)降(こう) 治(なお)った 俺(おれ)はガキお前(まえ) ジャブじゃ無駄(むだ) しぶとう 彼(かれ)は「馬先生(ませんせい)御免御免(ごめんごめん)、俺(おれ)は素人(しろうと)」 「俺(おれ)は無鉄砲(むてっぽう)」と 彼(かれ)は無鉄砲(むてっぽう)じゃないんだ 前(まえ)キック、サイドキック 左(ひだり)パンチ、練(ね)れ者(もの) あとで彼(かれ)は三(さん)四(よん)年(ねん) タイ拳(こぶし)お習(なら)った やはり 準備万端(じゅんびばんたん)（有bear来） これら 若造(わかぞう) 無駄無駄(むだむだ)（不讲武德） だ～ます 不(ふ)意(い)～打(う)ち 六(ろく)十(じゅう)九(きゅう)歳(さい)の老(ろう)人(じん) いいのか？よくない 小(こ)僧(ぞう) よくお前(まえ)は 恥(は)ず忘(わす)（耗子尾汁）れてます 今後(こんご) このようなずる 小賢(こざか)しい 武林(ぶりん)は和(わ)を大事(だいじ) ようじゃ無駄(むだ)（要讲武德） 八百(はっぴゃく)るな～俺(おれ)と（不要搞窝里斗） ありがとうね！ 已经更新完了，还加了汉字的假名注音hh 可以拿去照着这个台本配音玩了 有部分是字幕里有但是那人没念出来的，我就给删了 不是标准日语，很多语法错误，但是读着好玩就是了😂","categories":[{"name":"Fun","slug":"Fun","permalink":"https://blog.legr4ndk.top/categories/Fun/"}],"tags":[{"name":"文艺","slug":"文艺","permalink":"https://blog.legr4ndk.top/tags/%E6%96%87%E8%89%BA/"}]},{"title":"C#常见控件","slug":"CsharpCommonControls","date":"2020-11-22T10:48:47.000Z","updated":"2020-12-05T12:48:07.827Z","comments":true,"path":"2020/11/22/CsharpCommonControls/","link":"","permalink":"https://blog.legr4ndk.top/2020/11/22/CsharpCommonControls/","excerpt":"","text":"C#的WinForm编程真的是和Visual Basic一毛一样的体验 ——比隔壁C++的WinForm不知道高到哪里去了（ 控件（Control）是WinForm的基本元素 Brief IntroductionForm控件有一个系统自动生成的一个类实例化的对象（默认叫Form1），该类自带Load事件的函数。此类定义于Form1.cs和Form1.Design.cs中。于Program.cs中另有Program.cs内定义了Main函数作为程序的起点。 常见的控件有几个基本共有的属性，如： Size：是一组共两个值，用于确定对象的宽度和高度 (Name)：相当于该对象在程序中的变量名 AutoSize：如果为True则可能造成控件某些维度的手动大小调整不可用 Location：是一组两个值，用于确定对象在窗体的位置(x,y)，窗体左上顶点为坐标原点，向右为+x，向下为+y Label（标签）控件为控件和窗体的其它组成部分提供标识，通常用于提供描述性文字 Label控件由Label类描述，Label类继承自Control类，它在名字空间System.Windows.Forms中。 Label常用属性 AutoElipsis：获取或者设定一个值，指示是否要在Label右边缘显示省略号表示文本超过指定长度，否则文本将被直接截断 AutoSize：获取或者设定一个值，指示是否自动调整控件大小以显示完整内容 BorderStyle：获取或设置控件的边框样式 Image：获取或设置显示在Label上的图像 Text：获取或设置与此控件相关联的文本，即显示在Label上的文本 TextAlign：获取或设置Label中文本的对齐方式 TextBox（文本框）控件TextBox中的文本可以被编辑，而Label中的不行。 TextBox类所在的名字空间为System.Windows.Forms。 TextBox常用属性 AcceptsReturn：获取或设置一个值，该值指示在多行TextBox控件中按Enter键时，是在控件中创建一行新文本还是激活窗体的默认按钮，比如用于选择按回车是输入完了还是换一行 AcceptsTab：获取或设置一个值，该值指示在多行TextBox控件中按Tab键时，是在控件中键入一个Tab字符还是按选项卡的顺序将焦点移动到下一个控件 BackColor：获取或设置控件的背景色 Focused：获取一个值，该值指示控件是否有输入焦点 Font：获取或设置控件显示的文字的字体 Multiline：获取或设置一个值，该值指示此控件是否为多行TextBox控件 PasswordChar：获取或设置字符，该字符用于屏蔽单行TextBox控件中的密码字符 ReadOnly：获取或设置一个值，该值指示文本框中的文本是否为只读 RightToLeft：获取或设置一个值，该值指示是否将控件的元素对齐以支持从右向左的字体的区域设置 SelectedText：获取或设置一个值，该值指示控件中当前选定的文本 Text：字符串，获取或设置TextBox中的当前文本 TextAlign：获取或设置控件中文本的对齐方式 TextLength：获取或设置控件中文本的长度 WordWrap：指示多行文本框控件在必要时是否自动换行到下一行开始 TextBox常用事件 Click：鼠标单击控件时发生 Enter：鼠标进入控件区域时发生 GotFocus：在控件得到焦点时发生 KeyDown：在控件有焦点时按下按键时发生 KeyUp：在控件有焦点时释放按键时发生 Leave：在控件失去焦点时发生 LostFocus：在控件失去焦点时发生 TextChanged：在控件的Text属性值更改时发生（文本被改变 Button（按钮）控件用户可以单击按钮控件触发程序动作。 Button继承自ButtonBase类，ButtonBase继承自ContentControl类，ContentControl类继承自Control类。 Button常用属性 ClickMode：获取或设置Click事件何时发生，ClickMode有3种 悬停，鼠标悬停在该按钮上时激发此按钮 按下，鼠标在该按钮上按下时激发此按钮 释放，鼠标在该按钮上按下后，释放时激发此按钮 IsCancel：获取或设置一个值，指示该Button控件是否为取消按钮。用户可以通过ESC键激活取消按钮 IsDefault：获取或设置一个值，指示该Button控件是否为默认按钮。用户可以通过Enter键调用默认按钮 Button常用事件 Click：按钮被按下时发生（最常用） 选项控件选项的作用是跟据用户的实际情况在程序运行时调整程序的状态或行为。 选项控件的分类 GroupBox（组框） Panel（面板） RadioButton（单选按钮） CheckBox（复选框） RadioButtonRadioButton（单选按钮）控件是用来让用户在一组选项中选定一项且只能选定一项。 若窗体内仅有一组RadioButton控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，RadioButton应该被放置到一个GroupBox（组框）控件内进行分组。 RadioButton常用属性 Text：设定该RadioButton旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定RadioButton的状态（bool类型，True-被选中，False-未被选中（缺省设置）） RadioButton常用事件 CheckedChanged：Checked属性改变时发生（默认事件） 在VS中，双击单选按钮控件，会自动添加默认事件的事件处理函数 CheckBoxChechBox（复选框）控件是让用户在一组选项中选定一项或多项。 若窗体内仅有一组CheckBox控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，CheckBox应该被放置到一个GroupBox（组框）控件内进行分组。 CheckBox常用属性 Text：设定该CheckBox旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定CheckBox的状态（bool类型，True-被选中，False-未被选中（缺省设置）） CheckState：指示CheckBox目前的状态，有三个取值 Checked：表示被选中状态 Unchecked，表示未被选中状态 Indeterminate，表示不可用状态（此状态当ThreeState属性为True时有效） CheckBox常用事件 CheckedChanged：Checked属性改变时发生（默认事件） CheckedStateChanged：CheckedState属性改变时发生 GroupBoxGroupBox（组框）是一个容器类控件。 你可以将一组控件放入GroupBox来分类。 组框可以显示标题（文本），但是它没有滚动条。 边框一般比较细。 GroupBox常用属性 Controls：组框包含的控件集 Text：在组框顶部显示的标题文本 PanelPanel（面板）与GroupBox类似，也是一个容器类控件。 你也可以将一组控件放入Panel来分类。 面板可以包含滚动条，但是它没有标题。 边框可以通过相关边框属性来调节。 Panel常用属性 AutoScroll：当面板由于太小而无法显示所有控件时，这个属性指定是否出现滚动条，默认值为False BorderStyle：设置面板的边界样式，默认为None，其他选项有Fixed3D和FixedSingle Controls：面板包含的控件集 感觉差不多了，就这样吧！","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"做个好码农","slug":"做个好码农","permalink":"https://blog.legr4ndk.top/tags/%E5%81%9A%E4%B8%AA%E5%A5%BD%E7%A0%81%E5%86%9C/"}]},{"title":"Cpp中的多态","slug":"CppPolymorphism","date":"2020-10-23T12:02:51.000Z","updated":"2020-12-04T12:13:14.448Z","comments":true,"path":"2020/10/23/CppPolymorphism/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/23/CppPolymorphism/","excerpt":"","text":"多态是面向对象编程内极为重要的一种特征，它能极大的简化我们的代码 先来看一段类的原型 class Animal //基类&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Voiceless&quot; &lt;&lt; std::endl; //不知道该叫啥 &#125;;&#125;;class Dog : public Animal //狗派生类，继承了Animal&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; //汪汪叫 &#125;&#125;;class Cat : public Animal //猫派生类，继承了Animal&#123;public: void voice() &#123; std::cout &lt;&lt; &quot;Meow&quot; &lt;&lt; std::endl; //喵喵叫 &#125;&#125;; 我们可以看到，基类和派生类中都有函数voice()，它可以让不同的动物发出不同的叫声，其中，Dog类和Cat类的voice()函数是覆写了基类中的同名函数。 当然，还可以有很多基于Animal类的派生类，都可以有叫声，但是我们如果想统一一下让它们叫的方法，比如用个train函数，传入对象或者它的指针就可以自动调用它的voice函数。虽然Cpp支持重载函数，但是为每个不同的类各写一个这样的函数，工作量不仅大，而且枯燥。多态就是帮我们解决这个问题的。 多态 Polymorphism 表现方式有两种 重载多态，比如函数重载（本文不介绍了），属于静态联编 子类型多态，属于动态联编，就是我接下来要说的那些 子类型多态有两个要点： 虚函数 函数覆写override 我们来区分涉及继承链情况下的两种联编： 通过派生类对象访问同名函数，是静态联编 通过基类对象的指针访问同名函数，是静态联编 通过基类对象的指针或引用访问同名虚函数，是动态联编 那我们现在改一下原来的类的定义让它符合子类型多态的要求 class Animal&#123;public: virtual void voice() //此函数声明为虚函数后，派生类中无须再注明 &#123; std::cout &lt;&lt; &quot;Voiceless&quot; &lt;&lt; std::endl; &#125;;&#125;;class Dog : public Animal&#123;public: void voice() override //覆写了voice函数 &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; &#125;&#125;;class Cat : public Animal&#123;public: void voice() override //覆写了voice函数 &#123; std::cout &lt;&lt; &quot;Meow&quot; &lt;&lt; std::endl; &#125;&#125;; 那么还是刚刚那个例子，我们设计一个train函数 void train(Animal animal)&#123; animal.voice();&#125; 使用这个函数，你会发现无论你往参数里塞了什么阿猫阿狗的对象，输出的永远是“Voiceless”，这便是静态联编的问题了，它使用的是基类的对象而非基类对象的指针或引用，你需要把train修改成这样： void train(Animal&amp; animal)&#123; animal.voice();&#125;//或者这样void train(Animal* animal)&#123; animal-&gt;voice();&#125; 然后你的子类对象在调用这个train函数之后就可以正常发出正确的声音了 需要注意的是，如果voice函数不是虚函数，那么即使你用了派生类对象的指针、引用，只要那个进入函数的东西的类型是基类，它就会调用基类的函数 一句话总结一下，就是：函数虚，看对象；函数实，看类型。 但是，这个东西它也有问题，就是你使用基类的指针（或者引用）指向了派生类的对象的时候，你只能调用派生类的虚函数，无法调用非虚函数，例如我改一下Dog类的定义： class Dog : public Animal&#123;public: void voice() override &#123; std::cout &lt;&lt; &quot;Woof&quot; &lt;&lt; std::endl; &#125; void foo() //这个不是虚函数了 &#123; std::cout &lt;&lt; &quot;Foo!&quot; &lt;&lt; std::endl; &#125;&#125;; 但是我在main函数里这样定义： Animal ptr;Dog dog = new Dog();ptr = &amp;dog;ptr-&gt;voice(); //调用的是dog对象的voice函数ptr-&gt;foo(); //无法调用，No member named foo in Animal Animal类的指针虽然指向了dog，但是它将无法调用dog的非虚函数，但是如果我们偏要调用属于子类的非虚函数呢？ Introducing dynamic_cast! Cpp的dynamic_cast&lt;&gt;运算符可以把基类类型的指针转换为派生类的类型的指针，就可以使调用子类的非虚函数称为可能，方法如下 ptr-&gt;foo(); //它出了问题dynamic_cast&lt;Dog*&gt;(ptr)-&gt;foo(); //正常调用！ 虽然建议在任何基类与派生类间的指针、引用的类型转换都使用dynamic_cast运算符，但是实际上，派生类的指针（引用）转为基类类型的指针（引用）可以不使用该运算符而隐式转换，而基类的指针（引用）转为派生类类型的指针（引用）必须显式使用该运算符以完成类型转换。 比如我们有： Animal animal;Animal* pa;Cat cat;Cat* pc;pa = &amp;cat; //可以隐式转换（下转上）pc = dynamic_cast&lt;Cat*&gt;(animal); //必须显式转换（上转下） 多态就先写这么多~","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"做个好码农","slug":"做个好码农","permalink":"https://blog.legr4ndk.top/tags/%E5%81%9A%E4%B8%AA%E5%A5%BD%E7%A0%81%E5%86%9C/"}]},{"title":"Markdown语法教程","slug":"MarkdownCourse","date":"2020-10-18T14:11:22.000Z","updated":"2020-12-04T12:11:54.233Z","comments":true,"path":"2020/10/18/MarkdownCourse/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/18/MarkdownCourse/","excerpt":"","text":"这篇文章简单介绍下Markdown的基础语法，对写文章，记笔记有用 注意，Markdown排版支持大量html标签 # 大小标题（使用标题可以生成大纲） 使用=和-标记一号和二号标题 我是大标题我是小标题我是大标题=========在第二行书写多个=，为一级标题我是小标题---------------在第二行书写多个-，为二级标题 使用#标记1-6级标题 我是H1我是H2我是H3我是H4我是H5我是H6# 我是H1## 我是H2### 我是H3#### 我是H4##### 我是H5###### 我是H6是几级标题就打几个#，再跟上一个空格 特殊格式我是斜体 我是粗体 我是斜粗体 *我是斜体***我是粗体*****我是斜粗体***注意，星号可以用下划线替代 分割线，就像这样 ***___---你需要使用连续三个及以上的星号、减号或者下划线来创建分割线，每个符号间可以有空格 下划线和删除线 我是下划线 我是删除线 &lt;u&gt;我是下划线&lt;/u&gt;~~我是删除线~~下划线使用html的u标签实现，删除线在前后加上两个~即可 列表 第一项 第二项 第三项 第一项 第二项 * 第一项* 第二项* 第三项无序列表使用星号（或者加号、减号）跟一个空格1. 第一项2. 第二项有序列表使用数字加一个小数点以跟一个空格 区块 这是区块 &gt; 这是区块大于号加一个空格 代码块 这是代码块​```[language]#Codes here​```前后三个点包围的区块，第一块三个点后面可以跟上语言的名称 超链接 这是指向我的博客的超链接 [这是指向我的博客的超链接](https://legr4ndk.github.io/)方括号里是显示的字，小括号里是要跳转的链接当然你也可以使用html的&lt;a&gt;标签 图片 ![龙龙快动啊](http://blog.legr4ndk.top/ImgHost/loooong.jpg)一个感叹号直接接中括号，里面是注释文本，后面跟的小括号里面是图片路径当然你也可以使用html的&lt;img&gt;标签 表格 表头 表头 表头 表头 单元格 左对齐 右对齐 居中对齐 | 表头 | 表头 | 表头 | 表头 || ---- | :---- | ----: | :----: || 单元格 | 左对齐 | 右对齐 | 居中对齐 |使用|来分割单元格，使用-来分割表头和其他行，使用:来确定当列的对齐方式使用html的&lt;table&gt;标签也可以做到 够你喝一壶了！","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"Developer的自我修养","slug":"Developer的自我修养","permalink":"https://blog.legr4ndk.top/tags/Developer%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}]},{"title":"用Hexo配合GitHub快速上线自己的个人博客","slug":"HexoCourse","date":"2020-10-18T09:05:41.000Z","updated":"2020-12-04T12:11:04.900Z","comments":true,"path":"2020/10/18/HexoCourse/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/18/HexoCourse/","excerpt":"","text":"不想买服务器却又想创造属于自己的网站？Hexo可以帮你。 啥是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程可以让你快速上线属于你自己的博客。 事前准备你需要安装两个东西：Git和Node.js Git的安装教程在这儿。 Node.js可以直接在这儿下载，不要忘记把它加到环境变量中去。 安装完之后可以在命令行中输入 ➜ git --version #输入这个，下面是显示的内容git version 2.28.0.windows.1 ➜ npm --version #输入这个，下面是显示的内容6.14.8 如果均有回显版本号（可能你的版本和我的不一样），那么就说明安装成功了。 接下来因为要用到npm这个包管理器，所以先给npm的镜像站点换成国内的淘宝源，命令如下： ➜ npm config set registry https://registry.npm.taobao.org 然后准备工作就全部完成了。 安装Hexo需要以下几个命名，按顺序执行就行了： ➜ npm install hexo -g #安装hexo➜ npm install hexo-deployer-git --save #安装hexo的一个插件包，用于Git部署 安装完之后，你需要建立一个文件夹专门用来存放你的博客的文件，然后打开那个文件夹，在该文件夹里打开命令行窗口（Windows用户可以选择通过按住Shift并在文件夹窗口空白地区右键来打开PowerShell），现在需要初始化你的网站，命令行输入： ➜ hexo init #初始化hexo站点，init=initialize 此命令会从远程仓库克隆基础的Hexo站点模板，视你的网络条件（你懂）此过程可能持续数分钟，然后你的文件夹里会多很多文件，主文件夹结构大致如下： ├─node_modules #太大了不展开了├─scaffolds├─source #要展示在网页上的资源文件│ └─_posts #存放博客内的博文和媒体文件，博文以markdown存储└─themes #存放主题文件，自带一个landscape主题，此处以它为例，如果要用其他主题也请放入这边 └─landscape #主题存放文件夹，此处有主题的配置文件_config.yml ├─languages ├─layout │ ├─_partial │ │ └─post │ └─_widget ├─scripts └─source ├─css │ ├─fonts │ ├─images │ ├─_partial │ └─_util ├─fancybox │ └─helpers └─js 然后，你可以在命令行执行以下语句来清理已有网站内容 ➜ hexo clean 正式使用Hexo先介绍几个Hexo使用的基本命令： ➜ hexo generate #或者 hexo g，用来跟据你写好的md博文生成新的网页文件并链接➜ hexo server #或者hexo s,用于在本地的4000端口（127.0.0.1:4000）实时预览你的网页➜ hexo new &#x27;xxx&#x27; #新建博文，会在主文件夹/source/_posts文件夹下创建xxx.md与同名媒体文件夹 编辑博文请在md文件内，博文的资源文件（如图片）请放到同名文件夹中并在md文件中使用相对地址链接来完成（比如./xxx/233.jpg)。 ——————那么做到这步我就假定你已经在刚刚生成的.md文件中写完文章了—————— 部署Hexo博客到GitHub毫无疑问你得先注册个GitHub，如果还没有的话，点这里去注册。 然后新建一个仓库，注意这个仓库必须是开源的，而且名字有一定要求：必须是 用户名.github.io 例如我的GitHub的id是legr4ndk，那么我的仓库名就是legr4ndk.github.io。 新建仓库之后，你可以在仓库里找到你仓库的链接，就像这样： https://github.com/YourGithubID/YourRepoName.git 然后打开你的本地Hexo文件夹，有个_config.yml文件（注意不是主题文件夹里的那个），使用你的代码编辑器打开它，划到最下面有个deploy标签，你需要编辑一下： #原来是这样的deploy: type: &#39;&#39; #你需要把它改成deploy: type: &#39;git&#39; repository: https:&#x2F;&#x2F;github.com&#x2F;YourGithubID&#x2F;YourRepoName.git #这边写的是你的仓库链接，我这个只是范例 #注意冒号之后有空格 第16行还有个标签叫url，你需要把后面的值改成你的仓库名称，比如这样： url: http:&#x2F;&#x2F;YourGithubID.github.io 然后保存即可。 在部署前你必须使用hexo g重新生成网页文件。你可以运行hexo s命令先在本地检查你的网站还有没有问题。 部署使用一个命令： ➜ hexo deploy #或者hexo d，把本地生成的文件部署到GitHub上 如果你是第一次在命令行上面使用GitHub，那么将会有一个弹窗要求你登录你的GitHub，之后，你的网站将会被推送到GitHub上。过几分钟你就可以通过你的仓库名作为URL访问你的网站了。比如我的网站的地址就是legr4ndk.github.io。 注意事项 GitHub因为国内特殊环境可能出现无法访问，这个需要魔法上网。 每次deploy之后都需要几分钟后才能刷新观察到变化，切勿心急 每次写完新文章或者更换主题什么的之后，必须使用hexo g重新生成文件之后再部署 主题可以去这里寻找自己喜欢的，点击主题名字可以直接跳转主题的GitHub页面，跟据上面的教程安装即可。更改主题请去本地Hexo主文件夹的_config.yml内的theme标签更改。 主题内可能有部分依赖，建议换主题后在主题文件夹的命令行内运行npm install一键安装依赖（有的主题可能不行，建议查看主题的项目下的安装教程）。 到此为止你已经可以上线一个基础的个人网站了，接下来就是跟据主题的README.md文件介绍的那样去自己订制网页了。 Have fun~","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"Developer的自我修养","slug":"Developer的自我修养","permalink":"https://blog.legr4ndk.top/tags/Developer%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}]},{"title":"C语言数字、指针、布尔值灵活利用的典范","slug":"TheCLanguageIsSoNB","date":"2020-10-16T16:12:19.000Z","updated":"2020-12-04T12:13:54.722Z","comments":true,"path":"2020/10/17/TheCLanguageIsSoNB/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/17/TheCLanguageIsSoNB/","excerpt":"","text":"先思考这个问题，假设我有一组数，我需要在每两个数字中间加入一个空格然后再输出出来，末尾和头部都没有空格，应该如何实现。 实现方法很简单，加个if就可以实现了，比如我想输出1 2 3 4 5 6，就可以这样： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) &#123; if (i == 5) //输出到最后一个数字了 printf(&quot;%d&quot;, arr[i]); else printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125; 我们利用一个if语句来判断是否输出到最后一个数字，来选择是否输出占位的空格。事实上，也可以对第一个数字特殊对待，然后剩余数据输出时附带一个空格。 但是如果我们这么做呢： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) printf(&quot; %d&quot; + !i, arr[i]); return 0;&#125; 极其简单的几句话完成了我们之前要的操作，一气呵成。 我详细叙述下它的过程： 玄机在于printf语句的那个加法上。C语言的字符串常量作参数，实际上是一个指向常量池中该字符串的指针，也就是可以进行运算。然后就是一个!i，这是把C语言中的整型数据当布尔值来看待，对他取非。当循环第一趟时，i=0，0在C语言中是false，非i得到true，默认为1，当那个指针+1，指针就从原来的指向空格，变成指向“%d”，那么就不会输出空格。而当之后几轮时，i均为非0数，C语言中为true，那么取非则得到false，即0，那么原指针+0，就是它本身，也就会正常输出空格，最后达到我们的要求。 这种写法说实话有很大局限性，可读性也极差，但是却很好的体现了C语言的灵活之处。C语言对数据和内存的操作极为灵活，这就要求使用者有很高的水平。这种写法不推荐在正式的程序设计中使用，但是对于开拓思维、优化程序是很有帮助的。","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"做个好码农","slug":"做个好码农","permalink":"https://blog.legr4ndk.top/tags/%E5%81%9A%E4%B8%AA%E5%A5%BD%E7%A0%81%E5%86%9C/"}]},{"title":"Use git to push your code to your Github's repository","slug":"GitPushBriefIntroduction","date":"2020-10-16T15:45:05.000Z","updated":"2020-12-04T12:11:31.677Z","comments":true,"path":"2020/10/16/GitPushBriefIntroduction/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/16/GitPushBriefIntroduction/","excerpt":"","text":"First things first,install git. ——Stop BBing if you have not even installed the git. Install git(may need root permission) Ubuntu/Debian/Deepin: apt install git Arch/Manjaro:pacman -S git Free BSD:pkg install git macOS:brew install git Windows:Click HERE to download the installer Run git –version to make sure that git is installed on your device. Put your codes to a folder and initializeNow you can copy+paste all your code that need to be pushed to the Github in your new folder.Then run a terminal in this folder. Using git init to initial your local repository. And do not forget to add a new repository in your Github account.Once you added a new repository to your Github,you will get a repository-link just like this: https://github.com/YourGithubID/YourRepoName.git Now,run git remote add origin $YourRepoLink to link your remote repository to the local one. Add your files to staging areaUse git add $Filename to add the files you need to staging area. Or you can use git add . (THERE IS A DOT AT THE END) to add all your files。 Then run git status to check the files in your local repository. Run git commit -m ‘$YourCommits’ to add some commits to this submit. Push your code to GithubFirst of all,use git pull origin master to pull your online repository. Use git push origin master to submit your files to Github. There are some cases that you will meet the ERROR that refusing to merge unrelated histories when you pull.You can try git pull origin master –allow-unrelated-histories to allow merging two unrelated branches.(At the first time,the online repository is empty but the local one have some files,so of course they are unrelated). Now you can check your new repository on the Github. Done,enjoy.","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"Developer的自我修养","slug":"Developer的自我修养","permalink":"https://blog.legr4ndk.top/tags/Developer%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}]},{"title":"命名规则与驼峰命名法","slug":"NamingRuleAndCamelCase","date":"2020-10-16T13:44:37.000Z","updated":"2020-12-04T12:13:40.548Z","comments":true,"path":"2020/10/16/NamingRuleAndCamelCase/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/16/NamingRuleAndCamelCase/","excerpt":"","text":"还在使用x，y，z，a，b，c等无意义字符做变量名嘛？还因为把变量命名位g，s，b而遭到同学的嘲笑嘛？还因为不知道怎么命名变量能做的更直观嘛？ ——Introducing Camel-Case：驼峰命名法 我们现在先来看看一个例子： 假如我们想要定义一个变量存储我们的名字，该怎么命名呢？ mylastname 构成这个变量名的所有字母都通过小写被粗暴地整合在了一起，很难一眼看清，对吧？这种变量命名方法明显地降低了代码的可读性。要不，我们拆分一下单词？ my_last_mane 显而易见地，这个变量名的可读性比上面那种高了很多，我们可以轻易地读出它的各个单词并且很清楚地知道它的意思。但是很显然，这不够紧凑，我们还得多打两个字符（吐槽下这下划线真的不是很好按）。 驼峰命名法驼峰命名法的命名规格极为形象，通过大小写像驼峰一样变换来实现单词的区分，更方便直观地表示变量名。 那我们来看看驼峰命名法该怎么用： myLastName 相比于前两种，驼峰命名法既直观又紧凑，保证了代码可读性的同时也兼顾了效率。 驼峰命名法的规则是这样的： 当变量名或函数名是由多个单词连结在一起，构成的唯一识别字时，每一节个单词的首字母都采用大写来区分，单词与单词之间不额外添加下划线。 而以第一个单词的首字母是否要大写为区分，我们又可以分成大驼峰法和小驼峰法。 大驼峰法：包括第一个单词在内的所有单词的首字母全部大写，如： MyLastName DataBaseUser 小驼峰法：第一个单词的首字母不大写，其余每个单词的首字母均大写，如： myLastName studentsAverageGrades 驼峰命名法就介绍到这里。 接下来再讲讲我使用的一种命名规则。 强烈建议使用英文命名！！！ 变量的命名规则变量名的命名，首先应该是这个变量要储存的内容的英文意思。借助你强大的英文水平，先把你想好的中文变量名翻译成英文，不会的话就借助翻译软件吧。 然后，如果你翻译出来的内容仅由1个英文单词构成，请直接以这个单词的完全小写的形式命名这个变量。如果是由多个单词组成的词组，应该使用小驼峰法的方式为这个变量命名。 记住，它应该是个名词或者名词性词组。 例如： salary,tax,carSum,taxRate; 特殊地，给布尔类型的变量命名，建议使用 is + 属性名的方法，依照具体的语境，也可以用can，have，should等前缀代替is，同样使用小驼峰法。同时要记得避免使用否定词。例如： isReal,isHigh;(√)isNotTall,isError;(×) 常量的命名规则常量一般是指使用const关键字修饰定义的数据，有时也只使用预处理宏#define定义的数据。 使用const关键字定义的常量它的命名规则和变量类似，但是要使用大驼峰法，即第一个单词的首字母也要大写。例如： Line,SavingAccount,Pi; 使用#define关键字宏定义的常量它的所有字母都应该采用大写，同时，若是由多个单词组成的变量名，为了区分每个单词，在每两个单词之间应该添加下划线。例如： PI,MAX_SIZE; 函数/方法的命名规则函数的名称应该是一个动词或者一个动词词组。如果函数名仅由单个单词构成，那么请以这个单词的完全小写形式命名这个函数。如果这个函数名是一个动词词组，请以小驼峰法的方式命名这个函数。例如： getArea,setPath,takeSteps; 名字空间的命名规则（C++）对于名字空间，请以一个英文单词完成对它的命名，而且，应该使用它的完全小写形式。例如： model,common; 结构、类（C++）的命名规则结构体和类的名称应该是一个名词或者名词性词组。若使用单个单词命名，请首字母大写；若使用词组，应使用大驼峰法命名。例如： Node,SomeClass; 但是，命名结构和类形成的实例（结构体和对象）时，应该依照一般的变量的命名法进行命名。 对于枚举类型（以enum关键词声明）同样建议使用名词或者名词性词组，以首字母大写或者大驼峰法命名。 而对于枚举类型的枚举常量，建议以全部大写字母+下划线分割单词的方式命名,同时应尽量使用共同的类型名作为前缀。 例如： enum Color &#123; COLOR_RED, COLOR_GREEN, COLOR_BLUE &#125;;enum ColorType &#123; COLOR_TYPE_WARM, COLOR_TYPE_COLD &#125;; 额外再提几个用于命名的关键字以及技巧，让代码更直观 get应该用在直接取得已设定值的函数中。 set应该用在直接为变量设定值的函数中。 compute应该用在用于进行计算的函数中。 find应该用在用于查找的函数中。 init/initialize应该使用在用于初始化的函数中。 在需要标识序号的变量名中，使用No + 序号比较合适。 布尔变量的命名应使用is，has等前缀，并且尽量避免否定词。 循环变量建议设置为i，j，k，并且建议优先使用i而把j，k用于循环嵌套。 对于缩略词我们有两种态度：1、对于那种缩写了人家可能就看不懂了的，比如cmd，init，请不要用缩写代替他们。2、对于那种缩写认识展开别人就看不懂的，比如HTML，CPU，老老实实写缩写。 另外，对于自己写的头文件的命名，推荐使用大驼峰命名法。例如 MyClass.hCppFunction.h OK,有关命名方法先写这么多。","categories":[{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"}],"tags":[{"name":"Developer的自我修养","slug":"Developer的自我修养","permalink":"https://blog.legr4ndk.top/tags/Developer%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2020-10-15T13:36:30.000Z","updated":"2020-12-04T12:15:14.791Z","comments":true,"path":"2020/10/15/HelloWorld/","link":"","permalink":"https://blog.legr4ndk.top/2020/10/15/HelloWorld/","excerpt":"","text":"Hello World 哈哈哈今天布置了一个github上的Hexo静态站点 准备下次写个教程（flag插好） 这次我整了两个分部，gitee和github上面我都有布置 不得不吐槽一下gitee page 是真的难用，每次更新居然要去手动刷新，时效性还特么巨低 github就是GFW的锅了，太慢了太慢了，移动甚至都不让你上去 害，这边主要搬运一些之前写在别处的文章 还有随时想写的感想，所以不能算是纯技术类博客吧 （所以这站点名字叫QQ空间哈哈哈哈） 等我更新！ 宰🕊祭天 Update:Gitee pages太【自主规制】难用了，我把那边删了，以后只在GitHub上面发表。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://blog.legr4ndk.top/categories/Misc/"}],"tags":[{"name":"文艺","slug":"文艺","permalink":"https://blog.legr4ndk.top/tags/%E6%96%87%E8%89%BA/"}]}],"categories":[{"name":"Poet","slug":"Poet","permalink":"https://blog.legr4ndk.top/categories/Poet/"},{"name":"Technical","slug":"Technical","permalink":"https://blog.legr4ndk.top/categories/Technical/"},{"name":"Fun","slug":"Fun","permalink":"https://blog.legr4ndk.top/categories/Fun/"},{"name":"Misc","slug":"Misc","permalink":"https://blog.legr4ndk.top/categories/Misc/"}],"tags":[{"name":"文艺","slug":"文艺","permalink":"https://blog.legr4ndk.top/tags/%E6%96%87%E8%89%BA/"},{"name":"CTF","slug":"CTF","permalink":"https://blog.legr4ndk.top/tags/CTF/"},{"name":"后端","slug":"后端","permalink":"https://blog.legr4ndk.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","permalink":"https://blog.legr4ndk.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"做个好码农","slug":"做个好码农","permalink":"https://blog.legr4ndk.top/tags/%E5%81%9A%E4%B8%AA%E5%A5%BD%E7%A0%81%E5%86%9C/"},{"name":"Developer的自我修养","slug":"Developer的自我修养","permalink":"https://blog.legr4ndk.top/tags/Developer%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}]}