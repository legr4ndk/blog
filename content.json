{"meta":{"title":"Legrandk's Qzone","subtitle":"","description":"","author":"Legrandk","url":"https://legr4ndk.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2020-10-17T10:21:49.923Z","updated":"2020-10-17T10:21:49.923Z","comments":false,"path":"links/index.html","permalink":"https://legr4ndk.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-16T09:08:25.732Z","updated":"2020-10-16T09:08:25.732Z","comments":false,"path":"about/index.html","permalink":"https://legr4ndk.github.io/about/index.html","excerpt":"","text":"一只HDU的沙雕id源自曾服役120年的国际标准公斤实体Le Grand K网络空间安全专业出身，现为计算机科学与技术专业学生主要研究C++与C#游戏开发、Web应用程序后端前端苦手（泪目），日语菜鸡插着的flag永远不拔（宛如戏台上的老将军）欢迎来找我玩啊哈哈哈"},{"title":"分类","date":"2020-10-16T07:32:16.374Z","updated":"2020-10-16T07:32:16.374Z","comments":false,"path":"categories/index.html","permalink":"https://legr4ndk.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-16T07:32:16.376Z","updated":"2020-10-16T07:32:16.376Z","comments":false,"path":"tags/index.html","permalink":"https://legr4ndk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言数字、指针、布尔值灵活利用的典范","slug":"TheCLanguageIsSoNB","date":"2020-10-16T16:12:19.000Z","updated":"2020-10-16T16:38:50.689Z","comments":true,"path":"2020/10/17/TheCLanguageIsSoNB/","link":"","permalink":"https://legr4ndk.github.io/2020/10/17/TheCLanguageIsSoNB/","excerpt":"","text":"先思考这个问题，假设我有一组数，我需要在每两个数字中间加入一个空格然后再输出出来，末尾和头部都没有空格，应该如何实现。 实现方法很简单，加个if就可以实现了，比如我想输出1 2 3 4 5 6，就可以这样： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) &#123; if (i == 5) //输出到最后一个数字了 printf(&quot;%d&quot;, arr[i]); else printf(&quot;%d &quot;, arr[i]); &#125; return 0; 我们利用一个if语句来判断是否输出到最后一个数字，来选择是否输出占位的空格。事实上，也可以对第一个数字特殊对待，然后剩余数据输出时附带一个空格。 但是如果我们这么做呢： #include&lt;stdio.h&gt;int main()&#123; int arr[6] = &#123; 1, 2, 3, 4, 5, 6 &#125;; for (int i = 0; i &lt; 6; i++) printf(&quot; %d&quot; + !i, arr[i]); return 0;&#125; 极其简单的几句话完成了我们之前要的操作，一气呵成。 我详细叙述下它的过程： 玄机在于printf语句的那个加法上。C语言的字符串常量作参数，实际上是一个指向常量池中该字符串的指针，也就是可以进行运算。然后就是一个!i，这是把C语言中的整型数据当布尔值来看待，对他取非。当循环第一趟时，i=0，0在C语言中是false，非i得到true，默认为1，当那个指针+1，指针就从原来的指向空格，变成指向“%d”，那么就不会输出空格。而当之后几轮时，i均为非0数，C语言中为true，那么取非则得到false，即0，那么原指针+0，就是它本身，也就会正常输出空格，最后达到我们的要求。 这种写法说实话有很大局限性，可读性也极差，但是却很好的体现了C语言的灵活之处。C语言对数据和内存的操作极为灵活，这就要求使用者有很高的水平。这种写法不推荐在正式的程序设计中使用，但是对于开拓思维、优化程序是很有帮助的。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/tags/C-C/"}]},{"title":"Use git to push your code to your Github's repository","slug":"GitPushBriefIntroduction","date":"2020-10-16T15:45:05.000Z","updated":"2020-10-17T12:34:49.666Z","comments":true,"path":"2020/10/16/GitPushBriefIntroduction/","link":"","permalink":"https://legr4ndk.github.io/2020/10/16/GitPushBriefIntroduction/","excerpt":"","text":"First things first,install git. ——Stop BBing if you have not even installed the git. Install git(may need root permission) Ubuntu/Debian/Deepin: apt install git Arch/Manjaro:pacman -S git Free BSD:pkg install git macOS:brew install git Windows:Click HERE to download the installer Run git –version to make sure that git is installed on your device. Put your codes to a folder and initializeNow you can copy+paste all your code that need to be pushed to the Github in your new folder.Then run a terminal in this folder. Using git init to initial your local repository. And do not forget to add a new repository in your Github account.Once you added a new repository to your Github,you will get a repository-link just like this: https://github.com/YourGithubID/YourRepoName.git Now,run git remote add origin $YourRepoLink to link your remote repository to the local one. Add your files to staging areaUse git add $Filename to add the files you need to staging area. Or you can use git add . (THERE IS A DOT AT THE END) to add all your files。 Then run git status to check the files in your local repository. Run git commit -m ‘$YourCommits’ to add some commits to this submit. Push your code to GithubFirst of all,use git pull origin master to pull your online repository. Use git push origin master to submit your files to Github. There are some cases that you will meet the ERROR that refusing to merge unrelated histories when you pull.You can try git pull origin master –allow-unrelated-histories to allow merging two unrelated branches.(At the first time,the online repository is empty but the local one have some files,so of course they are unrelated). Now you can check your new repository on the Github. Done,enjoy.","categories":[{"name":"Git","slug":"Git","permalink":"https://legr4ndk.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://legr4ndk.github.io/tags/git/"}]},{"title":"命名规则与驼峰命名法","slug":"NamingRuleAndCamelCase","date":"2020-10-16T13:44:37.000Z","updated":"2020-10-16T14:03:21.625Z","comments":true,"path":"2020/10/16/NamingRuleAndCamelCase/","link":"","permalink":"https://legr4ndk.github.io/2020/10/16/NamingRuleAndCamelCase/","excerpt":"","text":"还在使用x，y，z，a，b，c等无意义字符做变量名嘛？还因为把变量命名位g，s，b而遭到同学的嘲笑嘛？还因为不知道怎么命名变量能做的更直观嘛？ ——Introducing Camel-Case：驼峰命名法 我们现在先来看看一个例子： 假如我们想要定义一个变量存储我们的名字，该怎么命名呢？ mylastname 构成这个变量名的所有字母都通过小写被粗暴地整合在了一起，很难一眼看清，对吧？这种变量命名方法明显地降低了代码的可读性。要不，我们拆分一下单词？ my_last_mane 显而易见地，这个变量名的可读性比上面那种高了很多，我们可以轻易地读出它的各个单词并且很清楚地知道它的意思。但是很显然，这不够紧凑，我们还得多打两个字符（吐槽下这下划线真的不是很好按）。 驼峰命名法驼峰命名法的命名规格极为形象，通过大小写像驼峰一样变换来实现单词的区分，更方便直观地表示变量名。 那我们来看看驼峰命名法该怎么用： myLastName 相比于前两种，驼峰命名法既直观又紧凑，保证了代码可读性的同时也兼顾了效率。 驼峰命名法的规则是这样的： 当变量名或函数名是由多个单词连结在一起，构成的唯一识别字时，每一节个单词的首字母都采用大写来区分，单词与单词之间不额外添加下划线。 而以第一个单词的首字母是否要大写为区分，我们又可以分成大驼峰法和小驼峰法。 大驼峰法：包括第一个单词在内的所有单词的首字母全部大写，如： MyLastName DataBaseUser 小驼峰法：第一个单词的首字母不大写，其余每个单词的首字母均大写，如： myLastName studentsAverageGrades 驼峰命名法就介绍到这里。 接下来再讲讲我使用的一种命名规则。 强烈建议使用英文命名！！！ 变量的命名规则变量名的命名，首先应该是这个变量要储存的内容的英文意思。借助你强大的英文水平，先把你想好的中文变量名翻译成英文，不会的话就借助翻译软件吧。 然后，如果你翻译出来的内容仅由1个英文单词构成，请直接以这个单词的完全小写的形式命名这个变量。如果是由多个单词组成的词组，应该使用小驼峰法的方式为这个变量命名。 记住，它应该是个名词或者名词性词组。 例如： salary,tax,carSum,taxRate; 特殊地，给布尔类型的变量命名，建议使用 is + 属性名的方法，依照具体的语境，也可以用can，have，should等前缀代替is，同样使用小驼峰法。同时要记得避免使用否定词。例如： isReal,isHigh;(√)isNotTall,isError;(×) 常量的命名规则常量一般是指使用const关键字修饰定义的数据，有时也只使用预处理宏#define定义的数据。 使用const关键字定义的常量它的命名规则和变量类似，但是要使用大驼峰法，即第一个单词的首字母也要大写。例如： Line,SavingAccount,Pi; 使用#define关键字宏定义的常量它的所有字母都应该采用大写，同时，若是由多个单词组成的变量名，为了区分每个单词，在每两个单词之间应该添加下划线。例如： PI,MAX_SIZE; 函数/方法的命名规则函数的名称应该是一个动词或者一个动词词组。如果函数名仅由单个单词构成，那么请以这个单词的完全小写形式命名这个函数。如果这个函数名是一个动词词组，请以小驼峰法的方式命名这个函数。例如： getArea,setPath,takeSteps; 名字空间的命名规则（C++）对于名字空间，请以一个英文单词完成对它的命名，而且，应该使用它的完全小写形式。例如： model,common; 结构、类（C++）的命名规则结构体和类的名称应该是一个名词或者名词性词组。若使用单个单词命名，请首字母大写；若使用词组，应使用大驼峰法命名。例如： Node,SomeClass; 但是，命名结构和类形成的实例（结构体和对象）时，应该依照一般的变量的命名法进行命名。 对于枚举类型（以enum关键词声明）同样建议使用名词或者名词性词组，以首字母大写或者大驼峰法命名。 而对于枚举类型的枚举常量，建议以全部大写字母+下划线分割单词的方式命名,同时应尽量使用共同的类型名作为前缀。 例如： enum Color &#123; COLOR_RED, COLOR_GREEN, COLOR_BLUE &#125;;enum ColorType &#123; COLOR_TYPE_WARM, COLOR_TYPE_COLD &#125;; 额外再提几个用于命名的关键字以及技巧，让代码更直观 get应该用在直接取得已设定值的函数中。 set应该用在直接为变量设定值的函数中。 compute应该用在用于进行计算的函数中。 find应该用在用于查找的函数中。 init/initialize应该使用在用于初始化的函数中。 在需要标识序号的变量名中，使用No + 序号比较合适。 布尔变量的命名应使用is，has等前缀，并且尽量避免否定词。 循环变量建议设置为i，j，k，并且建议优先使用i而把j，k用于循环嵌套。 对于缩略词我们有两种态度：1、对于那种缩写了人家可能就看不懂了的，比如cmd，init，请不要用缩写代替他们。2、对于那种缩写认识展开别人就看不懂的，比如HTML，CPU，老老实实写缩写。 另外，对于自己写的头文件的命名，推荐使用大驼峰命名法。例如 MyClass.hCppFunction.h OK,有关命名方法先写这么多。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"}],"tags":[{"name":"CamelCase","slug":"CamelCase","permalink":"https://legr4ndk.github.io/tags/CamelCase/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2020-10-15T14:30:10.810Z","updated":"2020-10-16T16:06:04.742Z","comments":true,"path":"2020/10/15/HelloWorld/","link":"","permalink":"https://legr4ndk.github.io/2020/10/15/HelloWorld/","excerpt":"","text":"Hello World 哈哈哈今天布置了一个github上的Hexo静态站点 准备下次写个教程（flag插好） 这次我整了两个分部，gitee和github上面我都有布置 不得不吐槽一下gitee page 是真的难用，每次更新居然要去手动刷新，时效性还特么巨低 github就是GFW的锅了，太慢了太慢了，移动甚至都不让你上去 害，这边主要搬运一些之前写在别处的文章 还有随时想写的感想，所以不能算是纯技术类博客吧 （所以这站点名字叫QQ空间哈哈哈哈） 等我更新！ 宰🕊祭天","categories":[],"tags":[]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/categories/C-C/"},{"name":"Git","slug":"Git","permalink":"https://legr4ndk.github.io/categories/Git/"},{"name":"Programming","slug":"Programming","permalink":"https://legr4ndk.github.io/categories/Programming/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://legr4ndk.github.io/tags/C-C/"},{"name":"git","slug":"git","permalink":"https://legr4ndk.github.io/tags/git/"},{"name":"CamelCase","slug":"CamelCase","permalink":"https://legr4ndk.github.io/tags/CamelCase/"}]}