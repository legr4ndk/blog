{"meta":{"title":"Legrandk's Qzone","subtitle":"","description":"","author":"Legrandk","url":"https://www.legr4ndk.top","root":"/"},"pages":[{"title":"找不到页面了！！","date":"2021-05-29T05:05:18.542Z","updated":"2021-05-29T05:05:18.542Z","comments":false,"path":"/404.html","permalink":"https://www.legr4ndk.top/404.html","excerpt":"","text":"别看了，这边没东西的 ## コード ４０４ 戳这儿👇回到主页"},{"title":"关于","date":"2021-05-29T05:02:04.882Z","updated":"2021-05-29T05:02:04.882Z","comments":false,"path":"about/index.html","permalink":"https://www.legr4ndk.top/about/index.html","excerpt":"","text":"一切都是主人的命令罢了。 About me夜露死苦！一只HDU的沙雕id源自曾服役120年的国际标准公斤实体Le Grand K以前是网络空间安全专业的，现在是计算机科学与技术专业的学生左壬喜欢插flag（然后不拔D D L 人为人儒雅随和，见谁都能有的没的扯几句夜猫子，但是从来没有通宵过非著名中二病晚期患者 What am I doing now 学习C#与.Net Core 想学好C++的网络编程和Windows API 被老师抓去做新苗计划了，学习MindSpore与后端开发中 百 萬 前 端 大 製 作 日语 What I love 日语ACG类歌曲 Vocaloid歌曲 彩虹合唱团！ 异世界、末日题材番剧 无厘头动漫 英文pop/country music 部分小语种 日式角色扮演游戏（JRPG） 第一人称射击类游戏（FPS） 部分手游🤣（比如王者荣耀） 无双与开放世界类 How to find me 新浪微博：Iegrandk（注意第一个是大写的i） QQ音乐：Legrandk 网易云音乐：六氟锑酸钠_NaSbF6 知乎：Legrandk 邮箱：legrandk@aliyun.com Github：legr4ndk Gitee：Legrandk Twitter：legr4ndk"},{"title":"分类","date":"2021-05-29T05:05:34.261Z","updated":"2021-03-14T13:39:09.366Z","comments":false,"path":"categories/index.html","permalink":"https://www.legr4ndk.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-29T05:05:41.694Z","updated":"2020-10-16T07:32:16.375Z","comments":true,"path":"links/index.html","permalink":"https://www.legr4ndk.top/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-14T13:39:22.104Z","updated":"2021-03-14T13:39:22.104Z","comments":false,"path":"tags/index.html","permalink":"https://www.legr4ndk.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ComputerArch","slug":"ComputerArch","date":"2021-07-04T03:58:07.000Z","updated":"2021-07-04T04:04:06.658Z","comments":true,"path":"2021/07/04/ComputerArch/","link":"","permalink":"https://www.legr4ndk.top/2021/07/04/ComputerArch/","excerpt":"","text":"你想看哪个实验 1 2 3 4 5 6 7 8 9","categories":[{"name":"学习","slug":"学习","permalink":"https://www.legr4ndk.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"study","slug":"study","permalink":"https://www.legr4ndk.top/tags/study/"}]},{"title":"当代大学牲的正义演讲（日语版）","slug":"origay","date":"2021-07-04T03:40:18.000Z","updated":"2021-07-04T03:42:00.519Z","comments":true,"path":"2021/07/04/origay/","link":"","permalink":"https://www.legr4ndk.top/2021/07/04/origay/","excerpt":"","text":"也许，我可以整个好活？ 俺(おれ)たちはどんな困難(こんなん)あっても 恐(おそ)れないで 笑(わら)って迎(むか)え 恐怖(きょうふ)を取り除(のぞ)く最良(さいりょう)の方法(ほうほう)は 恐怖(きょうふ)に立(た)ち向(む)かうことだ 堅持(けんじ)はこそ勝利(しょうり)だ 頑張(がんば)ろう！オーリゲー！！！😫","categories":[{"name":"耍","slug":"耍","permalink":"https://www.legr4ndk.top/categories/%E8%80%8D/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]},{"title":"编译原理实验报告与实验文件","slug":"CompilerPrincipalReport","date":"2021-07-04T03:20:41.000Z","updated":"2021-07-04T03:34:40.100Z","comments":true,"path":"2021/07/04/CompilerPrincipalReport/","link":"","permalink":"https://www.legr4ndk.top/2021/07/04/CompilerPrincipalReport/","excerpt":"","text":"实验代码CompilerPrincipalExperiment: 杭电计算机编译原理课程实验 实验有四个，输入均是用命令行参数指明输入文件，输出默认在输入文件同文件夹。 LexicalAnalysis.cc词法分析程序，把源代码分解成二元组，可以有效识别非法字符和两类注释并且在对应报错位置予以提出。 RegexParser.cc正规表达式解析程序，可以把正规表达式解析成后缀表达式然后输出可以生成对应的NFA的dot语言的源代码，源代码再经dot工具可以得到使用MYT算法得到的对应正规表达式的NFA。 注意，它的输入是单纯正规表达式 RecursiveDownParsing.cc递归下降子程序，可以实现LL(1)文法的语句的合法性的鉴别，具体文法见测试样例。 注意，它的输入是经词法分析处理的表达式的二元组 LL1Parser.ccLL(1)分析程序，可以实现LL(1)文法的语句的合法性的鉴别，具体文法见测试样例。 注意，它的输入是经词法分析处理的表达式的二元组 实验报告","categories":[{"name":"学习","slug":"学习","permalink":"https://www.legr4ndk.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"study","slug":"study","permalink":"https://www.legr4ndk.top/tags/study/"}]},{"title":"Knuth洗牌算法","slug":"KnuthShuffle","date":"2021-03-13T04:54:52.000Z","updated":"2021-03-14T15:26:12.610Z","comments":true,"path":"2021/03/13/KnuthShuffle/","link":"","permalink":"https://www.legr4ndk.top/2021/03/13/KnuthShuffle/","excerpt":"","text":"Knuth算法是一种非常常用的洗牌算法，它在很多方面都有着广泛的应用。本文需要一定的概率论知识，包括排列组合、古典概型和条件概率。 问题分析洗牌其实是一种取随机的算法，只有每一面牌在序列中的任意位置出现的概率都相同的时候，我们才可以说一个随机算法是公平的。 最容易想到的公平洗牌方式大概是这种：有n张牌，这n张牌自由组合共有n!个组合，每次只要随机且等可能地从这n!种情况内选取一项，就可以得到一种随机的排列，也就是一次洗牌。那么问题就来了，n在小的时候，n!的数值大小仍可计算，而当n逐渐增大到一定值的时候，n!就会变得不可计算了起来，要随机取得一个情况要耗费的开支太大，时间复杂度达到了o(n!)。 那么，有没有别的方法可以保证一次洗牌开销没那么大而每张牌在任一位置的概率都相等呢？ 算法分析我们可以借鉴下插入排序的思想。 比如有5张牌需要我去打乱位置，我就直接留五个空位，然后从第一个空位开始，从原来五张牌中随机选择一张，填到1号空位中，然后在原来的五张牌中抹去那张，还剩下4张。接下来来到二号空位，继续从剩下的4张牌中随机选择一张，放入第二个空位中，再在剩余的四张牌中抹去被选中的那一张……依次类推，你会得到一个序列，那就是洗牌的结果。那么，它是公平的吗？让我们来算算它的概率。 任一牌出现在第一个位置的概率，即为它第一次就被选中的概率，为1/5。 任一牌出现在第二个位置的概率，即为它第一次落选，但它在第二次被选中的概率，为4/5 * 1/4 = 1/5。 任一牌出现在第三个位置的概率，即为它第一、二次落选，但在第三次被选中的概率，为4/5 * 3/4 * 1/3 = 1/5。 …… 依此类推，跟据条件概率公式推导，你可以发现一张牌出现在任一位置的概率都为1/5即1/n，说明此洗牌算法是公平的。我们分析这个算法的时间复杂度，可以发现其时间复杂度为o(n)，也就是说他遍历一遍牌，就能实现洗牌的操作。但是我们发现，我们仍需要请求额外的存储空间来存储洗完的牌，空间复杂度方面还可以优化，而且，如何标记已经被选择过的牌，也是一个问题，这些都会带来额外的开支。 优化那么我们如何优化它的效率呢？我们注意到，每次随机选完牌之后，下一次选牌仍是随机的，那么在洗牌前的数据组中，牌的顺序是无关紧要的。我们完全可以把取数据然后放数据的过程，改为交换数据的过程。从第一个位置开始洗牌，从整个数组里所有元素中随机选择一个位置的内容与1号位置的元素交换，完成第一轮的洗牌。第二轮的时候，我们默认1号位置已经完成洗牌，从2~n号位置中选择一个元素与2号位置的元素交换位置，这样二号位置的洗牌也完成了……依此类推，把每个位置的牌都遍历一次，即可完成一次洗牌。这就是Knuth Shuffle洗牌算法。 使用条件概率公式，你可以很轻易地算出，每一张牌出现于任一位置的概率均为1/n，而且，Knuth算法每次会把排完序的数据排除在下一次循环之外，完美解决了已经洗完的部分的标记问题，它不需要额外的存储空间，只需要在交换两个数据的时候使用一个临时变量作为中间交换量即可，效率与空间利用率比之前高了很多。 代码以下是使用C#实现的Knuth算法，可以把{1, 2, 3, 4, 5}五张牌乱序洗牌后输出。 using System;namespace KnuthShuffle{ class Program { static void Main(string[] args) { int[] arr = {1, 2, 3, 4, 5}; //随机数生成法千千万，这个用的是Unix时间戳做种子 //你要是想搞事，完全可以换成随机性更强的随机数生成方法 Random random = new Random(); //Knuth洗牌算法其实就下面这么三行，非常简单 for (int i = 0; i &lt; arr.Length; i++) { Swap(ref arr[i], ref arr[random.Next(i, arr.Length)]); } //其实你要极致优化的话，听说从后面开始向前洗牌效率更高（这个是玄学我不确定） foreach (var variable in arr) { Console.WriteLine(variable); } } static void Swap(ref int x, ref int y) { int temp = x; x = y; y = temp; } }} 它有什么用？最简单且直观的用途就是：他能帮我们洗牌，然后实现牌类游戏的洗牌操作。 比如对于经典牌类游戏斗地主，你可以把54张牌的牌面塞到一个容器内，然后通过Knuth算法实现洗牌，然后抽出3张作为地主牌后按次序分成3组，每个人拿到的与地主牌就都是随机的，完美的符合随机洗牌的要求，再配合排序算法，可以快速地把牌按顺序排列完毕，就可以来一把紧张刺激的斗地主了。 那么一维的可以，二维的可以吗？事实上当然可以，比如我们同样很熟悉的小游戏扫雷，把雷和空格均匀地洗开之后，再按二维堆叠，就可以形成一幅随机的雷图了，接下来就是跟据数据来判断要在空白格子里填的数据了。 事实上，我们最常见的Knuth Shuffle的运用，还是在我们听歌的那件事上。市场上几乎所有的音乐播放软件的“随机播放”功能，其实都是“伪随机”，就是通过Knuth算法实现的乱序播放歌曲。这类音乐软件会在你打开随机播放功能后对你的歌单进行一次Knuth Shuffle，然后按序播放这个“洗牌后”的歌单里的歌，但是对于用户来说，确实是看起来像随机播放的了。 那么问题来啦，我们怎么判断你的音乐App是使用的“真随机播放”还是“伪随机播放”呢？很简单，打开你的音乐软件的随机播放功能，音乐开始播放后，轻按“下一首”按钮，再轻按“上一首”功能，如果它回到了原来的那首歌，那它毫无疑问是“伪随机播放”了。“真随机播放”的话，切歌时它会随机跳到下一首去，你是回不去的了~ 不过话说回来，如果我是要开发“真随机播放”功能的程序员的话，我可能会选择在“随机播放”模式下，把“上一首”按钮和“下一首”按钮的功能都设置成洗完牌后的随机打乱的歌单里的下一首。永远都往下一首播放的话，你也回不去原来那首歌了，体验上来说，因为都是切到下一首没被听过的音乐，应该与每次都生成随机数然后去随机找歌的“真随机播放”体验一致了，而且感觉这种处理方法的开销好像比每次生成随机数的情况要小。（发现华点😏","categories":[{"name":"算法","slug":"算法","permalink":"https://www.legr4ndk.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.legr4ndk.top/tags/algorithm/"}]},{"title":"一篇文章快速上手Nginx服务器","slug":"NginxCrashCourse","date":"2021-03-08T12:21:10.000Z","updated":"2021-03-14T10:17:28.610Z","comments":true,"path":"2021/03/08/NginxCrashCourse/","link":"","permalink":"https://www.legr4ndk.top/2021/03/08/NginxCrashCourse/","excerpt":"","text":"一篇文章解决Nginx基础操作 本文基于Debian操作系统演示。（不要问我服务器为啥不用CentOS，问就是它无了 【恶 灵 退 散】前方灵魂画手出没 啥是Nginx比如你写了个HTML丢在服务器上，你输入这个服务器的域名去访问，服务器不知道要拿什么给你，也就不能访问到页面。Nginx就跟Apache一样，会监听服务器的80端口（就是http协议浏览器默认端口），有人发请求，它就把它一个特殊文件夹里的网页文件返回回去。也就是说，它是一个Web服务器应用。 Nginx的并发量非常大，能达到50000左右，是Tomcat的很多倍，在部署JavaWeb服务的时候，一个Tomcat处理的并发量有限，如果想要同时处理更多的请求，就需要有一个中间的服务器作为转发。Nginx很强（它是老毛子写的），它有两个很重要的功能，就是负载均衡和反向代理。这俩后面再说。 怎么安装我用的Debian。（CentOS变成Red Hat的上游版了，不可能再用了的~） 这次咱从源代码手动编译出Nginx，相对于直接下载得到的Nginx，自己编译的不容易有依赖问题。 你需要系统里先有C语言编译器，比如Debian类Linux可以这样： apt install build-essential # 需要权限，这玩意里面包括了编译要用的一堆东西 先去 http://nginx.org/en/download.html 下载Nginx，是个tar.gz包，然后解压： tar -xzvf nginx-xxx.tar.gz 解压完进入文件夹： cd nginx-xxx# 目录结构如下drwxr-xr-x 6 1001 1001 4096 Mar 8 16:21 auto-rw-r--r-- 1 1001 1001 302863 Apr 21 2020 CHANGES-rw-r--r-- 1 1001 1001 462213 Apr 21 2020 CHANGES.rudrwxr-xr-x 2 1001 1001 4096 Mar 8 16:21 conf-rwxr-xr-x 1 1001 1001 2502 Apr 21 2020 configuredrwxr-xr-x 4 1001 1001 4096 Mar 8 16:21 contribdrwxr-xr-x 2 1001 1001 4096 Mar 8 16:21 html-rw-r--r-- 1 1001 1001 1397 Apr 21 2020 LICENSEdrwxr-xr-x 2 1001 1001 4096 Mar 8 16:21 man-rw-r--r-- 1 1001 1001 49 Apr 21 2020 READMEdrwxr-xr-x 9 1001 1001 4096 Mar 8 16:21 src 执行目录下的configure文件来配置make与依赖，然后使用make来编译、安装： ./configuremakemake install# 注意：以下是可能会需要的依赖，make不成功就把下面的也装了（yum包管理器用户自己找去）apt install libpcre3 libpcre3-devapt install openssl libssl-devapt install zlib1gapt install zlib1g.dev 然后查找Nginx在哪： whereis nginx# 得到 nginx: /usr/local/nginx 这样就装完了Nginx。 Nginx文件结构我们可以得到以下文件树： .├── conf # 配置文件目录│&nbsp;&nbsp; ├── fastcgi.conf│&nbsp;&nbsp; ├── fastcgi.conf.default│&nbsp;&nbsp; ├── fastcgi_params│&nbsp;&nbsp; ├── fastcgi_params.default│&nbsp;&nbsp; ├── koi-utf│&nbsp;&nbsp; ├── koi-win│&nbsp;&nbsp; ├── mime.types│&nbsp;&nbsp; ├── mime.types.default│&nbsp;&nbsp; ├── nginx.conf│&nbsp;&nbsp; ├── nginx.conf.default│&nbsp;&nbsp; ├── scgi_params│&nbsp;&nbsp; ├── scgi_params.default│&nbsp;&nbsp; ├── uwsgi_params│&nbsp;&nbsp; ├── uwsgi_params.default│&nbsp;&nbsp; └── win-utf├── html # 网页文件存放目录│&nbsp;&nbsp; ├── 50x.html│&nbsp;&nbsp; └── index.html├── logs # 日志文件存放目录└── sbin # 编译所得的nginx二进制文件存放目录 └── nginx 以下介绍一下四大文件夹 conf 配置文件目录主要有一个文件：nginx.conf，已经去除了所有的注释以及一些非必须的内容。 worker_processes 1; #工作进程的数量events { worker_connections 1024; # 每个工作进程的最大连接数}# 代表此处配置的是http规则http { include mime.types; # 定义mine类型 default_type application/octet-stream; sendfile on; # 是否使用sendfile函数来实现文件输出，一般网页建议为on，下载服务器，可以设置为off来降低系统压力 keepalive_timeout 65; # 响应超时时间 server { listen 80; # http协议监听端口为80 server_name localhost; # 配置访问域名 location / { # 访问 / 路径时展示 root html; # 网站的网页存放路径，可以改到别处 index index.html index.htm; # 默认主页文件 } error_page 500 502 503 504 /50x.html; # 错误网页，包含50x的错误 location = /50x.html { # 50x错误时返回的网页的路径 root html; } }} html 网页文件目录此目录存放了该服务器受到http请求时返回给浏览器的网页文件，你可以在这边放html、css、js甚至php等网页文件（如果你的系统支持的话），以及服务器报错时显示的文件（比如50x、404等）。 logs 日志文件目录这边会有几个日志文件。 access.log会记录Nginx每次被访问的信息，包括访问地址，时间、设备、内容等信息。 error.log会记录Nginx每次出错的时间，内容等信息。 nginx.pid会记录Nginx在系统中的进程ID（即PID）。 sbin 二进制文件目录这边只有一个文件，执行它，没有任何反应，就代表你启动了Nginx。 sudo ./nginx 然后你去用域名或者ip地址什么的访问你的服务器的80端口，就可以看到这个： 看到这个就说明你成功打开Nginx了。 关于nginx有一些命令行操作： nginx -s stop # 立即停止Nginxnginx -s quit # 关闭Nginx的所有服务再关闭Nginxnginx -s reload #改变Nginx的配置文件后重新加载配置文件，无需重启Nginx，用户无感操作ps aux|grep nginx # 查看Nginx的进程 Nginx可以做什么直接拿Nginx做PHP应用服务器你可以直接在web服务器上安装PHP解释器与MySQL数据库，然后你可以在html内放入你写好的Web程序（包括html、css、js与php文件等）。默认访问这个服务器时，它会自动打开文件里的index.html。若要自动打开PHP文件，你需要在Nginx的配置文件中改动一处： location / { # 访问 / 路径时展示 root html; index index.html index.htm index.php; # 默认主页文件，在此处添加index.php} 反向代理（Reverse Proxy） 这是正向代理的示意图，客户端无法直接访问到目标服务器的时候，可以使用一个可以访问到目标服务器的中间服务器作为代理，来为客户端提供流量转发的服务。 那反向代理是怎么回事呢？ 比如我们有3台服务器运行着我们的网站的服务，每个服务器都有着各自不同的ip地址。让我们假设每台服务器最多让100人同时访问。那么，当我们有200人同时访问这个网站时，用户要如何才能知道哪台服务器是有余力处理的，而又有哪台是被挤满了即将宕机的？用户当然没法知道，因为大家访问网站都是用同一个域名，比如百度，大家都只知道baidu.com，可是它实际上有很多很多的服务器架设在各地，每次访问我们都用的是同一个域名，没有人专门去访问百度1号，百度2号等服务器，这就是反向代理的作用。反向代理服务器把客户端的请求分给多个服务器，再由这个代理服务器将应用服务器上的返回包返回给客户。这样，客户只访问了一个域名，却不会导致大家都访问了一个服务器从而把服务器搞炸。示意图如下： 这就是反向代理的作用，使用反向代理可以很方便的构建服务器集群，而这对于用户来说是无感的。 负载均衡负载均衡就是Nginx反向代理时为后台的Web服务器分配请求的策略。 Nginx有很多种策略来进行负载均衡，以下简单介绍几种。 轮询轮询适用于在后端的Web服务器的性能都差不多的时候，Nginx会把反向代理的流量均匀分配给后台每一个服务器。像上面反向代理的图片一样，服务器1，2，3号收到的代理的数量大致一样。这样可以确保大量访问到来的时候各个服务器的负载压力都相近，不至于使某个服务器压力过大。 加权轮询理解了上面那个轮询之后，加权轮询就比较好理解了。不同于上面那一个，加权轮询更适用于后端Web服务器的性能有差异的情况下。Nginx会跟据配置文件中设置好的权重比例分配代理流量到不同的服务器上去，以实现不同性能的服务器各司其职都能最大化性能利用的功能。比如上图的1，2，3号服务器，分别最多能负载的请求数为1：2：3，那么在Nginx中配置好后，Nginx会把大约50%的流量转发到服务器3上，大约33%的流量转发到服务器2上，约17%的流量则会被转发到服务器1上。使用加权轮询策略可以尽量使服务器集群的性能最大化。（能力越大，责任越大） IP Hash轮询与流量转发带来的一个很重要的问题就是一个用户两次访问这个网站，他的流量可能会被转发到不同的服务器上，之前在那个服务器上进行过的操作、存留的Session在这个新服务器上并没有，而要实现服务器集群的Session共享又十分麻烦。一个好方法是使用Redis，但是Nginx的内置IP Hash策略其实可以帮我们完美解决一个问题。当第一次你从一个IP地址访问这个网站时，Nginx会算你的IP的Hash值，然后跟据留存的Hash结果，每次来自同一IP的请求，均交给同一个服务器来执行，就可以解决Session不共享的问题了。 URL重写（rewrite）该指令通过正则表达式的使用来改变URL。可以同时存在一个或者多个指令，按照顺序一次对URL进行匹配和处理。该指令可以在server块后者location块中使用rewrite关键字配置。 语法：rewrite regex replacement [flag]; 定义如下 rewrite：指令关键字。 regex：用来匹配URI的正则表达式。 replacement：匹配成功后用来替换URI中被截取内容的字符串，默认情况如果该字符串包含“http://”、”https://“开头，则不会继续向下对URI进行其他处理，直接返回重写的URI给客户端。 flag：用来设置rewrite对URI的处理行为,包含如下数据： last：终止在本location块中处理接收到的URI，并将此处重写的URI作为新的URI使用其他location进行处理（只是终止当前location的处理）。 break：将此处重写的URI作为一个新的URI在当前location中继续执行，并不会将新的URI转向其他location。 redirect：将重写后的URI返回个客户端，状态码是302，表明临时重定向，主要用在replacement字符串不以“http://”，“ https://”或“ $scheme” 开头。 permanent 将重写的URI返回客户端，状态码为301,指明是永久重定向。 反向代理与负载均衡的实现这边只实现一个最简单的http协议下80端口的反向代理与转发。 此处假设的情况是于127.0.0.1:8080与127.0.0.1:8081上均运行着同一个WebApp，需要把从80端口入口的流量以1：2的权重转发给这两个服务。 在nginx.conf文件下进行配置即可。（配置的部分参见上面以及下文代码的注释） http { server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } }} 这个代码块我省去了外围的全局配置，只留下了http那一块（实际上被我省去的不能删） 负载均衡的实现反向代理的实现需要先实现负载均衡。负载均衡的配置需要在http协议的配置区域内配置，使用关键字upstream: http { # 此处使用upstram关键字配置负载均衡，balance1为负载均衡的自定义策略名，可任意指定 upstrean balance1{ server 127.0.0.1:8080 weight=1; # 每台服务器均使用server关键词声明 server 127.0.0.1:8081 weight=1; # 使用weight来声明每个服务器的权值，这边实现了轮询 } # 这边实现了加权轮询的负载均衡策略，两台服务器收到的请求数大致为1:2 upstrean balance2{ server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=2; } server { # 节省篇幅，这边省去 }} 反向代理实现反向代理需要在http协议的配置区域的location域内配置，使用关键字proxy pass： location / { root html; index index.html index.htm; # 此处使用proxy pass关键字进行反向代理，使用上文声明的balance2策略 proxy pass http://balance2; # 以此方法实现Nginx对80端口的访问 / 目录的流量的反向代理} URL重写的实现（以http请求转https为例）http { server { listen 80; server_name localhost; rewrite ^(.*)$ https://$host$1 permanent; # 把所有的请求，转发到https的同域名下 # 或者有另一种写法，使用return实现 return 301 https://127.0.0.1$request_uri; # 发送301 再转新的地址 }} FinalNginx是个配置坑。可以配置的地方真的是，太太太太多了，性能调优也有很多骚操作。本文只是帮助你快速理解Nginx的一些工作的原理以及如何用它最主要的功能。很多其他的功能，例如动静分离（提供静态文件服务器）等操作在本文中还没有涉及，希望后面能再自己学学。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"server","slug":"server","permalink":"https://www.legr4ndk.top/tags/server/"}]},{"title":"一篇文章快速上手JavaScript","slug":"JavaScriptCrashCourse","date":"2021-03-07T14:53:45.000Z","updated":"2021-03-14T10:17:28.603Z","comments":true,"path":"2021/03/07/JavaScriptCrashCourse/","link":"","permalink":"https://www.legr4ndk.top/2021/03/07/JavaScriptCrashCourse/","excerpt":"","text":"观此文，你仍需有C语言、HTML、CSS基础之基础。 本文规范基本上基于ECMAScript2015（就是ES6）。 你需要认识C语言的分支与循环处理、HTML的常见标签以及CSS的基础选择器。如果你对C语言的函数指针或者函数式编程常用的lambda表达式有所理解的话，将有助你快速上手JavaScript。 （事件那边你要是懂一点WPF的event原理就更好了……不过没人学C#吧…… 如何输出console.log(); //输出信息console.warn(); //输出警告，是黄色的console.error(); //输出报错，是红色的（虽然也不会导致程序中止 它们可以通过传入多个参数来实现一次性输出更多数据。 数据类型通过let声明/定义变量，通过const声明常量。（不再推荐使用var） 例如： const name = 'Alfred'; //name是常量，必须直接初始化，之后不可变let age = 19; //age是变量，仍可变 你可与使用typeof运算符来输出一个量的数据类型，例如： console.log(typeof age); //向控制台输出age的类型（输出number） string用单引号或者双引号包围的字符串。 例子中我们有： const s = 'Hello World'; 连接使用加号可以连接字符串。 可以使用模板字符串来往字符串里面填入数据（使用反引号）。 例如： let info1 = 'My name is ' + name + ', and I am ' + age + ' years old.'; //使用加法连接let info2 = `My name is ${name}, and I am ${age} years old.`; //使用模板字符串//info1 和 info2 两个字符串的内容一致 获取长度使用字符串的length属性获取字符串长度。 例如： console.log(s.length); //向控制台输出字符串s的长度（输出11） 转变字符使用字符串的toUpperCase()方法把字符串里的字母都转成大写，使用toLowerCase()方法把字符串里的字母都转成小写。注意，返回值才是所求的字符串，原字符串并不会改变。 例如： console.log(s.toUpperCase()); //向控制台输出全为大写字母的字符串s（输出为HELLO WORLD）console.log(s.toLowerCase()); //向控制台输出全为小写字母的字符串s（输出为hello world） 获取子字符串使用字符串的substring()方法获取字符串的子串。该方法有两个参数，第一个参数代表子串从原字符串的第几个开始（下标从0开始），第二个参数代表子串在父串的第几个字符前结束。注意，第一个参数所指的字符会被包含在子串中而第二个参数所指的不会。 例如： console.log(s.substring(2,5)); //向控制台输出s的自下标为2的字符开始，自下标为5的字符结束的子串（输出为llo） 将字符串分割到数组中使用字符串的split()方法将字符串分割到数组中。该方法有一个参数，为分割的分隔符，此方法将按此分隔符分割该字符串到数组。如果要分割每个字符，请使用参数''（空字符串）。注意，参数将不出现在分割完的字符串中。 例如： console.log(s.split('')); //输出[\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"d\"]console.log(s.split(' ')); //输出[\"Hello\", \"World\"]console.log(s.split('ell')); //输出[\"H\", \"o World\"] object数组一个数组内可以有多个数据，这些数据可以是不同类型的。 数组下标从0开始，逐项递增。 即使数组被定义为const，但仍可改变数组，只是不能给该量赋值其他数组。 创建数组有多种方法创建数组： const array1 = new Array(1, 2); //使用构造函数创建，括号内可以传入一些值以初始化数组（也可以不传）const array2 = [1, 2, '233']; //直接创建 访问数组元素直接使用[]即可。 console.log(array1[0]); //向控制台输出array1数组的第一项（下标为0）（输出1） 给数组添加元素虽然array1只有两个元素，但是要想给它加元素，直接array1[2] = 3即可。注意，如果添加的位置比较不和原来的贴在一起，中间会用empty填充。 array1[2] = 3;console.log(array1); //输出[1, 2, 3]，长度为3array1[6] = 7;console.log(array1); //输出[1, 2, 3, empty × 3, 7]，长度为7（empty也算长度）//特殊情况：const arr = [1, 2];arr[-2] = 5;console.log(arr); //输出 [1, 2, -2: 5]，长度为2//要访问下标为-2的元素，可以使用arr[-2]或者arr['-2'] 向末尾追加，可以使用数组的push()方法，例如： array2.push(666);console.log(array2); //输出[1, 2, '233', 666] 向开头添加，可以使用数组的unshift()方法，例如： array2.unshift(9);console.log(array2); //输出[9, 1, 2, '233', 666] 去除数组中的元素使用数组的pop()方法，可以去除数组的最后一个元素，同时，此方法会返回被去除的元素。（类似于其他语音的pushBack()方法。）例如： let x = array2.pop();console.log(array2); //输出[9, 1, 2, '233']console.log(x); //输出666 检查某个量是不是数组使用Array.isArray()方法可以检查一个量是不是数组，如果传入的参数是数组，它会返回true；否则，它会返回false。 获取数组中某个值的下标使用数组的indexOf()方法可以获取数组中该元素（由参数传入）的下标。如果参数内容不存在于数组中，该函数会返回-1。例如： console.log(array2.indexOf(2)); //输出2console.log(array2.indexOf(999)); //输出-1 遍历数组可以通过for...of循环遍历数组的值，例如： for(let x of array2) { console.log(x);}//控制台会依次输出9, 1, 2, 233 或者使用数组的forEach()方法进行遍历。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数。例如： array2.forEach(function(x) { console.log(x); }); //参数为回调匿名函数array2.forEach(x =&gt; console.log(x) ); //使用λ表达式的匿名函数//控制台会依次输出9, 1, 2, 233 取出数组中对象的特定属性值并生成新数组可以通过数组的map()方法实现。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数，该回调函数需要返回特定的属性值。此方法的返回值为所求的数组。例如： //获取数组中所有对象的idconst x = [ { id: 1, name: 'Alfred' }, { id: 2, name: 'John' }]const ids = x.map(function(i) { return i.id; });const ids = x.map(i =&gt; i.id); //λ表达式版console.log(ids);//控制台会输出[1, 2] 筛选数组中满足特定属性值要求的对象并生成新对象数组可以通过数组的filter()方法实现。该方法需要传入一个参数作为回调函数，该回调函数有一个参数，即为每次遍历时代表的数组的内容，每次遍历执行一次回调函数，该回调函数需要返回一个布尔值，为真的情况下此对象会被加入新数组。此方法的返回值为所求的数组。例如： //筛选所有id=2的对象const x = [ { id: 1, name: 'Alfred' }, { id: 2, name: 'John' }]const id2 = x.filter(function(i) { return i.id === 2; });const id2 = x.filter(i =&gt; i.id === 2); //λ表达式版console.log(id2);//控制台会输出[{id: 2, name: \"John\"}] 对象对象实际上就是大括号包围的键值对。（{key: value}) 即使对象被定义为const，但仍可改变对象的内容，只是不能给该量赋值其他对象。 例子中，有： const person = { name: 'Alfred', age: 19, address: { province: 'Zhejiang', city: 'Hangzhou' }}; 访问对象的单个值使用.运算符来方位对象的单个值。例如： console.log(person.age); //输出19 解构对象可以通过解构对象的方式从对象中取出一定数量的值。例如： const { name, age, address: {city} } = person; //现在有3个const量分别为name、age和city 添加属性可以直接为对象添加新的键值对，例如： person.email = 'person@me.com';//那么person现在是/*{ name: 'Alfred', age: 19, address: { province: 'Zhejiang', city: 'Hangzhou' }, email: 'person@me.com'}*/ 遍历对象的属性可以通过for...in循环遍历对象的属性，例如： for (x in person) { console.log(x);}//遍历属性的名字（键），控制台会依次输出name, age, address, emailfor (x in person){ console.log(person[x]);}//遍历属性的值，控制台会依次输出Alfred, 19, {province: \"Zhejiang\", city: \"Hangzhou\"}, person@me.com JSONJSON是一种数据格式，长得很像JavaScript的对象，经常用于传输数据。 使用JSON.stringify()函数可以把JavaScript的object类型数据转换为JSON字符串。例如： const a = JSON.stringify(person);console.log(a);/*输出{ \"name\":\"Alfred\", \"age\":19, \"address\":{\"province\":\"Zhejiang\",\"city\":\"Hangzhou\"}, \"email\":\"person@me.com\"}*/ 其他如果你给一个变量赋值为null，那么你用typeof运算符查看这个量的类型的时候，会发现它是object类型。 只定义了而未初始化的变量，它的默认值是undefined。 其他待补充。 DOM如何选择元素使用document.querySelector()和document.querySelectorAll()来选择HTML上的标签。 前者用来选择单个元素，后者可以选择多个元素并将其组入一个NodeList，它类似于数组，可以进行数组的一些操作（比如forEach()遍历和NodeList.children[]来选择第几个元素）。这两个函数的参数是一个字符串，字符串是选择器，形式同CSS的标签选择器、class选择器（加.）和id选择器（加#），例如： const elem1 = document.querySelector('#id'); //如果实际可选的元素不止一个，则选择第一个const elem2 = document.querySelectorAll('.item'); //选中了所有.item标记的元素 删除页面元素可以使用页面元素.remove()方法完成。 elem1.remove(); //移除页面上的以#id标记的元素elem2.remove(); //移除页面上的所有的.item标记的元素elem2.lastElementChild.remove(); //移除elem2组合中的最后一个元素 添加页面元素可以通过document.createElement()方法来创建一个元素。此方法的参数为你要创建的元素的标签名，它的返回值为新创建好的元素DOM对象。要往元素内添加元素，可以使用元素的appendChild()方法，参数为你要插入的元素。特殊地，若要插入文字，参数可以设置为document.createTextNode()，此方法的参数为元素内的字符串。例如： //在一个ul内插入一个li，li的内容为2333const ul = document.querySelector('ul') //选中ulconst li = document.createElement('li'); //创建lili.appendChild(document.createTextNode('2333')); //li内插入字符ul.appendChild(li); //把li加入ul 获取与编辑页面元素的内容试试使用元素对象的textContent、innerText、innerHTML属性可以方便的获取或者更改元素的内容。 elem2.firstElementChild.textContent = 'Hello'; //修改elem2集合中的第一个元素的标签中的文本内容elem2.firstElementChild.innerText = 'Hello'; //效果同上elem1.innerHTML = '&lt;a href=\"xxx\"&gt;233&lt;/a&gt;'; //修改elem1的内嵌html代码console.log(document.querySelector('h1').textContent); //输出的是文本console.log(document.querySelector('h1').innerText); //同上console.log(document.querySelector('h1').innerHTML); //输出的是该元素的内嵌的所有HTML代码与文本 输入框里面的内容，可以通过元素对象的value属性来获取。 获取与编辑页面元素的HTML属性与CSS样式直接使用元素对象的相应属性并赋值即可。 给HTML元素添加新类使用元素的classList.add()方法实现，该函数接受一个字符串参数，即为要添加的class名；另外有一个方法叫classList.remove()，可以去除元素的某个class。 elem1.style.background = 'red'; //把elem1元素的背景改成红色的（CSS）elem1.href = 'https://www.baidu.com'; //把elem的href属性设为百度（之前没设置的会新指定）console.log(elem1.target); //输出elem1元素的target属性的内容elem1.classList.add('container'); //给elem1的class属性添加一个 container 类（可用于CSS选择） 事件以一个按钮元素为例。 btn = document.querySelector('.btn'); 为一个元素添加监听事件使用元素的addEventListener()方法可以为特定的元素添加监听事件。该函数有两个参数，第一个参数是一个字符串，代表要监听的事件；第二个参数为在目标元素上监听到该事件时所触发的回调函数。关于这个回调函数，它接受一个参数，这个参数是被监听方法自动传入的事件对象，函数体即该事件触发时执行的行为。该事件对象的target属性即为触发本事件的元素本身。例如，我给这个按钮添加单击按下时的监听事件： btn.addEventListener('click', e =&gt; { e.preventDefault(); //阻止该行为的默认事件，比如提交表单、跳转网页等 console.log('clicked!');}); 常用事件有： click：单击 mouseover：鼠标移入、悬浮在上 mouseout：鼠标移出 submit：表单提交 以及其他的比如输入事件等等。 事件可以用于检查表单格式（我懒得举例子了，建议自己实现一下，获取DOM对象然后在函数体内确认）。 Ending 看到这里就把整个文章看完了，但是你以为你这就可以愉快的写js了吗？ 并不！ 你要是还想了解更多的JavaScript语言方面的东西，推荐你几本书：《ES6标准入门（第三版）》、《JavaScript高级程序设计（第四版）》和《JavaScript DOM编程艺术》。 Good luck, and good night!","categories":[{"name":"前端","slug":"前端","permalink":"https://www.legr4ndk.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.legr4ndk.top/tags/javascript/"}]},{"title":"鼠年的年终总结","slug":"S3Solve","date":"2021-02-12T05:43:31.000Z","updated":"2021-03-14T10:17:28.612Z","comments":true,"path":"2021/02/12/S3Solve/","link":"","permalink":"https://www.legr4ndk.top/2021/02/12/S3Solve/","excerpt":"","text":"这半年最大的变化就是从网安去了计算机吧，说实话我觉得转专业带给我的平时生活的改变不是很大，除了不怎么会和室友一起上课了以外，虽然认识了很多从别的专业一起汇聚而来的人，但是其实我发现，新班级也好，旧班级也好，经常一起聊天探讨的也没几个人，虽然都分到一个班里了，但是大家其实很多都还是陌生人。 从我的专业角度来说，这学期，我是真的下决心坚持写博客了。记录自己的所学真的很棒，把网上学到的东西再用自己的话写一遍下来，不仅说是算一种留念，也能说是标记所学，将来在同样的问题上也更不容易翻车。这学期主要是有一门特殊的课叫创新实践。我们转专业学生一开始是没得选的，只能在所剩无几的名额中挑选了。我跟了一个做网络应用的老师（来源于对人工智能算法的抵触，虽然还是没逃掉），前半学期看起来很人畜无害，真的就是最轻松最养老的老师了，直到学期末，老师让我们一起申报新苗和大创计划的时候，才是我们麻烦的开始。现在，我作为一个没有学过Java的人，也在努力攻克JavaWeb这块肉。 我觉得我一个根本不会被贩卖焦虑的人，在群里每次看到大佬发言然后我一点都不懂的时候，真的就会不由自主地放弃摸鱼的想法。这学期，说实话摸鱼很多，就没学什么技术吧，每次都跟自己找借口说都来了计算机了，不着急学慢慢来。可是到现在，周围同学都上升了很多，我都甚至有的时候不怎么敢去搭话吧哈哈哈。 从人际上说的话，这学期其实没认识几个人（指名字和脸能对上的），大部分的认识人我都是在上课的时候，但是呢，就没有几个一起上过课的同学吧，平时其实也不怎么聊得起来。重组班级的人际关系说实话，很难搞，大家都已经建立了一个大学的朋友圈了，我发觉很多人其实并不是很想再像大家都是陌生人一样建立关系了。我这学期班级活动确实参与了不少呢。哎，现在有点后悔其实，我当时要是参选个班委是不是可以认识更多同学呢。当然，这学期说实话也确实认识了几个很值得的朋友，希望他们也能来年继续多多指教吧。 这学期，我觉得我最和mainstream对立的地方就是，大家都在学Java和Go开发，只有我在学几乎没有人看好的.NET和.NET Core平台。我对微软从很久以前就有个很独特的感情吧，也不知道怎么回事，就这么入了巨硬的坑，我相信这玩意虽然大家都不看好，但是我好好学的话还是很有用的。我一直挺看好这个平台的，而且千金难买我愿意，希望我喜欢的平台也能越来越好吧。 来年啊，课真的就越来越多了，也要进入大三了，说早也不早，差不多就要到下一次大的抉择的时候了，希望来年这个时候，我已经定好目标了吧。不过在那之前，我还是得先继续好好学呢，课内也好，课外也好，项目也好，希望能顺利齐头并进吧。 好吧，我写到这儿我已经混乱了。 加油，奥里给！","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]},{"title":"解决Servlet页面中文乱码问题","slug":"ServletHandleWithChinese","date":"2021-02-08T13:44:47.000Z","updated":"2021-03-14T10:17:28.613Z","comments":true,"path":"2021/02/08/ServletHandleWithChinese/","link":"","permalink":"https://www.legr4ndk.top/2021/02/08/ServletHandleWithChinese/","excerpt":"","text":"年前诈尸再来记一笔。 resp.setCharacterEncoding(\"utf-8\");resp.setContentType(\"text/html\"); Servlet页面中文乱码的解法。 新年快乐，武运昌隆。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.legr4ndk.top/tags/java/"}]},{"title":"在JSP上使用JavaBean","slug":"JSPuseJavaBean","date":"2021-01-07T07:54:53.000Z","updated":"2021-03-14T14:24:38.803Z","comments":true,"path":"2021/01/07/JSPuseJavaBean/","link":"","permalink":"https://www.legr4ndk.top/2021/01/07/JSPuseJavaBean/","excerpt":"","text":"恁诸位新年好哇！ 记录一下怎么在JSP中使用JavaBean来避免写重复代码。 什么是JavaBeanJavaBean 是特殊的 Java 类，使用 Java 语言书写，并且遵守 JavaBean API 规范。 为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。 JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。 以上来自百度百科。总之，JavaBean就类似你事先写好一个类然后可以在多个不同的文件里引入而不需要在每个JSP文件里都单独声明这个类，可以减少很多的重复代码。 怎么写一个JavaBeanJavaBean的特征在上面已经有所提及了，下面以一个操作JDBC连接MySQL的JavaBean文件来示范如何写JavaBean。 package src; //包名import java.sql.*; //引入必需的库public class MysqlBean implements java.io.Serializable { //必须继承序列化接口 //以下为字段，全是私有的，这边的内容在使用时都不会改，所以没有getter和setter String DBDriver = \"com.mysql.jdbc.Driver\"; String ConnStr = \"jdbc:mysql://localhost:3306/$DBNAME\"; String MyUser = \"$USERNAME\"; String MyPassword = \"$PASSWORD\"; Connection conn = null; Statement stmt = null; ResultSet rs = null; public MysqlBean() { try { Class.forName(DBDriver); } catch (java.lang.ClassNotFoundException e) { System.err.println(\"DBconn (): \" + e.getMessage()); } } public ResultSet executeQuery(String sql) { rs = null; try { conn = DriverManager.getConnection(ConnStr, MyUser, MyPassword); Statement stmt = conn.createStatement( java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY); rs = stmt.executeQuery(sql); } catch (SQLException ex) { System.err.println(\"aq.executeQuery:\" + ex.getMessage()); } return rs; } public int executeUpdate(String sql) { { int count = 0; try { conn = DriverManager.getConnection(ConnStr, MyUser, MyPassword); Statement stmt = conn.createStatement(); count = stmt.executeUpdate(sql); stmt.close(); conn.close(); } catch (SQLException ex) { System.err.println(\"aq.executeQuery:\" + ex.getMessage()); } return count; } } public boolean closeConn() { try { if (rs != null) rs.close(); if (stmt != null) stmt.close(); if (conn != null) conn.close(); return true; } catch (SQLException ex) { System.err.println(\"closeConn:\" + ex.getMessage()); return false; } }} 在文件里完成必要的自定义（比如数据库名等）之后，将其保存为MysqlBean.java，然后使用javac命令将其编译为class文件（注意使用的Java版本需要与你运行tomcat的JRE版本相同），得到MysqlBean.class文件。这样，你就成功生成了一个JavaBean的类文件。 如何在JSP里面使用JavaBean部署JavaBean跟据你写的包名（比如我的是src包），将class文件放在&lt;JSP 项目&gt;/WEB-INF/classes/包名/文件夹中，例如本示例，class文件的位置为&lt;JSP 项目&gt;/WEB-INF/classes/src/MysqlBean.class。 调用JavaBean在JSP文件中，你可与使用&lt;jsp:useBean /&gt;标签来声明一个Bean。在声明一个Bean之后，这个JavaBean对象就变成脚本变量，可以在JSP里面直接使用。例如，要在JSP里使用上文提到的Bean，可以在JSP的开头加上： &lt;jsp:useBean id=\"MySQL\" class=\"src.MysqlBean\"/&gt; 其中，id代表Bean生成的对象的脚本变量的名字，class代表class文件所在的包和类名。 然后，你就可以在JSP中使用对象名（id）.方法名的方式来使用Bean内的方法了，例如我想使用上文的Bean中的execute方法，我可以使用MySQL.execute(\"\");。 特殊的getter、setter使用方法JavaBean中对于getter，setter函数使用特殊的标签来调用： &lt;jsp:setProperty name=\"bean的id\" property=\"属性名\" value=\"value\"/&gt; //调用setter()&lt;jsp:getProperty name=\"bean的id\" property=\"属性名\"/&gt; //调用getter() 上面那个类我没写getter和setter，就不演示了~ 先这样，JSP其实好像用的不多，以后还是Servlet吧。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.legr4ndk.top/tags/java/"}]},{"title":"JDBC提供的SQL操作API解析","slug":"JDBCexecuteCourse","date":"2020-12-23T10:55:28.000Z","updated":"2021-03-14T10:17:28.596Z","comments":true,"path":"2020/12/23/JDBCexecuteCourse/","link":"","permalink":"https://www.legr4ndk.top/2020/12/23/JDBCexecuteCourse/","excerpt":"","text":"DriveManager类DriveManager类有两个作用：注册驱动与获得数据库连接。 注册驱动使用registerDrive()方法实现，建立连接使用getConnection()方法实现。 registerDriver()在此类中有一段静态代码使用DriverManager.registerDriver(new Driver());完成了驱动的注册，所以已经无须手动调用此方法注册。 getConnection()此方法有三个String类型参数： url：与数据库连接的路径 user：与数据库连接的用户名 password：与数据库连接的密码 此处主要涉及URL的写法，比较特殊：jdbc:mysql://localhost:3306/$DB_NAME。其中： jdbc：连接数据库的协议 mysql：jdbc的子协议 localhost：连接的MySQL数据库服务器的主机地址。连接是本机就可以写成localhost，如果连接不是本机的，就需要写上连接主机的IP地址或域名。 3306：MySQL数据库服务器的端口号 $DB_NAME：数据库名称 该函数将会与数据库连接，如果连接成功则返回一个Connection类的数据库连接对象，若连接失败则返回null。 Connection类Connection类即数据库连接对象，有两大功能：创建用于执行SQL语句的对象和管理事务 以下三个方法可以创建用于执行SQL语句的对象： createStatement()：返回一个Statement对象，用于执行SQL prepareCall()：返回一个CallableStatement对象，用于调用数据库中存储过程 prepareStatement()：返回一个PreparedStatement对象，用于执行SQL并对SQL进行预处理以解决SQL注入漏洞。 以下三个无返回值的方法用于管理数据库事务： getAutoCommit()：将此连接的自动提交模式设定为给定状态 commit()：使所有上一次提交/回滚后进行的更改成为永久更改，并释放此Connection对象当前的数据库锁 rollback()：取消在当前事务中进行的所有更改，并释放此Connection对象当前的数据库锁 Statement接口Statement 接口提供了三种执行 SQL 语句的方法： executeQuery() executeUpdate() execute() 我们需要针对不同的SQL语句使用这三种方法 executeQuery()executeQuery()返回一个ResultSet类的对象，该对象是一个结果集。这个方法只能被用于查询语句，比如用的最多的SELECT语句，执行完语句后会返回代表查询结果的ResultSet对象。随后可以通过ResultSet类中的getString()方法来获取读到的数据。 executeUpdate()executeUpdate()常用于执行INSERT、UPDATE、DELETE、CREATE TABLE等非查询类语句。常用于数据库与数据表的增删改。它返回一个int类型的值，对于INSERT、UPDATE、DELETE等操作，会返回数据表中受影响的行数；对于CREATE TABLE等的操作，它的返回值总为0。 execute()execute()可以用于执行任何SQL语句。它的返回值是一个bool类型的值，来表明该SQL语句是否返回了ResultSet对象。如果执行后得到的第一个结果是ResultSet则返回true，否则返回false。返回为true后可以利用getResultSet()方法来获取对应的ResultSet类的结果集对象。此函数更复杂，推荐仅当不知道SQL语句的具体类型时使用此函数来执行。 ResultSet接口ResultSet类是查询的结果集。主要使用两个方法来进行操作：getString()和next()。 getString()getString()方法接受一个String类型的参数，作为要获得的字段的字段名。它会返回一个String类型的值，就是ResultSet对象当前指向行的所求字段的值。此方法多用于处理查询所得值。 next()next()方法会将该ResultSet对象所指向行的光标向下移动一行。它返回一个bool类型的值，当光标已经不能下移时会返回false，否则返回true并下移光标。此方法可以用于遍历查询所得数据或者判断查询是否有查到值。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.legr4ndk.top/tags/java/"}]},{"title":"NPUCTF HappyCheckInVerification WP","slug":"HappyCheckinNPUWP","date":"2020-12-17T15:39:52.000Z","updated":"2021-03-15T14:04:17.810Z","comments":true,"path":"2020/12/17/HappyCheckinNPUWP/","link":"","permalink":"https://www.legr4ndk.top/2020/12/17/HappyCheckinNPUWP/","excerpt":"","text":"本文搬运自我写在别处的文章 题目信息题目链接：https://pan.baidu.com/s/1c_Y0WJmzTdNVyYgjHmUI_Q 提取码: qhh8 Hint：关注西北工业大学信息安全协会微信公众号NWPUSEC 解题过程下载得到无后缀名的名叫zip的文件，把后缀名改成.zip，提示文件已损坏，故用16进制文件查看器检查文件（本文使用HxD）。 这是此文件的文件头，可见zip文件的文件头标记504B0304不在文件头部，反而是zip文件的目录结束标识（504B0506）在文件头。把从00000000-00000015的部分移动至文件尾，保存重新打开，就可以看到zip文件的文件了。此zip文件带有伪加密，可以通过搜索的方法搜索zip文件头标记504B0102，在其偏移5字节的地方改为00（要改两处）来去除伪加密。 保存解压即可获得一个mp4视频和一个二维码文件。 视频文件是喜闻乐见的黑人抬棺材的视频，但是在视频中有两个部分被植入了拨号音。截取这段音频降噪，使用dtmf2num工具识别拨号音，得到电话号码13418070885。 再来看二维码： 这是获取的二维码图像，可见二维码的三个定位符均被抹去，所以无法扫描。通过PS添加三个定位符，得到一个二维码。扫描得到以下文字： flag{this_is_not_flag}三曳所諳陀怯耶南夜缽得醯怯勝數不知喝盧瑟侄盡遠故隸怯薩不娑羯涅冥伊盧耶諳提度奢道盧冥以朋罰所即栗諳蒙集皤夷夜集諳利顛呐寫無怯依奢竟#￥#%E68BBFE4BD9BE68B89E6A0BCE79A84E5A7BFE58ABFE59CA8E69C80E5908E32333333||254333254242254338254342254231254338254345254432254238254643254236254145254239254441254437254234254232254131254236254245253244253244254343254438254330254341254336254435…sadwq#asdsadasf faf$use$dasdasdafafa_$ba##se64$ this is not flag 后面的第一部分哪些诡异的文字，是“与佛论禅”编码。最前面加上“佛曰：”，得到一句话：“都说了这不是佛拉格了”。 第二部分是一段十六进制数，把它转成字符串，得到：“拿佛拉格的姿势在最后”。 第三段也是一串十六进制数，把它转成字符串，得到：%C3%BB%C8%CB%B1%C8%CE%D2%B8%FC%B6%AE%B9%DA%D7%B4%B2%A1%B6%BE%2D%2D%CC%D8%C0%CA%C6%D5 肉眼可见它是url编码，直接转换，得到一串字符：“没人比我更懂冠状病毒–特朗普”。 最后一段没啥花头了，就是看到了use base64，是时候把刚刚从拨号音得到的电话号码用BASE64编码发到公众号，得到一段诡异的音频。 这是一段sstv的音频，里面有个图，直接使用软件MMSSTV，播放这段音频给电脑听（推荐电脑内录），你就可以看到孙狗的笑容（天皇遗照）。flag就写在孙🐕的胸上。 结束","categories":[{"name":"安全","slug":"安全","permalink":"https://www.legr4ndk.top/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://www.legr4ndk.top/tags/ctf/"}]},{"title":"实现网页登陆的逻辑","slug":"BackEndLoginCourse","date":"2020-12-17T14:46:26.000Z","updated":"2021-03-14T10:17:28.582Z","comments":true,"path":"2020/12/17/BackEndLoginCourse/","link":"","permalink":"https://www.legr4ndk.top/2020/12/17/BackEndLoginCourse/","excerpt":"","text":"实现登陆逻辑至少涉及两个方面，登陆与注册 本文使用SQL语言的MySQL dialect 登陆（Log in）登陆主要是实现将用户提交的含有用户名uname和密码passwd的表单提交给数据库对比，如果发现此条记录在数据库中存在且合法，则返回登陆成功，否则返回登陆失败，需要请求用户重新提交。 这边主要注意的是一个点，在查询的时候我们会使用SQL语句去数据库查询，一般想到的逻辑应该是去查询得到用户名对应的密码，然后再去对比用户提交的密码与数据库返回的密码是否一致。即使用了以下的SQL代码： SELECT passwd FROM user_info WHERE uname = $UNAME; 在登陆成功情况下两者并无任何区别，但实际上这个方式有一个巨大的缺陷：在登陆失败时，这种数据处理方式割裂了“用户名输入错误”（此用户名不存在）与“查到用户名，但密码错误”两种情况。如果这两种不同的情况被以不同形式返回到前端（比如分别提示“用户名错误”或“密码错误”，那么就很容易被通过“撞库攻击”而“撞”出网站的许多用户的用户名，即使他们并不知道每个id的密码，这无疑方便了攻击者通过id暴力穷举或者使用密码字典的方式获取密码。 正确的处理方法应该是连着用户名和密码一起放入SQL语句里去查询，比如： SELECT * FROM user_info WHERE uname = $UNAME AND passwd = $PASSWD; 然后通过执行了该语句之后是否具有返回数据的方式来判断用户试图登陆的账号密码对是否被注册且有效。如果成功，则结果同上，但是若登陆失败，那么它只能体现用户名和密码错误，安全性相对更高。 注册（Register）注册的验证涉及三个步骤： 验证提交的密码的合法性 验证提交的username的唯一性 插入提交的用户名与密码到数据库。 提交密码的合法性判断无非是判断密码长度、判断是否含有不合法字符、判断密码格式是否合规。使用各种语言的字符串处理手段乃至正则表达式都可以直接实现，此处不再赘述。提供一个常见的网站密码格式要求：以字母开头，必须包含大/小写字母、数字、一般符号的至少三种，长度在8-64位之间。 提交的用户名的唯一性判断可以通过SQL语言的SELECT语句，即查询语句来实现，比如： SELECT * FROM user_info WHERE uname = $UNAME; 然后通过执行该语句后是否有查询到的数据来判断这个用户名是否被注册过，以决定是否要为此组提交的数据执行注册（即插入数据表）的操作。 值得一提的是，你可与为某一列设置UNIQUE来保证这列的数据一定不相同，此情况下，若插入重复的username将会导致MySQL抛出异常，需要对这一异常进行处理。 插入提交的数据到数据库在我们确认用户提交的数据在数据库中不会出现问题之后，我们便可以把用户提交的键值对插入数据表中了。插入操作使用INSERT来实现，例如： INSERT INTO user_info (uname, passwd) VALUES ($UNAME, $PASSWD); 此方法会把$UNAME与$PASSWD以一条新记录的方式插入到对于数据表中。一般在这种情况下，它便不再会出现插入异常了。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://www.legr4ndk.top/tags/sql/"}]},{"title":"在JSP上连接MySQL数据库","slug":"JSPconnectMySQL","date":"2020-12-16T12:53:36.000Z","updated":"2021-03-14T10:17:28.603Z","comments":true,"path":"2020/12/16/JSPconnectMySQL/","link":"","permalink":"https://www.legr4ndk.top/2020/12/16/JSPconnectMySQL/","excerpt":"","text":"驱动准备你需要下载Java Database Connector for MySQL，本文提供一个来自于菜鸟教程的jar包，版本号为5.1.39。点击此处下载。将此文件放入tomcat目录的lib文件夹中。 配置Tomcat的连接池不配置连接池，在使用驱动包的时候tomcat会返回500 Internal Server Error，提示ClassNotFoundException（异常：找不到类），可以通过配置它的连接池来解决问题。 修改server.xml修改位于tomcat目录下的conf/server.xml,找到&lt;GlobalNamingResources&gt;标签，在此标签内我们需要添加内容。 &lt;!--这个标签是已经存在的，找到它然后编辑即可--&gt;&lt;GlobalNamingResources&gt; &lt;!--这部分为文件自带内容，不作改动--&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;!--配置mysql数据库的连接池, 需要做的额外步骤是将mysql的Java驱动类放到tomcat的lib目录下--&gt; &lt;Resource name=\"jdbc/mysqlds\" auth=\"Container\" type=\"javax.sql.DataSource\" username=\"$UNAME\" password=\"$PWD\" maxIdle=\"30\" maxWait=\"10000\" maxActive=\"100\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/$DBNAME\" /&gt; &lt;/GlobalNamingResources&gt; 其中 $DBNAME位置放你的数据库名，$UNAME位置放置你的数据库用户名，$PWD位置放置你的数据库密码 修改context.xml修改位于tomcat目录下的conf/context.xml，在&lt;Context&gt;标签内我们需要添加内容。 &lt;Context&gt; &lt;!--这部分为文件自带内容，不作改动--&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;${catalina.base}/conf/web.xml&lt;/WatchedResource&gt; &lt;!--以下为在本文件中的添加内容--&gt; &lt;ResourceLink name=\"jdbc/mysqlds\" global=\"jdbc/mysqlds\" type=\"javax.sql.DataSource\"/&gt; &lt;/Context&gt; 修改web.xml修改位于tomcat目录下的网页项目文件夹下的WEB-INF/web.xml文件，在 &lt;web-app&gt;内我们需要添加内容。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--以下为在本文件中的添加内容--&gt; &lt;resource-ref&gt; &lt;description&gt;mysql数据库连接池&lt;/description&gt; &lt;res-ref-name&gt;jdbc/mysqlds&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;res-sharing-scope&gt;Shareable&lt;/res-sharing-scope&gt; &lt;/resource-ref&gt; &lt;/web-app&gt; 配置之后，需重启tomcat。之后连接数据库的时候就不会出现ClassNotFoundException了。 JSP连接数据库给出一段DEMO： &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.sql.*\"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;通过JSP打开数据表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Class.forName(\"com.mysql.jdbc.Driver\"); //驱动程序名 String url = \"jdbc:mysql://localhost:3306/$DBNAME\"; //数据库名 String username = \"$UNAME\"; //数据库用户名 String password = \"$PWD\"; //数据库用户密码 Connection conn = DriverManager.getConnection(url, username, password); //连接数据库并返回连接状态 if(conn != null){ out.print(\"数据库连接成功！\"); out.print(\"&lt;br /&gt;\"); Statement stmt = null; ResultSet rs = null; String sql = \"SELECT * FROM $TABLENAME;\"; //查询语句 stmt = conn.createStatement(); rs = stmt.executeQuery(sql); out.print(\"查询结果：\"); out.print(\"&lt;br /&gt;\"); out.println(\"id\"+\" \"+\"uname\"+\" \"+\"pwd\"); out.print(\"&lt;br /&gt;\"); while (rs.next()) { out.println(rs.getString(\"id\")+\" \"+rs.getString(\"uname\")+\" \"+rs.getString(\"passwd\")+\"&lt;br /&gt;\"); //将查询结输出 } } else{ out.print(\"连接失败！\"); } %&gt; &lt;/body&gt;&lt;/html&gt; 其中 $DBNAME位置放你的数据库名，$UNAME位置放置你的数据库用户名，$PWD位置放置你的数据库密码，$TABLENAME位置放置你操作的数据表表名。 ResultSet.getString()函数接受字段名作为参数返回对应一条记录的该字段的值，可以以此读取信息。 上方Demo实现了读取一个数据表中id、uname、pwd字段的所有数据的JSP代码。 通过更改SQL语句可以实现更多的操作，此处不再赘述。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.legr4ndk.top/tags/java/"}]},{"title":"于Ubuntu 18.04上配置Java Server Pages运行环境","slug":"JSPenvironment","date":"2020-12-11T10:16:45.000Z","updated":"2021-03-14T10:17:28.599Z","comments":true,"path":"2020/12/11/JSPenvironment/","link":"","permalink":"https://www.legr4ndk.top/2020/12/11/JSPenvironment/","excerpt":"","text":"更新系统sudo apt update #更新软件源sudo apt upgrade #更新软件包 Web服务器应用Apachesudo apt install apache2 -y #安装apache2sudo /etc/init.d/apache2 start #启动apache2sudo /etc/init.d/apache2 stop #关闭apache2 Java运行时与JDKsudo apt install openjdk-11-jdk-headless #安装openjdk-11 Java应用服务器Tomcatsudo apt install git #安装git（作为wget的依赖）sudo apt install wget #有的系统自带wget，就不用装wget https://mirrors.cnnic.cn/apache/tomcat/tomcat-9/v9.0.40/bin/apache-tomcat-9.0.40.tar.gz #于cnnic镜像站下载tomcat的预编译二进制文件tar -xzvf apache-tomcat-9.0.40.tar.gz #解压压缩文件sudo mv ./apache-tomcat-9.0.40 /usr/local/tomcat #移动所有文件到/usr/local目录下的tomcat文件夹中sudo chmod -R 755 /usr/local/tomcat #赋予权限cd /usr/local/tomcat/bin #进入存放tomcat的文件夹vim ./startup.sh #编辑startup.sh脚本# 最后一行加上：#tomcatexport TOMCAT_HOME=/usr/local/tomcat# 保存退出sudo /usr/local/tomcat/bin/startup.sh #启动tomcatsudo /usr/local/tomcat/bin/shutdown.sh #关闭tomcat 数据库MySQLsudo apt-get install mysql-server #安装mysql-serversudo mysql -uroot -p #root用户登陆mysql-clinet，默认无密码#执行以下操作以自订密码use mysql;update user set authentication_string=PASSWORD(\"自定义密码\") where user='root';update user set plugin=\"mysql_native_password\";flush privileges;quit;#退出mysqlsudo /etc/init.d/ mysql start #启动mysqlsudo /etc/init.d/ mysql stop #关闭mysqlsudo /etc/init.d/ mysql restart #重启mysql#要创建新的mysql用户CREATE USER 'username'@'host' IDENTIFIED BY 'password';#username：用户名，host：指定该用户在哪个主机上可以登陆，本地用户用localhost，从任意远程主机登陆，可以使用通配符%，password：用户密码 启动Apache和Tomcat之后可以在80端口看到apache的it works界面，8080端口可以看到位于 /usr/local/tomcat/webapps/ROOT/ 的网页，可以自己放jsp文件于次文件夹，以对于域名的相对地址访问。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"server","slug":"server","permalink":"https://www.legr4ndk.top/tags/server/"}]},{"title":"在网页文件中引入Bootstrap","slug":"IncludeBootstrap","date":"2020-12-09T15:27:58.000Z","updated":"2021-03-14T10:17:28.598Z","comments":true,"path":"2020/12/09/IncludeBootstrap/","link":"","permalink":"https://www.legr4ndk.top/2020/12/09/IncludeBootstrap/","excerpt":"","text":"文件均使用了在Staticfile CDN上的镜像 在文件中引入Bootstrap3的库以下内容请放入html文件的&lt;head&gt;与&lt;/head&gt;之间： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;!-- 引入 Bootstrap --&gt;&lt;link href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 以下内容请放入html文件的&lt;body&gt;与&lt;/body&gt;之间： &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- 包括所有已编译的插件 --&gt;&lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; Bootstrap4版的库文件链接：以下内容请放入html文件的&lt;head&gt;与&lt;/head&gt;之间： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\"&gt;&lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.staticfile.org/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 以下内容请放入html文件的&lt;body&gt;与&lt;/body&gt;之间： &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js --&gt;&lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js\"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;&lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.legr4ndk.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://www.legr4ndk.top/tags/bootstrap/"}]},{"title":"注 入 怨 念","slug":"EssayP","date":"2020-11-27T15:23:06.000Z","updated":"2021-03-14T10:17:28.586Z","comments":true,"path":"2020/11/27/EssayP/","link":"","permalink":"https://www.legr4ndk.top/2020/11/27/EssayP/","excerpt":"","text":"最近看到一首很有感觉的诗，且放在这边： 我把子弹穿破胸膛我的眼睛被鲸鲨咬碎口腔被灌满砒霜溃疡双手砍断滚在床下少女把头颅盛走你就静静看着我把我泡在福尔马林永垂不朽 活在福尔马林里，也未尝不是永垂不朽。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]},{"title":"马保国日语版","slug":"masensei","date":"2020-11-24T13:36:30.000Z","updated":"2021-03-14T10:17:28.616Z","comments":true,"path":"2020/11/24/masensei/","link":"","permalink":"https://www.legr4ndk.top/2020/11/24/masensei/","excerpt":"","text":"原视频见于Bilibili 此处只是靠听力和字幕扒取了台词 止增笑耳 こんにちは 俺(おれ)は太極(たいきょく)マスター 马(mǎ) 保(bǎo) 国(guó) 今(いま) 友達(ともだち)が「先生(せんせい)どうしたの」と 俺(おれ)は「何(なに)が」と 写真(しゃしん)が何枚来(なんまいき)た 俺見(おれみ)たと お！ それは昨日(きのう) 二人(ふたり)の若(わか)もん ３０ぐらい 一人体重(ひとりたいじゅう)９０キロ 一人体重(ひとりたいじゅう)８０キロ 彼(かれ)ら 一人(ひとり) 「俺(おれ)、ジム(じむ)で運動(うんどう)、首(くび)がひねった、馬先生(うませんせい)、太極(たいきょく)を気功(きこう)を、教(おし)えてくれない？」 俺(おれ)は「いい」と おれは「君(きみ)の筋(きん)トレ效(き)かない」 彼(かれ)は不満(ふまん) 俺(おれ)は「子供(こども)よ、両手(りょうて)で俺(おれ)の指(ゆび)を折(お)ってみ」 折(お)れない 彼(かれ)は「役立(やくだ)てない」と 俺(おれ)は「役立(やくだ)てる」と これ「化力(かりょく)」 カンフー技(わざ) 四両(よんりょう)で千斤(せんきん)を制(せい)する ２００斤(きん)の英国力士(えいこくりきし) 俺(おれ)の指(ゆび)に勝(か)てない あ！ 彼(かれ)はやってみみと 俺(おれ)はオッケーと そして彼(かれ)ガーと立(た)て 速(はや)いあ！ そして続(つづ)いて 先ず左蹴(ひだりしゅう) 「ん」 次右(つぎみぎ)サイド 最後左(さいごひだり)ジャブ 俺全部(おれぜんぶ)ガードした ガードした！ ガードしてもちろん伝統(でんとう)カンフーは切磋(せっさ)だけ 右手鼻(みぎてはな)につけて 打(う)たない 俺笑(おれわら)って 手(て)を引(ひ)こうと だからここで 伝統(でんとう)カンフーの切磋琢磨(せっさたくま)で 彼(かれ)はすでに負(ま)けた もし力(ちから)いれたら ワンパンチで彼(かれ)の鼻(はな)を折(お)った 鼻(はな)につけて打(う)たない かれ認(みと)め 俺(おれ)は彼(かれ)の顔(かお)に行(い)った 彼(かれ)は鼻(はな)がつけられたのを知(し)らずに 俺(おれ)は顔(かお)に行ったと認(みと)めた 俺(おれ)は手(て)を引(ひ)いてやめた 彼(かれ)は不意打(ふいう)ち 左(ひだり)ジャブ俺(おれ)の顔(かお)を 俺油断(おれゆだん)したら、「迷(まよ)うさ」（没有闪） 彼(かれ)の左(ひだり)パンチ俺(おれ)の目(め)… 右目(みぎめ)に擦(す)った でも大丈夫(だいじょうぶ) 彼(かれ)も写真(しゃしん)で言(い)った 二分(にふん)ほど以降(いこう) その場(ば)で涙出(なみだで)た 目(め)を覆(おお)って 俺(おれ)は「止(や)めて」と 二(に)分(ふん)以(い)ほ…二(に)分(ふん)以(い)降(こう) 治(なお)った 俺(おれ)はガキお前(まえ) ジャブじゃ無駄(むだ) しぶとう 彼(かれ)は「馬先生(ませんせい)御免御免(ごめんごめん)、俺(おれ)は素人(しろうと)」 「俺(おれ)は無鉄砲(むてっぽう)」と 彼(かれ)は無鉄砲(むてっぽう)じゃないんだ 前(まえ)キック、サイドキック 左(ひだり)パンチ、練(ね)れ者(もの) あとで彼(かれ)は三(さん)四(よん)年(ねん) タイ拳(こぶし)お習(なら)った やはり 準備万端(じゅんびばんたん)（有bear来） これら 若造(わかぞう) 無駄無駄(むだむだ)（不讲武德） だ～ます 不(ふ)意(い)～打(う)ち 六(ろく)十(じゅう)九(きゅう)歳(さい)の老(ろう)人(じん) いいのか？よくない 小(こ)僧(ぞう) よくお前(まえ)は 恥(は)ず忘(わす)（耗子尾汁）れてます 今後(こんご) このようなずる 小賢(こざか)しい 武林(ぶりん)は和(わ)を大事(だいじ) ようじゃ無駄(むだ)（要讲武德） 八百(はっぴゃく)るな～俺(おれ)と（不要搞窝里斗） ありがとうね！ 已经更新完了，还加了汉字的假名注音hh 可以拿去照着这个台本配音玩了 有部分是字幕里有但是那人没念出来的，我就给删了 不是标准日语，很多语法错误，但是读着好玩就是了😂","categories":[{"name":"耍","slug":"耍","permalink":"https://www.legr4ndk.top/categories/%E8%80%8D/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]},{"title":"C#常见控件（WPF平台）","slug":"CsharpCommonControls","date":"2020-11-22T10:48:47.000Z","updated":"2021-03-14T10:17:28.584Z","comments":true,"path":"2020/11/22/CsharpCommonControls/","link":"","permalink":"https://www.legr4ndk.top/2020/11/22/CsharpCommonControls/","excerpt":"","text":"C#的WinForm编程真的是和Visual Basic一毛一样的体验 ——比隔壁C++的WinForm不知道高到哪里去了（ 控件（Control）是WinForm的基本元素 Brief IntroductionForm控件有一个系统自动生成的一个类实例化的对象（默认叫Form1），该类自带Load事件的函数。此类定义于Form1.cs和Form1.Design.cs中。于Program.cs中另有Program.cs内定义了Main函数作为程序的起点。 常见的控件有几个基本共有的属性，如： Size：是一组共两个值，用于确定对象的宽度和高度 (Name)：相当于该对象在程序中的变量名 AutoSize：如果为True则可能造成控件某些维度的手动大小调整不可用 Location：是一组两个值，用于确定对象在窗体的位置(x,y)，窗体左上顶点为坐标原点，向右为+x，向下为+y Label（标签）控件为控件和窗体的其它组成部分提供标识，通常用于提供描述性文字 Label控件由Label类描述，Label类继承自Control类，它在名字空间System.Windows.Forms中。 Label常用属性 AutoElipsis：获取或者设定一个值，指示是否要在Label右边缘显示省略号表示文本超过指定长度，否则文本将被直接截断 AutoSize：获取或者设定一个值，指示是否自动调整控件大小以显示完整内容 BorderStyle：获取或设置控件的边框样式 Image：获取或设置显示在Label上的图像 Text：获取或设置与此控件相关联的文本，即显示在Label上的文本 TextAlign：获取或设置Label中文本的对齐方式 TextBox（文本框）控件TextBox中的文本可以被编辑，而Label中的不行。 TextBox类所在的名字空间为System.Windows.Forms。 TextBox常用属性 AcceptsReturn：获取或设置一个值，该值指示在多行TextBox控件中按Enter键时，是在控件中创建一行新文本还是激活窗体的默认按钮，比如用于选择按回车是输入完了还是换一行 AcceptsTab：获取或设置一个值，该值指示在多行TextBox控件中按Tab键时，是在控件中键入一个Tab字符还是按选项卡的顺序将焦点移动到下一个控件 BackColor：获取或设置控件的背景色 Focused：获取一个值，该值指示控件是否有输入焦点 Font：获取或设置控件显示的文字的字体 Multiline：获取或设置一个值，该值指示此控件是否为多行TextBox控件 PasswordChar：获取或设置字符，该字符用于屏蔽单行TextBox控件中的密码字符 ReadOnly：获取或设置一个值，该值指示文本框中的文本是否为只读 RightToLeft：获取或设置一个值，该值指示是否将控件的元素对齐以支持从右向左的字体的区域设置 SelectedText：获取或设置一个值，该值指示控件中当前选定的文本 Text：字符串，获取或设置TextBox中的当前文本 TextAlign：获取或设置控件中文本的对齐方式 TextLength：获取或设置控件中文本的长度 WordWrap：指示多行文本框控件在必要时是否自动换行到下一行开始 TextBox常用事件 Click：鼠标单击控件时发生 Enter：鼠标进入控件区域时发生 GotFocus：在控件得到焦点时发生 KeyDown：在控件有焦点时按下按键时发生 KeyUp：在控件有焦点时释放按键时发生 Leave：在控件失去焦点时发生 LostFocus：在控件失去焦点时发生 TextChanged：在控件的Text属性值更改时发生（文本被改变 Button（按钮）控件用户可以单击按钮控件触发程序动作。 Button继承自ButtonBase类，ButtonBase继承自ContentControl类，ContentControl类继承自Control类。 Button常用属性 ClickMode：获取或设置Click事件何时发生，ClickMode有3种 悬停，鼠标悬停在该按钮上时激发此按钮 按下，鼠标在该按钮上按下时激发此按钮 释放，鼠标在该按钮上按下后，释放时激发此按钮 IsCancel：获取或设置一个值，指示该Button控件是否为取消按钮。用户可以通过ESC键激活取消按钮 IsDefault：获取或设置一个值，指示该Button控件是否为默认按钮。用户可以通过Enter键调用默认按钮 Button常用事件 Click：按钮被按下时发生（最常用） 选项控件选项的作用是跟据用户的实际情况在程序运行时调整程序的状态或行为。 选项控件的分类 GroupBox（组框） Panel（面板） RadioButton（单选按钮） CheckBox（复选框） RadioButtonRadioButton（单选按钮）控件是用来让用户在一组选项中选定一项且只能选定一项。 若窗体内仅有一组RadioButton控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，RadioButton应该被放置到一个GroupBox（组框）控件内进行分组。 RadioButton常用属性 Text：设定该RadioButton旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定RadioButton的状态（bool类型，True-被选中，False-未被选中（缺省设置）） RadioButton常用事件 CheckedChanged：Checked属性改变时发生（默认事件） 在VS中，双击单选按钮控件，会自动添加默认事件的事件处理函数 CheckBoxChechBox（复选框）控件是让用户在一组选项中选定一项或多项。 若窗体内仅有一组CheckBox控件时，可以将它们直接放置在这个窗体内。 当有两组或多组选项时，CheckBox应该被放置到一个GroupBox（组框）控件内进行分组。 CheckBox常用属性 Text：设定该CheckBox旁边的文本内容 CheckAlign：设定控件按钮与文本的位置关系（对齐方式） Checked：由它设定CheckBox的状态（bool类型，True-被选中，False-未被选中（缺省设置）） CheckState：指示CheckBox目前的状态，有三个取值 Checked：表示被选中状态 Unchecked，表示未被选中状态 Indeterminate，表示不可用状态（此状态当ThreeState属性为True时有效） CheckBox常用事件 CheckedChanged：Checked属性改变时发生（默认事件） CheckedStateChanged：CheckedState属性改变时发生 GroupBoxGroupBox（组框）是一个容器类控件。 你可以将一组控件放入GroupBox来分类。 组框可以显示标题（文本），但是它没有滚动条。 边框一般比较细。 GroupBox常用属性 Controls：组框包含的控件集 Text：在组框顶部显示的标题文本 PanelPanel（面板）与GroupBox类似，也是一个容器类控件。 你也可以将一组控件放入Panel来分类。 面板可以包含滚动条，但是它没有标题。 边框可以通过相关边框属性来调节。 Panel常用属性 AutoScroll：当面板由于太小而无法显示所有控件时，这个属性指定是否出现滚动条，默认值为False BorderStyle：设置面板的边界样式，默认为None，其他选项有Fixed3D和FixedSingle Controls：面板包含的控件集 感觉差不多了，就这样吧！","categories":[{"name":"客户端","slug":"客户端","permalink":"https://www.legr4ndk.top/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://www.legr4ndk.top/tags/csharp/"}]},{"title":"Cpp中的多态","slug":"CppPolymorphism","date":"2020-10-23T12:02:51.000Z","updated":"2021-03-14T10:17:28.587Z","comments":true,"path":"2020/10/23/CppPolymorphism/","link":"","permalink":"https://www.legr4ndk.top/2020/10/23/CppPolymorphism/","excerpt":"","text":"多态是面向对象编程内极为重要的一种特征，它能极大的简化我们的代码 先来看一段类的原型 class Animal //基类{public: void voice() { std::cout &lt;&lt; \"Voiceless\" &lt;&lt; std::endl; //不知道该叫啥 };};class Dog : public Animal //狗派生类，继承了Animal{public: void voice() { std::cout &lt;&lt; \"Woof\" &lt;&lt; std::endl; //汪汪叫 }};class Cat : public Animal //猫派生类，继承了Animal{public: void voice() { std::cout &lt;&lt; \"Meow\" &lt;&lt; std::endl; //喵喵叫 }}; 我们可以看到，基类和派生类中都有函数voice()，它可以让不同的动物发出不同的叫声，其中，Dog类和Cat类的voice()函数是覆写了基类中的同名函数。 当然，还可以有很多基于Animal类的派生类，都可以有叫声，但是我们如果想统一一下让它们叫的方法，比如用个train函数，传入对象或者它的指针就可以自动调用它的voice函数。虽然Cpp支持重载函数，但是为每个不同的类各写一个这样的函数，工作量不仅大，而且枯燥。多态就是帮我们解决这个问题的。 多态 Polymorphism 表现方式有两种 重载多态，比如函数重载（本文不介绍了），属于静态联编 子类型多态，属于动态联编，就是我接下来要说的那些 子类型多态有两个要点： 虚函数 函数覆写override 我们来区分涉及继承链情况下的两种联编： 通过派生类对象访问同名函数，是静态联编 通过基类对象的指针访问同名函数，是静态联编 通过基类对象的指针或引用访问同名虚函数，是动态联编 那我们现在改一下原来的类的定义让它符合子类型多态的要求 class Animal{public: virtual void voice() //此函数声明为虚函数后，派生类中无须再注明 { std::cout &lt;&lt; \"Voiceless\" &lt;&lt; std::endl; };};class Dog : public Animal{public: void voice() override //覆写了voice函数 { std::cout &lt;&lt; \"Woof\" &lt;&lt; std::endl; }};class Cat : public Animal{public: void voice() override //覆写了voice函数 { std::cout &lt;&lt; \"Meow\" &lt;&lt; std::endl; }}; 那么还是刚刚那个例子，我们设计一个train函数 void train(Animal animal){ animal.voice();} 使用这个函数，你会发现无论你往参数里塞了什么阿猫阿狗的对象，输出的永远是“Voiceless”，这便是静态联编的问题了，它使用的是基类的对象而非基类对象的指针或引用，你需要把train修改成这样： void train(Animal&amp; animal){ animal.voice();}//或者这样void train(Animal* animal){ animal-&gt;voice();} 然后你的子类对象在调用这个train函数之后就可以正常发出正确的声音了 需要注意的是，如果voice函数不是虚函数，那么即使你用了派生类对象的指针、引用，只要那个进入函数的东西的类型是基类，它就会调用基类的函数 一句话总结一下，就是：函数虚，看对象；函数实，看类型。 但是，这个东西它也有问题，就是你使用基类的指针（或者引用）指向了派生类的对象的时候，你只能调用派生类的虚函数，无法调用非虚函数，例如我改一下Dog类的定义： class Dog : public Animal{public: void voice() override { std::cout &lt;&lt; \"Woof\" &lt;&lt; std::endl; } void foo() //这个不是虚函数了 { std::cout &lt;&lt; \"Foo!\" &lt;&lt; std::endl; }}; 但是我在main函数里这样定义： Animal ptr;Dog dog = new Dog();ptr = &amp;dog;ptr-&gt;voice(); //调用的是dog对象的voice函数ptr-&gt;foo(); //无法调用，No member named foo in Animal Animal类的指针虽然指向了dog，但是它将无法调用dog的非虚函数，但是如果我们偏要调用属于子类的非虚函数呢？ Introducing dynamic_cast! Cpp的dynamic_cast&lt;&gt;运算符可以把基类类型的指针转换为派生类的类型的指针，就可以使调用子类的非虚函数称为可能，方法如下 ptr-&gt;foo(); //它出了问题dynamic_cast&lt;Dog*&gt;(ptr)-&gt;foo(); //正常调用！ 虽然建议在任何基类与派生类间的指针、引用的类型转换都使用dynamic_cast运算符，但是实际上，派生类的指针（引用）转为基类类型的指针（引用）可以不使用该运算符而隐式转换，而基类的指针（引用）转为派生类类型的指针（引用）必须显式使用该运算符以完成类型转换。 比如我们有： Animal animal;Animal* pa;Cat cat;Cat* pc;pa = &amp;cat; //可以隐式转换（下转上）pc = dynamic_cast&lt;Cat*&gt;(animal); //必须显式转换（上转下） 多态就先写这么多~","categories":[{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://www.legr4ndk.top/tags/cpp/"}]},{"title":"Markdown语法教程","slug":"MarkdownCourse","date":"2020-10-18T14:11:22.000Z","updated":"2021-06-07T10:04:05.524Z","comments":true,"path":"2020/10/18/MarkdownCourse/","link":"","permalink":"https://www.legr4ndk.top/2020/10/18/MarkdownCourse/","excerpt":"","text":"这篇文章简单介绍下Markdown的基础语法，对写文章，记笔记有用 注意，Markdown排版支持大量html标签 # 大小标题（使用标题可以生成大纲） 使用=和-标记一号和二号标题 我是大标题我是小标题我是大标题=========在第二行书写多个=，为一级标题我是小标题---------------在第二行书写多个-，为二级标题 使用#标记1-6级标题 我是H1我是H2我是H3我是H4我是H5我是H6# 我是H1## 我是H2### 我是H3#### 我是H4##### 我是H5###### 我是H6是几级标题就打几个#，再跟上一个空格 特殊格式我是斜体 我是粗体 我是斜粗体 *我是斜体***我是粗体*****我是斜粗体***注意，星号可以用下划线替代 分割线，就像这样 ***___---你需要使用连续三个及以上的星号、减号或者下划线来创建分割线，每个符号间可以有空格 下划线和删除线 我是下划线 我是删除线 &lt;u&gt;我是下划线&lt;/u&gt;~~我是删除线~~下划线使用html的u标签实现，删除线在前后加上两个~即可 列表 第一项 第二项 第一项 第二项 * 第一项* 第二项无序列表使用星号（或者加号、减号）跟一个空格1. 第一项2. 第二项有序列表使用数字加一个小数点以跟一个空格 区块 这是区块 &gt; 这是区块大于号加一个空格 代码块 这是代码块​```[language]# Codes here​```前后三个点包围的区块，第一块三个点后面可以跟上语言的名称 超链接 这是指向我的博客的超链接 [这是指向我的博客的超链接](https://legr4ndk.github.io/)方括号里是显示的字，小括号里是要跳转的链接当然你也可以使用html的&lt;a&gt;标签 图片 ![龙龙快动啊](http://www.legr4ndk.top/img/loooong.jpg)一个感叹号直接接中括号，里面是注释文本，后面跟的小括号里面是图片路径当然你也可以使用html的&lt;img&gt;标签 表格 表头 表头 表头 表头 单元格 左对齐 右对齐 居中对齐 | 表头 | 表头 | 表头 | 表头 || ---- | :---- | ----: | :----: || 单元格 | 左对齐 | 右对齐 | 居中对齐 |使用|来分割单元格，使用-来分割表头和其他行，使用:来确定当列的对齐方式使用html的&lt;table&gt;标签也可以做到 够你喝一壶了！","categories":[{"name":"工具","slug":"工具","permalink":"https://www.legr4ndk.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.legr4ndk.top/tags/markdown/"}]},{"title":"用Hexo配合GitHub快速上线自己的个人博客","slug":"HexoCourse","date":"2020-10-18T09:05:41.000Z","updated":"2021-03-14T10:17:28.594Z","comments":true,"path":"2020/10/18/HexoCourse/","link":"","permalink":"https://www.legr4ndk.top/2020/10/18/HexoCourse/","excerpt":"","text":"不想买服务器却又想创造属于自己的网站？Hexo可以帮你。 啥是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程可以让你快速上线属于你自己的博客。 事前准备你需要安装两个东西：Git和Node.js Git的安装教程在这儿。 Node.js可以直接在这儿下载，不要忘记把它加到环境变量中去。 安装完之后可以在命令行中输入 ➜ git --version #输入这个，下面是显示的内容git version 2.28.0.windows.1 ➜ npm --version #输入这个，下面是显示的内容6.14.8 如果均有回显版本号（可能你的版本和我的不一样），那么就说明安装成功了。 接下来因为要用到npm这个包管理器，所以先给npm的镜像站点换成国内的淘宝源，命令如下： ➜ npm config set registry https://registry.npm.taobao.org 然后准备工作就全部完成了。 安装Hexo需要以下几个命名，按顺序执行就行了： ➜ npm install hexo -g #安装hexo➜ npm install hexo-deployer-git --save #安装hexo的一个插件包，用于Git部署 安装完之后，你需要建立一个文件夹专门用来存放你的博客的文件，然后打开那个文件夹，在该文件夹里打开命令行窗口（Windows用户可以选择通过按住Shift并在文件夹窗口空白地区右键来打开PowerShell），现在需要初始化你的网站，命令行输入： ➜ hexo init #初始化hexo站点，init=initialize 此命令会从远程仓库克隆基础的Hexo站点模板，视你的网络条件（你懂）此过程可能持续数分钟，然后你的文件夹里会多很多文件，主文件夹结构大致如下： ├─node_modules #太大了不展开了├─scaffolds├─source #要展示在网页上的资源文件│ └─_posts #存放博客内的博文和媒体文件，博文以markdown存储└─themes #存放主题文件，自带一个landscape主题，此处以它为例，如果要用其他主题也请放入这边 └─landscape #主题存放文件夹，此处有主题的配置文件_config.yml ├─languages ├─layout │ ├─_partial │ │ └─post │ └─_widget ├─scripts └─source ├─css │ ├─fonts │ ├─images │ ├─_partial │ └─_util ├─fancybox │ └─helpers └─js 然后，你可以在命令行执行以下语句来清理已有网站内容 ➜ hexo clean 正式使用Hexo先介绍几个Hexo使用的基本命令： ➜ hexo generate #或者 hexo g，用来跟据你写好的md博文生成新的网页文件并链接➜ hexo server #或者hexo s,用于在本地的4000端口（127.0.0.1:4000）实时预览你的网页➜ hexo new 'xxx' #新建博文，会在主文件夹/source/_posts文件夹下创建xxx.md与同名媒体文件夹 编辑博文请在md文件内，博文的资源文件（如图片）请放到同名文件夹中并在md文件中使用相对地址链接来完成（比如./xxx/233.jpg)。 ——————那么做到这步我就假定你已经在刚刚生成的.md文件中写完文章了—————— 部署Hexo博客到GitHub毫无疑问你得先注册个GitHub，如果还没有的话，点这里去注册。 然后新建一个仓库，注意这个仓库必须是开源的，而且名字有一定要求：必须是 用户名.github.io 例如我的GitHub的id是legr4ndk，那么我的仓库名就是legr4ndk.github.io。 新建仓库之后，你可以在仓库里找到你仓库的链接，就像这样： https://github.com/YourGithubID/YourRepoName.git 然后打开你的本地Hexo文件夹，有个_config.yml文件（注意不是主题文件夹里的那个），使用你的代码编辑器打开它，划到最下面有个deploy标签，你需要编辑一下： #原来是这样的deploy: type: '' #你需要把它改成deploy: type: 'git' repository: https://github.com/YourGithubID/YourRepoName.git #这边写的是你的仓库链接，我这个只是范例 #注意冒号之后有空格 第16行还有个标签叫url，你需要把后面的值改成你的仓库名称，比如这样： url: http://YourGithubID.github.io 然后保存即可。 在部署前你必须使用hexo g重新生成网页文件。你可以运行hexo s命令先在本地检查你的网站还有没有问题。 部署使用一个命令： ➜ hexo deploy #或者hexo d，把本地生成的文件部署到GitHub上 如果你是第一次在命令行上面使用GitHub，那么将会有一个弹窗要求你登录你的GitHub，之后，你的网站将会被推送到GitHub上。过几分钟你就可以通过你的仓库名作为URL访问你的网站了。比如我的网站的地址就是legr4ndk.github.io。 注意事项 GitHub因为国内特殊环境可能出现无法访问，这个需要魔法上网。 每次deploy之后都需要几分钟后才能刷新观察到变化，切勿心急 每次写完新文章或者更换主题什么的之后，必须使用hexo g重新生成文件之后再部署 主题可以去这里寻找自己喜欢的，点击主题名字可以直接跳转主题的GitHub页面，跟据上面的教程安装即可。更改主题请去本地Hexo主文件夹的_config.yml内的theme标签更改。 主题内可能有部分依赖，建议换主题后在主题文件夹的命令行内运行npm install一键安装依赖（有的主题可能不行，建议查看主题的项目下的安装教程）。 到此为止你已经可以上线一个基础的个人网站了，接下来就是跟据主题的README.md文件介绍的那样去自己订制网页了。 Have fun~","categories":[{"name":"工具","slug":"工具","permalink":"https://www.legr4ndk.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.legr4ndk.top/tags/hexo/"}]},{"title":"C语言数字、指针、布尔值灵活利用的典范","slug":"TheCLanguageIsSoNB","date":"2020-10-16T16:12:19.000Z","updated":"2021-03-14T10:17:28.615Z","comments":true,"path":"2020/10/17/TheCLanguageIsSoNB/","link":"","permalink":"https://www.legr4ndk.top/2020/10/17/TheCLanguageIsSoNB/","excerpt":"","text":"先思考这个问题，假设我有一组数，我需要在每两个数字中间加入一个空格然后再输出出来，末尾和头部都没有空格，应该如何实现。 实现方法很简单，加个if就可以实现了，比如我想输出1 2 3 4 5 6，就可以这样： #include&lt;stdio.h&gt;int main(){ int arr[6] = { 1, 2, 3, 4, 5, 6 }; for (int i = 0; i &lt; 6; i++) { if (i == 5) //输出到最后一个数字了 printf(\"%d\", arr[i]); else printf(\"%d \", arr[i]); } return 0;} 我们利用一个if语句来判断是否输出到最后一个数字，来选择是否输出占位的空格。事实上，也可以对第一个数字特殊对待，然后剩余数据输出时附带一个空格。 但是如果我们这么做呢： #include&lt;stdio.h&gt;int main(){ int arr[6] = { 1, 2, 3, 4, 5, 6 }; for (int i = 0; i &lt; 6; i++) printf(\" %d\" + !i, arr[i]); return 0;} 极其简单的几句话完成了我们之前要的操作，一气呵成。 我详细叙述下它的过程： 玄机在于printf语句的那个加法上。C语言的字符串常量作参数，实际上是一个指向常量池中该字符串的指针，也就是可以进行运算。然后就是一个!i，这是把C语言中的整型数据当布尔值来看待，对他取非。当循环第一趟时，i=0，0在C语言中是false，非i得到true，默认为1，当那个指针+1，指针就从原来的指向空格，变成指向“%d”，那么就不会输出空格。而当之后几轮时，i均为非0数，C语言中为true，那么取非则得到false，即0，那么原指针+0，就是它本身，也就会正常输出空格，最后达到我们的要求。 这种写法说实话有很大局限性，可读性也极差，但是却很好的体现了C语言的灵活之处。C语言对数据和内存的操作极为灵活，这就要求使用者有很高的水平。这种写法不推荐在正式的程序设计中使用，但是对于开拓思维、优化程序是很有帮助的。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.legr4ndk.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.legr4ndk.top/tags/algorithm/"}]},{"title":"Use git to push your code to your Github's repository","slug":"GitPushBriefIntroduction","date":"2020-10-16T15:45:05.000Z","updated":"2021-03-14T10:17:28.589Z","comments":true,"path":"2020/10/16/GitPushBriefIntroduction/","link":"","permalink":"https://www.legr4ndk.top/2020/10/16/GitPushBriefIntroduction/","excerpt":"","text":"First things first,install git. ——Stop BBing if you have not even installed the git. Install git(may need root permission) Ubuntu/Debian/Deepin: apt install git Arch/Manjaro:pacman -S git Free BSD:pkg install git macOS:brew install git Windows:Click HERE to download the installer Run git –version to make sure that git is installed on your device. Put your codes to a folder and initializeNow you can copy+paste all your code that need to be pushed to the Github in your new folder.Then run a terminal in this folder. Using git init to initial your local repository. And do not forget to add a new repository in your Github account.Once you added a new repository to your Github,you will get a repository-link just like this: https://github.com/YourGithubID/YourRepoName.git Now,run git remote add origin $YourRepoLink to link your remote repository to the local one. Add your files to staging areaUse git add $Filename to add the files you need to staging area. Or you can use git add . (THERE IS A DOT AT THE END) to add all your files。 Then run git status to check the files in your local repository. Run git commit -m ‘$YourCommits’ to add some commits to this submit. Push your code to GithubFirst of all,use git pull origin master to pull your online repository. Use git push origin master to submit your files to Github. There are some cases that you will meet the ERROR that refusing to merge unrelated histories when you pull.You can try git pull origin master –allow-unrelated-histories to allow merging two unrelated branches.(At the first time,the online repository is empty but the local one have some files,so of course they are unrelated). Now you can check your new repository on the Github. Done,enjoy.","categories":[{"name":"工具","slug":"工具","permalink":"https://www.legr4ndk.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.legr4ndk.top/tags/git/"}]},{"title":"命名规则与驼峰命名法","slug":"NamingRuleAndCamelCase","date":"2020-10-16T13:44:37.000Z","updated":"2021-03-14T10:17:28.608Z","comments":true,"path":"2020/10/16/NamingRuleAndCamelCase/","link":"","permalink":"https://www.legr4ndk.top/2020/10/16/NamingRuleAndCamelCase/","excerpt":"","text":"还在使用x，y，z，a，b，c等无意义字符做变量名嘛？还因为把变量命名位g，s，b而遭到同学的嘲笑嘛？还因为不知道怎么命名变量能做的更直观嘛？ ——Introducing Camel-Case：驼峰命名法 我们现在先来看看一个例子： 假如我们想要定义一个变量存储我们的名字，该怎么命名呢？ mylastname 构成这个变量名的所有字母都通过小写被粗暴地整合在了一起，很难一眼看清，对吧？这种变量命名方法明显地降低了代码的可读性。要不，我们拆分一下单词？ my_last_mane 显而易见地，这个变量名的可读性比上面那种高了很多，我们可以轻易地读出它的各个单词并且很清楚地知道它的意思。但是很显然，这不够紧凑，我们还得多打两个字符（吐槽下这下划线真的不是很好按）。 驼峰命名法驼峰命名法的命名规格极为形象，通过大小写像驼峰一样变换来实现单词的区分，更方便直观地表示变量名。 那我们来看看驼峰命名法该怎么用： myLastName 相比于前两种，驼峰命名法既直观又紧凑，保证了代码可读性的同时也兼顾了效率。 驼峰命名法的规则是这样的： 当变量名或函数名是由多个单词连结在一起，构成的唯一识别字时，每一节个单词的首字母都采用大写来区分，单词与单词之间不额外添加下划线。 而以第一个单词的首字母是否要大写为区分，我们又可以分成大驼峰法和小驼峰法。 大驼峰法：包括第一个单词在内的所有单词的首字母全部大写，如： MyLastName DataBaseUser 小驼峰法：第一个单词的首字母不大写，其余每个单词的首字母均大写，如： myLastName studentsAverageGrades 驼峰命名法就介绍到这里。 接下来再讲讲我使用的一种命名规则。 强烈建议使用英文命名！！！ 变量的命名规则变量名的命名，首先应该是这个变量要储存的内容的英文意思。借助你强大的英文水平，先把你想好的中文变量名翻译成英文，不会的话就借助翻译软件吧。 然后，如果你翻译出来的内容仅由1个英文单词构成，请直接以这个单词的完全小写的形式命名这个变量。如果是由多个单词组成的词组，应该使用小驼峰法的方式为这个变量命名。 记住，它应该是个名词或者名词性词组。 例如： salary,tax,carSum,taxRate; 特殊地，给布尔类型的变量命名，建议使用 is + 属性名的方法，依照具体的语境，也可以用can，have，should等前缀代替is，同样使用小驼峰法。同时要记得避免使用否定词。例如： isReal,isHigh;(√)isNotTall,isError;(×) 常量的命名规则常量一般是指使用const关键字修饰定义的数据，有时也只使用预处理宏#define定义的数据。 使用const关键字定义的常量它的命名规则和变量类似，但是要使用大驼峰法，即第一个单词的首字母也要大写。例如： Line,SavingAccount,Pi; 使用#define关键字宏定义的常量它的所有字母都应该采用大写，同时，若是由多个单词组成的变量名，为了区分每个单词，在每两个单词之间应该添加下划线。例如： PI,MAX_SIZE; 函数/方法的命名规则函数的名称应该是一个动词或者一个动词词组。如果函数名仅由单个单词构成，那么请以这个单词的完全小写形式命名这个函数。如果这个函数名是一个动词词组，请以小驼峰法的方式命名这个函数。例如： getArea,setPath,takeSteps; 名字空间的命名规则（C++）对于名字空间，请以一个英文单词完成对它的命名，而且，应该使用它的完全小写形式。例如： model,common; 结构、类（C++）的命名规则结构体和类的名称应该是一个名词或者名词性词组。若使用单个单词命名，请首字母大写；若使用词组，应使用大驼峰法命名。例如： Node,SomeClass; 但是，命名结构和类形成的实例（结构体和对象）时，应该依照一般的变量的命名法进行命名。 对于枚举类型（以enum关键词声明）同样建议使用名词或者名词性词组，以首字母大写或者大驼峰法命名。 而对于枚举类型的枚举常量，建议以全部大写字母+下划线分割单词的方式命名,同时应尽量使用共同的类型名作为前缀。 例如： enum Color { COLOR_RED, COLOR_GREEN, COLOR_BLUE };enum ColorType { COLOR_TYPE_WARM, COLOR_TYPE_COLD }; 额外再提几个用于命名的关键字以及技巧，让代码更直观 get应该用在直接取得已设定值的函数中。 set应该用在直接为变量设定值的函数中。 compute应该用在用于进行计算的函数中。 find应该用在用于查找的函数中。 init/initialize应该使用在用于初始化的函数中。 在需要标识序号的变量名中，使用No + 序号比较合适。 布尔变量的命名应使用is，has等前缀，并且尽量避免否定词。 循环变量建议设置为i，j，k，并且建议优先使用i而把j，k用于循环嵌套。 对于缩略词我们有两种态度：1、对于那种缩写了人家可能就看不懂了的，比如cmd，init，请不要用缩写代替他们。2、对于那种缩写认识展开别人就看不懂的，比如HTML，CPU，老老实实写缩写。 另外，对于自己写的头文件的命名，推荐使用大驼峰命名法。例如 MyClass.hCppFunction.h OK,有关命名方法先写这么多。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2020-10-15T13:36:30.000Z","updated":"2021-03-14T10:17:28.593Z","comments":true,"path":"2020/10/15/HelloWorld/","link":"","permalink":"https://www.legr4ndk.top/2020/10/15/HelloWorld/","excerpt":"","text":"Hello World 哈哈哈今天布置了一个github上的Hexo静态站点 准备下次写个教程（flag插好） 这次我整了两个分部，gitee和github上面我都有布置 不得不吐槽一下gitee page 是真的难用，每次更新居然要去手动刷新，时效性还特么巨低 github就是GFW的锅了，太慢了太慢了，移动甚至都不让你上去 害，这边主要搬运一些之前写在别处的文章 还有随时想写的感想，所以不能算是纯技术类博客吧 （所以这站点名字叫QQ空间哈哈哈哈） 等我更新！ 宰🕊祭天 Update:Gitee pages太【自主规制】难用了，我把那边删了，以后只在GitHub上面发表。","categories":[{"name":"个人感悟","slug":"个人感悟","permalink":"https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://www.legr4ndk.top/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"耍","slug":"耍","permalink":"https://www.legr4ndk.top/categories/%E8%80%8D/"},{"name":"算法","slug":"算法","permalink":"https://www.legr4ndk.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"后端","slug":"后端","permalink":"https://www.legr4ndk.top/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","permalink":"https://www.legr4ndk.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"个人感悟","slug":"个人感悟","permalink":"https://www.legr4ndk.top/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"},{"name":"安全","slug":"安全","permalink":"https://www.legr4ndk.top/categories/%E5%AE%89%E5%85%A8/"},{"name":"客户端","slug":"客户端","permalink":"https://www.legr4ndk.top/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"https://www.legr4ndk.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"study","slug":"study","permalink":"https://www.legr4ndk.top/tags/study/"},{"name":"misc","slug":"misc","permalink":"https://www.legr4ndk.top/tags/misc/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.legr4ndk.top/tags/algorithm/"},{"name":"server","slug":"server","permalink":"https://www.legr4ndk.top/tags/server/"},{"name":"javascript","slug":"javascript","permalink":"https://www.legr4ndk.top/tags/javascript/"},{"name":"java","slug":"java","permalink":"https://www.legr4ndk.top/tags/java/"},{"name":"ctf","slug":"ctf","permalink":"https://www.legr4ndk.top/tags/ctf/"},{"name":"sql","slug":"sql","permalink":"https://www.legr4ndk.top/tags/sql/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://www.legr4ndk.top/tags/bootstrap/"},{"name":"csharp","slug":"csharp","permalink":"https://www.legr4ndk.top/tags/csharp/"},{"name":"cpp","slug":"cpp","permalink":"https://www.legr4ndk.top/tags/cpp/"},{"name":"markdown","slug":"markdown","permalink":"https://www.legr4ndk.top/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://www.legr4ndk.top/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://www.legr4ndk.top/tags/git/"}]}